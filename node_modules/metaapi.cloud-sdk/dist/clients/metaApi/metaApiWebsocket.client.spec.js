'use strict';

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _should = require('should');

var _should2 = _interopRequireDefault(_should);

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

var _metaApiWebsocket = require('./metaApiWebsocket.client');

var _metaApiWebsocket2 = _interopRequireDefault(_metaApiWebsocket);

var _socket = require('socket.io');

var _socket2 = _interopRequireDefault(_socket);

var _notConnectedError = require('./notConnectedError');

var _notConnectedError2 = _interopRequireDefault(_notConnectedError);

var _errorHandler = require('../errorHandler');

var _httpClient = require('../httpClient');

var _httpClient2 = _interopRequireDefault(_httpClient);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const metaapiApiUrl = 'https://mt-client-api-v1.agiliumtrade.agiliumtrade.ai';

/**
 * @test {MetaApiWebsocketClient}
 */
// eslint-disable-next-line max-statements
describe('MetaApiWebsocketClient', () => {

  let io;
  let server;
  let client;
  let sandbox;
  let httpClient = new _httpClient2.default();

  before(() => {
    sandbox = _sinon2.default.createSandbox();
  });

  beforeEach(async () => {
    client = new _metaApiWebsocket2.default(httpClient, 'token', { application: 'application',
      domain: 'project-stock.agiliumlabs.cloud', requestTimeout: 1.5, useSharedClientApi: true,
      retryOpts: { retries: 3, minDelayInSeconds: 0.1, maxDelayInSeconds: 0.5 } });
    client.url = 'http://localhost:6784';
    io = new _socket2.default(6784, { path: '/ws', pingTimeout: 1000000 });
    io.on('connect', socket => {
      server = socket;
      if (socket.request._query['auth-token'] !== 'token') {
        socket.emit({ error: 'UnauthorizedError', message: 'Authorization token invalid' });
        socket.close();
      }
    });
    client._socketInstancesByAccounts = { accountId: 0 };
    await client.connect();
    sandbox.stub(client._socketInstances[0].synchronizationThrottler, 'activeSynchronizationIds').get(() => []);
  });

  afterEach(async () => {
    sandbox.restore();
    let resolve;
    let promise = new _promise2.default(res => resolve = res);
    client.close();
    io.close(() => resolve());
    await promise;
  });

  /**
   * @test {MetaApiWebsocketClient#_tryReconnect}
   */
  it('should change client id on reconnect', async () => {
    const clock = _sinon2.default.useFakeTimers({ shouldAdvanceTime: true });
    client.close();
    let clientId;
    let connectAmount = 0;
    io.on('connect', socket => {
      connectAmount++;
      socket.request.headers['client-id'].should.equal(socket.request._query.clientId);
      socket.request.headers['client-id'].should.not.equal(clientId);
      socket.request._query.clientId.should.not.equal(clientId);
      clientId = socket.request._query.clientId;
      socket.disconnect();
    });
    await client.connect();
    await new _promise2.default(res => setTimeout(res, 50));
    await clock.tickAsync(1500);
    await new _promise2.default(res => setTimeout(res, 50));
    connectAmount.should.be.aboveOrEqual(2);
    clock.restore();
  });

  /**
   * @test {MetaApiWebsocketClient#_getServerUrl}
   */
  it('should connect to dedicated server', async () => {
    let positions = [{
      id: '46214692',
      type: 'POSITION_TYPE_BUY',
      symbol: 'GBPUSD',
      magic: 1000,
      time: new Date('2020-04-15T02:45:06.521Z'),
      updateTime: new Date('2020-04-15T02:45:06.521Z'),
      openPrice: 1.26101,
      currentPrice: 1.24883,
      currentTickValue: 1,
      volume: 0.07,
      swap: 0,
      profit: -85.25999999999966,
      commission: -0.25,
      clientId: 'TE_GBPUSD_7hyINWqAlE',
      stopLoss: 1.17721,
      unrealizedProfit: -85.25999999999901,
      realizedProfit: -6.536993168992922e-13
    }];
    let resolve;
    let promise = new _promise2.default(res => resolve = res);
    client.close();
    io.close(() => resolve());
    await promise;
    io = new _socket2.default(6785, { path: '/ws', pingTimeout: 1000000 });
    sandbox.stub(httpClient, 'request').resolves({ url: 'http://localhost:6785' });
    client = new _metaApiWebsocket2.default(httpClient, 'token', { application: 'application',
      domain: 'project-stock.agiliumlabs.cloud', requestTimeout: 1.5, useSharedClientApi: false,
      retryOpts: { retries: 3, minDelayInSeconds: 0.1, maxDelayInSeconds: 0.5 } });
    io.on('connect', socket => {
      server = socket;
      if (socket.request._query['auth-token'] !== 'token') {
        socket.emit({ error: 'UnauthorizedError', message: 'Authorization token invalid' });
        socket.close();
      }
      server.on('request', data => {
        if (data.type === 'getPositions' && data.accountId === 'accountId' && data.application === 'RPC') {
          server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, positions });
        }
      });
    });
    let actual = await client.getPositions('accountId');
    actual.should.match(positions);
  });

  /**
   * @test {MetaApiWebsocketClient#getAccountInformation}
   */
  it('should retrieve MetaTrader account information from API', async () => {
    let accountInformation = {
      broker: 'True ECN Trading Ltd',
      currency: 'USD',
      server: 'ICMarketsSC-Demo',
      balance: 7319.9,
      equity: 7306.649913200001,
      margin: 184.1,
      freeMargin: 7120.22,
      leverage: 100,
      marginLevel: 3967.58283542
    };
    server.on('request', data => {
      if (data.type === 'getAccountInformation' && data.accountId === 'accountId' && data.application === 'RPC') {
        server.emit('response', {
          type: 'response', accountId: data.accountId, requestId: data.requestId,
          accountInformation
        });
      }
    });
    let actual = await client.getAccountInformation('accountId');
    actual.should.match(accountInformation);
  });

  /**
   * @test {MetaApiWebsocketClient#getPositions}
   */
  it('should retrieve MetaTrader positions from API', async () => {
    let positions = [{
      id: '46214692',
      type: 'POSITION_TYPE_BUY',
      symbol: 'GBPUSD',
      magic: 1000,
      time: new Date('2020-04-15T02:45:06.521Z'),
      updateTime: new Date('2020-04-15T02:45:06.521Z'),
      openPrice: 1.26101,
      currentPrice: 1.24883,
      currentTickValue: 1,
      volume: 0.07,
      swap: 0,
      profit: -85.25999999999966,
      commission: -0.25,
      clientId: 'TE_GBPUSD_7hyINWqAlE',
      stopLoss: 1.17721,
      unrealizedProfit: -85.25999999999901,
      realizedProfit: -6.536993168992922e-13
    }];
    server.on('request', data => {
      if (data.type === 'getPositions' && data.accountId === 'accountId' && data.application === 'RPC') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, positions });
      }
    });
    let actual = await client.getPositions('accountId');
    actual.should.match(positions);
  });

  /**
   * @test {MetaApiWebsocketClient#getPosition}
   */
  it('should retrieve MetaTrader position from API by id', async () => {
    let position = {
      id: '46214692',
      type: 'POSITION_TYPE_BUY',
      symbol: 'GBPUSD',
      magic: 1000,
      time: new Date('2020-04-15T02:45:06.521Z'),
      updateTime: new Date('2020-04-15T02:45:06.521Z'),
      openPrice: 1.26101,
      currentPrice: 1.24883,
      currentTickValue: 1,
      volume: 0.07,
      swap: 0,
      profit: -85.25999999999966,
      commission: -0.25,
      clientId: 'TE_GBPUSD_7hyINWqAlE',
      stopLoss: 1.17721,
      unrealizedProfit: -85.25999999999901,
      realizedProfit: -6.536993168992922e-13
    };
    server.on('request', data => {
      if (data.type === 'getPosition' && data.accountId === 'accountId' && data.positionId === '46214692' && data.application === 'RPC') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, position });
      }
    });
    let actual = await client.getPosition('accountId', '46214692');
    actual.should.match(position);
  });

  /**
   * @test {MetaApiWebsocketClient#getOrders}
   */
  it('should retrieve MetaTrader orders from API', async () => {
    let orders = [{
      id: '46871284',
      type: 'ORDER_TYPE_BUY_LIMIT',
      state: 'ORDER_STATE_PLACED',
      symbol: 'AUDNZD',
      magic: 123456,
      platform: 'mt5',
      time: new Date('2020-04-20T08:38:58.270Z'),
      openPrice: 1.03,
      currentPrice: 1.05206,
      volume: 0.01,
      currentVolume: 0.01,
      comment: 'COMMENT2'
    }];
    server.on('request', data => {
      if (data.type === 'getOrders' && data.accountId === 'accountId' && data.application === 'RPC') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, orders });
      }
    });
    let actual = await client.getOrders('accountId');
    actual.should.match(orders);
  });

  /**
   * @test {MetaApiWebsocketClient#getOrder}
   */
  it('should retrieve MetaTrader order from API by id', async () => {
    let order = {
      id: '46871284',
      type: 'ORDER_TYPE_BUY_LIMIT',
      state: 'ORDER_STATE_PLACED',
      symbol: 'AUDNZD',
      magic: 123456,
      platform: 'mt5',
      time: new Date('2020-04-20T08:38:58.270Z'),
      openPrice: 1.03,
      currentPrice: 1.05206,
      volume: 0.01,
      currentVolume: 0.01,
      comment: 'COMMENT2'
    };
    server.on('request', data => {
      if (data.type === 'getOrder' && data.accountId === 'accountId' && data.orderId === '46871284' && data.application === 'RPC') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, order });
      }
    });
    let actual = await client.getOrder('accountId', '46871284');
    actual.should.match(order);
  });

  /**
   * @test {MetaApiWebsocketClient#getHistoryOrdersByTicket}
   */
  it('should retrieve MetaTrader history orders from API by ticket', async () => {
    let historyOrders = [{
      clientId: 'TE_GBPUSD_7hyINWqAlE',
      currentPrice: 1.261,
      currentVolume: 0,
      doneTime: new Date('2020-04-15T02:45:06.521Z'),
      id: '46214692',
      magic: 1000,
      platform: 'mt5',
      positionId: '46214692',
      state: 'ORDER_STATE_FILLED',
      symbol: 'GBPUSD',
      time: new Date('2020-04-15T02:45:06.260Z'),
      type: 'ORDER_TYPE_BUY',
      volume: 0.07
    }];
    server.on('request', data => {
      if (data.type === 'getHistoryOrdersByTicket' && data.accountId === 'accountId' && data.ticket === '46214692' && data.application === 'RPC') {
        server.emit('response', {
          type: 'response', accountId: data.accountId, requestId: data.requestId, historyOrders,
          synchronizing: false
        });
      }
    });
    let actual = await client.getHistoryOrdersByTicket('accountId', '46214692');
    actual.should.match({ historyOrders, synchronizing: false });
  });

  /**
   * @test {MetaApiWebsocketClient#getHistoryOrdersByPosition}
   */
  it('should retrieve MetaTrader history orders from API by position', async () => {
    let historyOrders = [{
      clientId: 'TE_GBPUSD_7hyINWqAlE',
      currentPrice: 1.261,
      currentVolume: 0,
      doneTime: new Date('2020-04-15T02:45:06.521Z'),
      id: '46214692',
      magic: 1000,
      platform: 'mt5',
      positionId: '46214692',
      state: 'ORDER_STATE_FILLED',
      symbol: 'GBPUSD',
      time: new Date('2020-04-15T02:45:06.260Z'),
      type: 'ORDER_TYPE_BUY',
      volume: 0.07
    }];
    server.on('request', data => {
      if (data.type === 'getHistoryOrdersByPosition' && data.accountId === 'accountId' && data.positionId === '46214692' && data.application === 'RPC') {
        server.emit('response', {
          type: 'response', accountId: data.accountId, requestId: data.requestId, historyOrders,
          synchronizing: false
        });
      }
    });
    let actual = await client.getHistoryOrdersByPosition('accountId', '46214692');
    actual.should.match({ historyOrders, synchronizing: false });
  });

  /**
   * @test {MetaApiWebsocketClient#getHistoryOrdersByTimeRange}
   */
  it('should retrieve MetaTrader history orders from API by time range', async () => {
    let historyOrders = [{
      clientId: 'TE_GBPUSD_7hyINWqAlE',
      currentPrice: 1.261,
      currentVolume: 0,
      doneTime: new Date('2020-04-15T02:45:06.521Z'),
      id: '46214692',
      magic: 1000,
      platform: 'mt5',
      positionId: '46214692',
      state: 'ORDER_STATE_FILLED',
      symbol: 'GBPUSD',
      time: new Date('2020-04-15T02:45:06.260Z'),
      type: 'ORDER_TYPE_BUY',
      volume: 0.07
    }];
    server.on('request', data => {
      if (data.type === 'getHistoryOrdersByTimeRange' && data.accountId === 'accountId' && data.startTime === '2020-04-15T02:45:00.000Z' && data.endTime === '2020-04-15T02:46:00.000Z' && data.offset === 1 && data.limit === 100 && data.application === 'RPC') {
        server.emit('response', {
          type: 'response', accountId: data.accountId, requestId: data.requestId, historyOrders,
          synchronizing: false
        });
      }
    });
    let actual = await client.getHistoryOrdersByTimeRange('accountId', new Date('2020-04-15T02:45:00.000Z'), new Date('2020-04-15T02:46:00.000Z'), 1, 100);
    actual.should.match({ historyOrders, synchronizing: false });
  });

  /**
   * @test {MetaApiWebsocketClient#getDealsByTicket}
   */
  it('should retrieve MetaTrader deals from API by ticket', async () => {
    let deals = [{
      clientId: 'TE_GBPUSD_7hyINWqAlE',
      commission: -0.25,
      entryType: 'DEAL_ENTRY_IN',
      id: '33230099',
      magic: 1000,
      platform: 'mt5',
      orderId: '46214692',
      positionId: '46214692',
      price: 1.26101,
      profit: 0,
      swap: 0,
      symbol: 'GBPUSD',
      time: new Date('2020-04-15T02:45:06.521Z'),
      type: 'DEAL_TYPE_BUY',
      volume: 0.07
    }];
    server.on('request', data => {
      if (data.type === 'getDealsByTicket' && data.accountId === 'accountId' && data.ticket === '46214692' && data.application === 'RPC') {
        server.emit('response', {
          type: 'response', accountId: data.accountId, requestId: data.requestId, deals,
          synchronizing: false
        });
      }
    });
    let actual = await client.getDealsByTicket('accountId', '46214692');
    actual.should.match({ deals, synchronizing: false });
  });

  /**
   * @test {MetaApiWebsocketClient#getDealsByPosition}
   */
  it('should retrieve MetaTrader deals from API by position', async () => {
    let deals = [{
      clientId: 'TE_GBPUSD_7hyINWqAlE',
      commission: -0.25,
      entryType: 'DEAL_ENTRY_IN',
      id: '33230099',
      magic: 1000,
      platform: 'mt5',
      orderId: '46214692',
      positionId: '46214692',
      price: 1.26101,
      profit: 0,
      swap: 0,
      symbol: 'GBPUSD',
      time: new Date('2020-04-15T02:45:06.521Z'),
      type: 'DEAL_TYPE_BUY',
      volume: 0.07
    }];
    server.on('request', data => {
      if (data.type === 'getDealsByPosition' && data.accountId === 'accountId' && data.positionId === '46214692' && data.application === 'RPC') {
        server.emit('response', {
          type: 'response', accountId: data.accountId, requestId: data.requestId, deals,
          synchronizing: false
        });
      }
    });
    let actual = await client.getDealsByPosition('accountId', '46214692');
    actual.should.match({ deals, synchronizing: false });
  });

  /**
   * @test {MetaApiWebsocketClient#getDealsByTimeRange}
   */
  it('should retrieve MetaTrader deals from API by time range', async () => {
    let deals = [{
      clientId: 'TE_GBPUSD_7hyINWqAlE',
      commission: -0.25,
      entryType: 'DEAL_ENTRY_IN',
      id: '33230099',
      magic: 1000,
      platform: 'mt5',
      orderId: '46214692',
      positionId: '46214692',
      price: 1.26101,
      profit: 0,
      swap: 0,
      symbol: 'GBPUSD',
      time: new Date('2020-04-15T02:45:06.521Z'),
      type: 'DEAL_TYPE_BUY',
      volume: 0.07
    }];
    server.on('request', data => {
      if (data.type === 'getDealsByTimeRange' && data.accountId === 'accountId' && data.startTime === '2020-04-15T02:45:00.000Z' && data.endTime === '2020-04-15T02:46:00.000Z' && data.offset === 1 && data.limit === 100 && data.application === 'RPC') {
        server.emit('response', {
          type: 'response', accountId: data.accountId, requestId: data.requestId, deals,
          synchronizing: false
        });
      }
    });
    let actual = await client.getDealsByTimeRange('accountId', new Date('2020-04-15T02:45:00.000Z'), new Date('2020-04-15T02:46:00.000Z'), 1, 100);
    actual.should.match({ deals, synchronizing: false });
  });

  /**
   * @test {MetaApiWebsocketClient#removeHistory}
   */
  it('should remove history from API', async () => {
    let requestReceived = false;
    server.on('request', data => {
      if (data.type === 'removeHistory' && data.accountId === 'accountId' && data.application === 'app') {
        requestReceived = true;
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId });
      }
    });
    await client.removeHistory('accountId', 'app');
    requestReceived.should.be.true();
  });

  /**
   * @test {MetaApiWebsocketClient#removeApplication}
   */
  it('should remove application from API', async () => {
    let requestReceived = false;
    server.on('request', data => {
      if (data.type === 'removeApplication' && data.accountId === 'accountId' && data.application === 'application') {
        requestReceived = true;
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId });
      }
    });
    await client.removeApplication('accountId');
    requestReceived.should.be.true();
  });

  /**
   * @test {MetaApiWebsocketClient#trade}
   */
  it('should execute a trade via new API version', async () => {
    let trade = {
      actionType: 'ORDER_TYPE_SELL',
      symbol: 'AUDNZD',
      volume: 0.07
    };
    let response = {
      numericCode: 10009,
      stringCode: 'TRADE_RETCODE_DONE',
      message: 'Request completed',
      orderId: '46870472'
    };
    server.on('request', data => {
      data.trade.should.match(trade);
      if (data.type === 'trade' && data.accountId === 'accountId' && data.application === 'application') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, response });
      }
    });
    let actual = await client.trade('accountId', trade);
    actual.should.match(response);
  });

  /**
   * @test {MetaApiWebsocketClient#trade}
   */
  it('should execute a trade via API and receive trade error from old API version', async () => {
    let trade = {
      actionType: 'ORDER_TYPE_SELL',
      symbol: 'AUDNZD',
      volume: 0.07
    };
    let response = {
      error: 10006,
      description: 'TRADE_RETCODE_REJECT',
      message: 'Request rejected',
      orderId: '46870472'
    };
    server.on('request', data => {
      data.trade.should.match(trade);
      if (data.type === 'trade' && data.accountId === 'accountId' && data.application === 'application') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, response });
      }
    });
    try {
      await client.trade('accountId', trade);
      _should2.default.fail('Trade error expected');
    } catch (err) {
      err.message.should.equal('Request rejected');
      err.name.should.equal('TradeError');
      err.stringCode.should.equal('TRADE_RETCODE_REJECT');
      err.numericCode.should.equal(10006);
    }
  });

  /**
   * @test {MetaApiWebsocketClient#subscribe}
   */
  it('should connect to MetaTrader terminal', async () => {
    let requestReceived = false;
    server.on('request', data => {
      if (data.type === 'subscribe' && data.accountId === 'accountId' && data.application === 'application' && data.instanceIndex === 1) {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId });
        requestReceived = true;
      }
    });
    await client.subscribe('accountId', 1);
    await new _promise2.default(res => setTimeout(res, 50));
    requestReceived.should.be.true();
  });

  /**
   * @test {MetaApiWebsocketClient#subscribe}
   */
  it('should create new instance when account limit is reached', async () => {
    _sinon2.default.assert.match(client.socketInstances.length, 1);
    for (let i = 0; i < 100; i++) {
      client._socketInstancesByAccounts['accountId' + i] = 0;
    }

    io.removeAllListeners('connect');
    io.on('connect', socket => {
      socket.on('request', data => {
        if (data.type === 'subscribe' && data.accountId === 'accountId101' && data.application === 'application' && data.instanceIndex === 1) {
          socket.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId });
        }
      });
    });
    await client.subscribe('accountId101', 1);
    await new _promise2.default(res => setTimeout(res, 50));
    _sinon2.default.assert.match(client.socketInstances.length, 2);
  });

  /**
   * @test {MetaApiWebsocketClient#subscribe}
   */
  it('should return error if connect to MetaTrader terminal failed', async () => {
    let requestReceived = false;
    server.on('request', data => {
      if (data.type === 'subscribe' && data.accountId === 'accountId' && data.application === 'application') {
        requestReceived = true;
      }
      server.emit('processingError', {
        id: 1, error: 'NotAuthenticatedError', message: 'Error message',
        requestId: data.requestId
      });
    });
    let success = true;
    try {
      await client.subscribe('accountId');
      success = false;
    } catch (err) {
      err.name.should.equal('NotConnectedError');
    }
    success.should.be.true();
    requestReceived.should.be.true();
  });

  /**
   * @test {MetaApiWebsocketClient#reconnect}
   */
  it('should reconnect to MetaTrader terminal', async () => {
    let requestReceived = false;
    server.on('request', data => {
      if (data.type === 'reconnect' && data.accountId === 'accountId' && data.application === 'application') {
        requestReceived = true;
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId });
      }
    });
    await client.reconnect('accountId');
    requestReceived.should.be.true();
  });

  /**
   * @test {MetaApiWebsocketClient#getSymbols}
   */
  it('should retrieve symbols from API', async () => {
    let symbols = ['EURUSD'];
    server.on('request', data => {
      if (data.type === 'getSymbols' && data.accountId === 'accountId' && data.application === 'RPC') {
        server.emit('response', {
          type: 'response', accountId: data.accountId, requestId: data.requestId, symbols
        });
      }
    });
    let actual = await client.getSymbols('accountId');
    actual.should.match(symbols);
  });

  /**
   * @test {MetaApiWebsocketClient#getSymbolSpecification}
   */
  it('should retrieve symbol specification from API', async () => {
    let specification = {
      symbol: 'AUDNZD',
      tickSize: 0.00001,
      minVolume: 0.01,
      maxVolume: 100,
      volumeStep: 0.01
    };
    server.on('request', data => {
      if (data.type === 'getSymbolSpecification' && data.accountId === 'accountId' && data.symbol === 'AUDNZD' && data.application === 'RPC') {
        server.emit('response', {
          type: 'response', accountId: data.accountId, requestId: data.requestId,
          specification
        });
      }
    });
    let actual = await client.getSymbolSpecification('accountId', 'AUDNZD');
    actual.should.match(specification);
  });

  /**
   * @test {MetaApiWebsocketClient#getSymbolPrice}
   */
  it('should retrieve symbol price from API', async () => {
    let price = {
      symbol: 'AUDNZD',
      bid: 1.05297,
      ask: 1.05309,
      profitTickValue: 0.59731,
      lossTickValue: 0.59736
    };
    server.on('request', data => {
      if (data.type === 'getSymbolPrice' && data.accountId === 'accountId' && data.symbol === 'AUDNZD' && data.application === 'RPC') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, price });
      }
    });
    let actual = await client.getSymbolPrice('accountId', 'AUDNZD');
    actual.should.match(price);
  });

  /**
   * @test {MetaApiWebsocketClient#getCandle}
   */
  it('should retrieve candle from API', async () => {
    let candle = {
      symbol: 'AUDNZD',
      timeframe: '15m',
      time: new Date('2020-04-07T03:45:00.000Z'),
      brokerTime: '2020-04-07 06:45:00.000',
      open: 1.03297,
      high: 1.06309,
      low: 1.02705,
      close: 1.043,
      tickVolume: 1435,
      spread: 17,
      volume: 345
    };
    server.on('request', data => {
      if (data.type === 'getCandle' && data.accountId === 'accountId' && data.symbol === 'AUDNZD' && data.application === 'RPC' && data.timeframe === '15m') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, candle });
      }
    });
    let actual = await client.getCandle('accountId', 'AUDNZD', '15m');
    actual.should.match(candle);
  });

  /**
   * @test {MetaApiWebsocketClient#getTick}
   */
  it('should retrieve latest tick from API', async () => {
    let tick = {
      symbol: 'AUDNZD',
      time: new Date('2020-04-07T03:45:00.000Z'),
      brokerTime: '2020-04-07 06:45:00.000',
      bid: 1.05297,
      ask: 1.05309,
      last: 0.5298,
      volume: 0.13,
      side: 'buy'
    };
    server.on('request', data => {
      if (data.type === 'getTick' && data.accountId === 'accountId' && data.symbol === 'AUDNZD' && data.application === 'RPC') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, tick });
      }
    });
    let actual = await client.getTick('accountId', 'AUDNZD');
    actual.should.match(tick);
  });

  /**
   * @test {MetaApiWebsocketClient#getBook}
   */
  it('should retrieve latest order book from API', async () => {
    let book = {
      symbol: 'AUDNZD',
      time: new Date('2020-04-07T03:45:00.000Z'),
      brokerTime: '2020-04-07 06:45:00.000',
      book: [{
        type: 'BOOK_TYPE_SELL',
        price: 1.05309,
        volume: 5.67
      }, {
        type: 'BOOK_TYPE_BUY',
        price: 1.05297,
        volume: 3.45
      }]
    };
    server.on('request', data => {
      if (data.type === 'getBook' && data.accountId === 'accountId' && data.symbol === 'AUDNZD' && data.application === 'RPC') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, book });
      }
    });
    let actual = await client.getBook('accountId', 'AUDNZD');
    actual.should.match(book);
  });

  /**
   * @test {MetaApiWebsocketClient#sendUptime}
   */
  it('should sent uptime stats to the server', async () => {
    server.on('request', data => {
      if (data.type === 'saveUptime' && data.accountId === 'accountId' && (0, _stringify2.default)(data.uptime) === (0, _stringify2.default)({ '1h': 100 }) && data.application === 'application') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId });
      }
    });
    await client.saveUptime('accountId', { '1h': 100 });
  });

  /**
   * @test {MetaApiWebsocketClient#unsubscribe}
   */
  it('should unsubscribe from account data', async () => {
    let requestReceived = false;

    let response = { type: 'response', accountId: 'accountId' };
    server.on('request', data => {
      if (data.type === 'unsubscribe' && data.accountId === 'accountId') {
        requestReceived = true;
        server.emit('response', (0, _assign2.default)({ requestId: data.requestId }, response));
      }
    });
    await client.unsubscribe('accountId');
    _sinon2.default.assert.match(requestReceived, true);
    client.socketInstancesByAccounts.should.not.have.property('accountId');
  });

  /**
   * @test {MetaApiWebsocketClient#unsubscribe}
   */
  it('should ignore not found exception on unsubscribe', async () => {
    server.on('request', data => {
      server.emit('processingError', {
        id: 1, error: 'ValidationError', message: 'Validation failed',
        details: [{ parameter: 'volume', message: 'Required value.' }], requestId: data.requestId
      });
    });
    try {
      await client.unsubscribe('accountId');
      throw new Error('ValidationError extected');
    } catch (err) {
      err.name.should.equal('ValidationError');
      err.details.should.match([{
        parameter: 'volume',
        message: 'Required value.'
      }]);
    }
    server.removeAllListeners('request');
    server.on('request', data => {
      server.emit('processingError', {
        id: 1, error: 'NotFoundError', message: 'Account not found', requestId: data.requestId
      });
    });
    await client.unsubscribe('accountId');
  });

  describe('error handling', () => {

    /**
     * @test {MetaApiWebsocketClient#trade}
     */
    it('should handle ValidationError', async () => {
      let trade = {
        actionType: 'ORDER_TYPE_SELL',
        symbol: 'AUDNZD'
      };
      server.on('request', data => {
        server.emit('processingError', {
          id: 1, error: 'ValidationError', message: 'Validation failed',
          details: [{ parameter: 'volume', message: 'Required value.' }], requestId: data.requestId
        });
      });
      try {
        await client.trade('accountId', trade);
        throw new Error('ValidationError extected');
      } catch (err) {
        err.name.should.equal('ValidationError');
        err.details.should.match([{
          parameter: 'volume',
          message: 'Required value.'
        }]);
      }
    });

    /**
     * @test {MetaApiWebsocketClient#getPosition}
     */
    it('should handle NotFoundError', async () => {
      server.on('request', data => {
        server.emit('processingError', {
          id: 1, error: 'NotFoundError', message: 'Position id 1234 not found',
          requestId: data.requestId
        });
      });
      try {
        await client.getPosition('accountId', '1234');
        throw new Error('NotFoundError extected');
      } catch (err) {
        err.name.should.equal('NotFoundError');
      }
    });

    /**
     * @test {MetaApiWebsocketClient#getPosition}
     */
    it('should handle NotSynchronizedError', async () => {
      server.on('request', data => {
        server.emit('processingError', {
          id: 1, error: 'NotSynchronizedError', message: 'Error message',
          requestId: data.requestId
        });
      });
      try {
        await client.getPosition('accountId', '1234');
        throw new Error('NotSynchronizedError extected');
      } catch (err) {
        err.name.should.equal('NotSynchronizedError');
      }
    }).timeout(8000);

    /**
     * @test {MetaApiWebsocketClient#getPosition}
     */
    it('should handle NotConnectedError', async () => {
      server.on('request', data => {
        server.emit('processingError', {
          id: 1, error: 'NotAuthenticatedError', message: 'Error message',
          requestId: data.requestId
        });
      });
      try {
        await client.getPosition('accountId', '1234');
        throw new Error('NotConnectedError extected');
      } catch (err) {
        err.name.should.equal('NotConnectedError');
      }
    });

    /**
     * @test {MetaApiWebsocketClient#getPosition}
     */
    it('should handle other errors', async () => {
      server.on('request', data => {
        server.emit('processingError', {
          id: 1, error: 'Error', message: 'Error message',
          requestId: data.requestId
        });
      });
      try {
        await client.getPosition('accountId', '1234');
        throw new Error('InternalError extected');
      } catch (err) {
        err.name.should.equal('InternalError');
      }
    }).timeout(8000);
  });

  describe('connection status synchronization', () => {

    afterEach(() => {
      client.removeAllListeners();
    });

    it('should process authenticated synchronization event', async () => {
      let listener = {
        onConnected: () => {}
      };
      sandbox.stub(listener, 'onConnected').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 1, replicas: 2 });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onConnected, '1:ps-mpa-1', 2);
    });

    it('should process authenticated synchronization event with session id', async () => {
      let listener = {
        onConnected: () => {}
      };
      sandbox.stub(listener, 'onConnected').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 2, replicas: 4, sessionId: 'wrong' });
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 1, replicas: 2, sessionId: client._sessionId });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.callCount(listener.onConnected, 1);
      _sinon2.default.assert.calledWith(listener.onConnected, '1:ps-mpa-1', 2);
    });

    it('should process broker connection status event', async () => {
      let listener = {
        onConnected: () => {},
        onBrokerConnectionStatusChanged: () => {}
      };
      sandbox.stub(listener, 'onBrokerConnectionStatusChanged').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 1 });
      server.emit('synchronization', { type: 'status', accountId: 'accountId', host: 'ps-mpa-1', connected: true,
        instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onBrokerConnectionStatusChanged, '1:ps-mpa-1', true);
    });

    it('should call an onDisconnect if there was no signal for a long time', async () => {
      const clock = _sinon2.default.useFakeTimers({ shouldAdvanceTime: true });
      let listener = {
        onConnected: () => {},
        onDisconnected: () => {},
        onBrokerConnectionStatusChanged: () => {}
      };
      sandbox.stub(listener, 'onDisconnected').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 1, replicas: 2 });
      server.emit('synchronization', { type: 'status', accountId: 'accountId', host: 'ps-mpa-1', connected: true,
        instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      await clock.tickAsync(10000);
      await server.emit('synchronization', { type: 'status', accountId: 'accountId', host: 'ps-mpa-1', connected: true,
        instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      await clock.tickAsync(55000);
      _sinon2.default.assert.notCalled(listener.onDisconnected);
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 1, replicas: 2 });
      await new _promise2.default(res => setTimeout(res, 50));
      await clock.tickAsync(10000);
      _sinon2.default.assert.notCalled(listener.onDisconnected);
      await clock.tickAsync(55000);
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onDisconnected, '1:ps-mpa-1');
      clock.restore();
    });

    it('should close stream on timeout if another stream exists', async () => {
      const clock = _sinon2.default.useFakeTimers({ shouldAdvanceTime: true });
      let listener = {
        onConnected: () => {},
        onDisconnected: () => {},
        onStreamClosed: () => {},
        onBrokerConnectionStatusChanged: () => {}
      };
      const onTimeoutStub = sandbox.stub(client._subscriptionManager, 'onTimeout').resolves();
      const onStreamClosedStub = sandbox.stub(listener, 'onStreamClosed').resolves();
      const onDisconnectedStub = sandbox.stub(listener, 'onDisconnected').resolves();
      sandbox.stub(client._subscriptionManager, 'onDisconnected').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 1, replicas: 2 });
      await new _promise2.default(res => setTimeout(res, 50));
      await clock.tickAsync(15000);
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-2',
        instanceIndex: 1, replicas: 2 });
      server.emit('synchronization', { type: 'status', accountId: 'accountId', host: 'ps-mpa-1', connected: true,
        instanceIndex: 1 });
      server.emit('synchronization', { type: 'status', accountId: 'accountId', host: 'ps-mpa-2', connected: true,
        instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      await clock.tickAsync(15000);
      server.emit('synchronization', { type: 'status', accountId: 'accountId', host: 'ps-mpa-1', connected: true,
        instanceIndex: 1 });
      server.emit('synchronization', { type: 'status', accountId: 'accountId', host: 'ps-mpa-2', connected: true,
        instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      await clock.tickAsync(55000);
      _sinon2.default.assert.notCalled(onDisconnectedStub);
      server.emit('synchronization', { type: 'status', accountId: 'accountId', host: 'ps-mpa-1', connected: true,
        instanceIndex: 1 });
      server.emit('synchronization', { type: 'status', accountId: 'accountId', host: 'ps-mpa-2', connected: true,
        instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      await clock.tickAsync(15000);
      server.emit('synchronization', { type: 'status', accountId: 'accountId', host: 'ps-mpa-2', connected: true,
        instanceIndex: 1 });
      _sinon2.default.assert.notCalled(onDisconnectedStub);
      await new _promise2.default(res => setTimeout(res, 50));
      await clock.tickAsync(55000);
      _sinon2.default.assert.calledWith(onStreamClosedStub, '1:ps-mpa-1');
      _sinon2.default.assert.notCalled(onDisconnectedStub);
      _sinon2.default.assert.notCalled(onTimeoutStub);
      await new _promise2.default(res => setTimeout(res, 50));
      await clock.tickAsync(15000);
      _sinon2.default.assert.calledWith(onDisconnectedStub, '1:ps-mpa-2');
      _sinon2.default.assert.notCalled(client._subscriptionManager.onDisconnected);
      _sinon2.default.assert.calledWith(onTimeoutStub, 'accountId', 1);
      clock.restore();
    });

    it('should process server-side health status event', async () => {
      let listener = {
        onConnected: () => {},
        onBrokerConnectionStatusChanged: () => {},
        onHealthStatus: () => {}
      };
      sandbox.stub(listener, 'onHealthStatus').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 1 });
      server.emit('synchronization', { type: 'status', accountId: 'accountId', host: 'ps-mpa-1', connected: true,
        healthStatus: { restApiHealthy: true }, instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onHealthStatus, '1:ps-mpa-1', { restApiHealthy: true });
    });

    it('should process disconnected synchronization event', async () => {
      let listener = {
        onConnected: () => {},
        onDisconnected: () => {}
      };
      sandbox.stub(listener, 'onDisconnected').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 1 });
      server.emit('synchronization', { type: 'disconnected', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onDisconnected, '1:ps-mpa-1');
    });

    it('should close the stream if host name disconnected and another stream exists', async () => {
      let listener = {
        onConnected: () => {},
        onDisconnected: () => {},
        onStreamClosed: () => {}
      };
      sandbox.stub(listener, 'onDisconnected').resolves();
      sandbox.stub(listener, 'onStreamClosed').resolves();
      const onDisconnectedStub = sandbox.stub(client._subscriptionManager, 'onDisconnected').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 1, replicas: 2 });
      server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-2',
        instanceIndex: 1, replicas: 2 });
      server.emit('synchronization', { type: 'disconnected', accountId: 'accountId', host: 'ps-mpa-1',
        instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onStreamClosed, '1:ps-mpa-1');
      _sinon2.default.assert.notCalled(listener.onDisconnected);
      _sinon2.default.assert.notCalled(onDisconnectedStub);
      server.emit('synchronization', { type: 'disconnected', accountId: 'accountId', host: 'ps-mpa-2',
        instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledOnce(listener.onDisconnected);
      _sinon2.default.assert.calledWith(onDisconnectedStub, 'accountId', 1);
    });
  });

  describe('terminal state synchronization', () => {

    afterEach(() => {
      client.removeAllListeners();
    });

    it('should only accept packets with own synchronization ids', async () => {
      let listener = {
        onAccountInformationUpdated: () => {}
      };
      sandbox.stub(listener, 'onAccountInformationUpdated').resolves();
      client.addSynchronizationListener('accountId', listener);
      sandbox.stub(client._socketInstances[0].synchronizationThrottler, 'activeSynchronizationIds').get(() => ['synchronizationId']);
      server.emit('synchronization', { type: 'accountInformation', accountId: 'accountId',
        accountInformation: {}, instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.callCount(listener.onAccountInformationUpdated, 1);
      server.emit('synchronization', { type: 'accountInformation', accountId: 'accountId',
        accountInformation: {}, instanceIndex: 1, synchronizationId: 'wrong' });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.callCount(listener.onAccountInformationUpdated, 1);
      server.emit('synchronization', { type: 'accountInformation', accountId: 'accountId',
        accountInformation: {}, instanceIndex: 1, synchronizationId: 'synchronizationId' });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.callCount(listener.onAccountInformationUpdated, 2);
    });

    /**
     * @test {MetaApiWebsocketClient#synchronize}
     */
    it('should synchronize with MetaTrader terminal', async () => {
      let requestReceived = false;
      // eslint-disable-next-line complexity
      server.on('request', data => {
        if (data.type === 'synchronize' && data.accountId === 'accountId' && data.host === 'ps-mpa-1' && data.startingHistoryOrderTime === '2020-01-01T00:00:00.000Z' && data.startingDealTime === '2020-01-02T00:00:00.000Z' && data.requestId === 'synchronizationId' && data.application === 'application' && data.instanceIndex === 1) {
          requestReceived = true;
          server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId });
        }
      });
      await client.synchronize('accountId', 1, 'ps-mpa-1', 'synchronizationId', new Date('2020-01-01T00:00:00.000Z'), new Date('2020-01-02T00:00:00.000Z'));
      requestReceived.should.be.true();
    });

    it('should process synchronization started event', async () => {
      let listener = {
        onSynchronizationStarted: () => {}
      };
      sandbox.stub(listener, 'onSynchronizationStarted').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'synchronizationStarted', accountId: 'accountId', instanceIndex: 1,
        host: 'ps-mpa-1' });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onSynchronizationStarted, '1:ps-mpa-1');
    });

    it('should synchronize account information', async () => {
      let accountInformation = {
        broker: 'True ECN Trading Ltd',
        currency: 'USD',
        server: 'ICMarketsSC-Demo',
        balance: 7319.9,
        equity: 7306.649913200001,
        margin: 184.1,
        freeMargin: 7120.22,
        leverage: 100,
        marginLevel: 3967.58283542
      };
      let listener = {
        onAccountInformationUpdated: () => {}
      };
      sandbox.stub(listener, 'onAccountInformationUpdated').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'accountInformation', accountId: 'accountId',
        host: 'ps-mpa-1', accountInformation, instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onAccountInformationUpdated, '1:ps-mpa-1', accountInformation);
    });

    it('should synchronize positions', async () => {
      let positions = [{
        id: '46214692',
        type: 'POSITION_TYPE_BUY',
        symbol: 'GBPUSD',
        magic: 1000,
        time: new Date('2020-04-15T02:45:06.521Z'),
        updateTime: new Date('2020-04-15T02:45:06.521Z'),
        openPrice: 1.26101,
        currentPrice: 1.24883,
        currentTickValue: 1,
        volume: 0.07,
        swap: 0,
        profit: -85.25999999999966,
        commission: -0.25,
        clientId: 'TE_GBPUSD_7hyINWqAlE',
        stopLoss: 1.17721,
        unrealizedProfit: -85.25999999999901,
        realizedProfit: -6.536993168992922e-13
      }];
      let listener = {
        onPositionsReplaced: () => {}
      };
      sandbox.stub(listener, 'onPositionsReplaced').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'positions', accountId: 'accountId', positions, instanceIndex: 1,
        host: 'ps-mpa-1' });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onPositionsReplaced, '1:ps-mpa-1', positions);
    });

    it('should synchronize orders', async () => {
      let orders = [{
        id: '46871284',
        type: 'ORDER_TYPE_BUY_LIMIT',
        state: 'ORDER_STATE_PLACED',
        symbol: 'AUDNZD',
        magic: 123456,
        platform: 'mt5',
        time: new Date('2020-04-20T08:38:58.270Z'),
        openPrice: 1.03,
        currentPrice: 1.05206,
        volume: 0.01,
        currentVolume: 0.01,
        comment: 'COMMENT2'
      }];
      let listener = {
        onOrdersReplaced: () => {}
      };
      sandbox.stub(listener, 'onOrdersReplaced').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'orders', accountId: 'accountId', orders, instanceIndex: 1,
        host: 'ps-mpa-1' });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onOrdersReplaced, '1:ps-mpa-1', orders);
    });

    it('should synchronize history orders', async () => {
      let historyOrders = [{
        clientId: 'TE_GBPUSD_7hyINWqAlE',
        currentPrice: 1.261,
        currentVolume: 0,
        doneTime: new Date('2020-04-15T02:45:06.521Z'),
        id: '46214692',
        magic: 1000,
        platform: 'mt5',
        positionId: '46214692',
        state: 'ORDER_STATE_FILLED',
        symbol: 'GBPUSD',
        time: new Date('2020-04-15T02:45:06.260Z'),
        type: 'ORDER_TYPE_BUY',
        volume: 0.07
      }];
      let listener = {
        onHistoryOrderAdded: () => {}
      };
      sandbox.stub(listener, 'onHistoryOrderAdded').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'historyOrders', accountId: 'accountId', historyOrders,
        instanceIndex: 1, host: 'ps-mpa-1' });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onHistoryOrderAdded, '1:ps-mpa-1', historyOrders[0]);
    });

    it('should synchronize deals', async () => {
      let deals = [{
        clientId: 'TE_GBPUSD_7hyINWqAlE',
        commission: -0.25,
        entryType: 'DEAL_ENTRY_IN',
        id: '33230099',
        magic: 1000,
        platform: 'mt5',
        orderId: '46214692',
        positionId: '46214692',
        price: 1.26101,
        profit: 0,
        swap: 0,
        symbol: 'GBPUSD',
        time: new Date('2020-04-15T02:45:06.521Z'),
        type: 'DEAL_TYPE_BUY',
        volume: 0.07
      }];
      let listener = {
        onDealAdded: () => {}
      };
      sandbox.stub(listener, 'onDealAdded').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'deals', accountId: 'accountId', deals, instanceIndex: 1,
        host: 'ps-mpa-1' });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onDealAdded, '1:ps-mpa-1', deals[0]);
    });

    it('should process synchronization updates', async () => {
      let update = {
        accountInformation: {
          broker: 'True ECN Trading Ltd',
          currency: 'USD',
          server: 'ICMarketsSC-Demo',
          balance: 7319.9,
          equity: 7306.649913200001,
          margin: 184.1,
          freeMargin: 7120.22,
          leverage: 100,
          marginLevel: 3967.58283542
        },
        updatedPositions: [{
          id: '46214692',
          type: 'POSITION_TYPE_BUY',
          symbol: 'GBPUSD',
          magic: 1000,
          time: new Date('2020-04-15T02:45:06.521Z'),
          updateTime: new Date('2020-04-15T02:45:06.521Z'),
          openPrice: 1.26101,
          currentPrice: 1.24883,
          currentTickValue: 1,
          volume: 0.07,
          swap: 0,
          profit: -85.25999999999966,
          commission: -0.25,
          clientId: 'TE_GBPUSD_7hyINWqAlE',
          stopLoss: 1.17721,
          unrealizedProfit: -85.25999999999901,
          realizedProfit: -6.536993168992922e-13
        }],
        removedPositionIds: ['1234'],
        updatedOrders: [{
          id: '46871284',
          type: 'ORDER_TYPE_BUY_LIMIT',
          state: 'ORDER_STATE_PLACED',
          symbol: 'AUDNZD',
          magic: 123456,
          platform: 'mt5',
          time: new Date('2020-04-20T08:38:58.270Z'),
          openPrice: 1.03,
          currentPrice: 1.05206,
          volume: 0.01,
          currentVolume: 0.01,
          comment: 'COMMENT2'
        }],
        completedOrderIds: ['2345'],
        historyOrders: [{
          clientId: 'TE_GBPUSD_7hyINWqAlE',
          currentPrice: 1.261,
          currentVolume: 0,
          doneTime: new Date('2020-04-15T02:45:06.521Z'),
          id: '46214692',
          magic: 1000,
          platform: 'mt5',
          positionId: '46214692',
          state: 'ORDER_STATE_FILLED',
          symbol: 'GBPUSD',
          time: new Date('2020-04-15T02:45:06.260Z'),
          type: 'ORDER_TYPE_BUY',
          volume: 0.07
        }],
        deals: [{
          clientId: 'TE_GBPUSD_7hyINWqAlE',
          commission: -0.25,
          entryType: 'DEAL_ENTRY_IN',
          id: '33230099',
          magic: 1000,
          platform: 'mt5',
          orderId: '46214692',
          positionId: '46214692',
          price: 1.26101,
          profit: 0,
          swap: 0,
          symbol: 'GBPUSD',
          time: new Date('2020-04-15T02:45:06.521Z'),
          type: 'DEAL_TYPE_BUY',
          volume: 0.07
        }]
      };
      let listener = {
        onAccountInformationUpdated: () => {},
        onPositionUpdated: () => {},
        onPositionRemoved: () => {},
        onOrderUpdated: () => {},
        onOrderCompleted: () => {},
        onHistoryOrderAdded: () => {},
        onDealAdded: () => {}
      };
      sandbox.stub(listener, 'onAccountInformationUpdated').resolves();
      sandbox.stub(listener, 'onPositionUpdated').resolves();
      sandbox.stub(listener, 'onPositionRemoved').resolves();
      sandbox.stub(listener, 'onOrderUpdated').resolves();
      sandbox.stub(listener, 'onOrderCompleted').resolves();
      sandbox.stub(listener, 'onHistoryOrderAdded').resolves();
      sandbox.stub(listener, 'onDealAdded').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', (0, _assign2.default)({ type: 'update', accountId: 'accountId', instanceIndex: 1,
        host: 'ps-mpa-1' }, update));
      await new _promise2.default(res => setTimeout(res, 100));
      _sinon2.default.assert.calledWith(listener.onAccountInformationUpdated, '1:ps-mpa-1', update.accountInformation);
      _sinon2.default.assert.calledWith(listener.onPositionUpdated, '1:ps-mpa-1', update.updatedPositions[0]);
      _sinon2.default.assert.calledWith(listener.onPositionRemoved, '1:ps-mpa-1', update.removedPositionIds[0]);
      _sinon2.default.assert.calledWith(listener.onOrderUpdated, '1:ps-mpa-1', update.updatedOrders[0]);
      _sinon2.default.assert.calledWith(listener.onOrderCompleted, '1:ps-mpa-1', update.completedOrderIds[0]);
      _sinon2.default.assert.calledWith(listener.onHistoryOrderAdded, '1:ps-mpa-1', update.historyOrders[0]);
      _sinon2.default.assert.calledWith(listener.onDealAdded, '1:ps-mpa-1', update.deals[0]);
    });
  });

  describe('market data synchronization', () => {

    afterEach(() => {
      client.removeAllListeners();
    });

    /**
     * @test {MetaApiWebsocketClient#_rpcRequest}
     */
    it('should retry request on failure', async () => {
      let requestCounter = 0;
      let order = {
        id: '46871284',
        type: 'ORDER_TYPE_BUY_LIMIT',
        state: 'ORDER_STATE_PLACED',
        symbol: 'AUDNZD',
        magic: 123456,
        platform: 'mt5',
        time: new Date('2020-04-20T08:38:58.270Z'),
        openPrice: 1.03,
        currentPrice: 1.05206,
        volume: 0.01,
        currentVolume: 0.01,
        comment: 'COMMENT2'
      };
      server.on('request', data => {
        if (requestCounter > 1 && data.type === 'getOrder' && data.accountId === 'accountId' && data.orderId === '46871284' && data.application === 'RPC') {
          server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, order });
        }
        requestCounter++;
      });
      let actual = await client.getOrder('accountId', '46871284');
      actual.should.match(order);
    }).timeout(20000);

    /**
     * @test {MetaApiWebsocketClient#_rpcRequest}
     */
    it('should wait specified amount of time on too many requests error', async () => {
      let requestCounter = 0;
      let order = {
        id: '46871284',
        type: 'ORDER_TYPE_BUY_LIMIT',
        state: 'ORDER_STATE_PLACED',
        symbol: 'AUDNZD',
        magic: 123456,
        platform: 'mt5',
        time: new Date('2020-04-20T08:38:58.270Z'),
        openPrice: 1.03,
        currentPrice: 1.05206,
        volume: 0.01,
        currentVolume: 0.01,
        comment: 'COMMENT2'
      };
      server.on('request', data => {
        if (requestCounter > 0 && data.type === 'getOrder' && data.accountId === 'accountId' && data.orderId === '46871284' && data.application === 'RPC') {
          server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, order });
        } else {
          server.emit('processingError', {
            id: 1, error: 'TooManyRequestsError', requestId: data.requestId,
            message: 'The API allows 10000 requests per 60 minutes to avoid overloading our servers.',
            status_code: 429, metadata: {
              periodInMinutes: 60, maxRequestsForPeriod: 10000,
              recommendedRetryTime: new Date(Date.now() + 1000)
            }
          });
        }
        requestCounter++;
      });
      const startTime = Date.now();
      let actual = await client.getOrder('accountId', '46871284');
      actual.should.match(order);
      (Date.now() - startTime).should.be.approximately(1000, 100);
    }).timeout(10000);

    /**
     * @test {MetaApiWebsocketClient#_rpcRequest}
     */
    it('should return too many requests exception if recommended time is beyond max request time', async () => {
      let requestCounter = 0;
      let order = {
        id: '46871284',
        type: 'ORDER_TYPE_BUY_LIMIT',
        state: 'ORDER_STATE_PLACED',
        symbol: 'AUDNZD',
        magic: 123456,
        platform: 'mt5',
        time: new Date('2020-04-20T08:38:58.270Z'),
        openPrice: 1.03,
        currentPrice: 1.05206,
        volume: 0.01,
        currentVolume: 0.01,
        comment: 'COMMENT2'
      };
      server.on('request', data => {
        if (requestCounter > 0 && data.type === 'getOrder' && data.accountId === 'accountId' && data.orderId === '46871284' && data.application === 'RPC') {
          server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, order });
        } else {
          server.emit('processingError', {
            id: 1, error: 'TooManyRequestsError', requestId: data.requestId,
            message: 'The API allows 10000 requests per 60 minutes to avoid overloading our servers.',
            status_code: 429, metadata: {
              periodInMinutes: 60, maxRequestsForPeriod: 10000,
              recommendedRetryTime: new Date(Date.now() + 60000)
            }
          });
        }
        requestCounter++;
      });

      try {
        await client.getOrder('accountId', '46871284');
        throw new Error('TooManyRequestsError expected');
      } catch (err) {
        err.name.should.equal('TooManyRequestsError');
      }
    }).timeout(10000);

    /**
     * @test {MetaApiWebsocketClient#_rpcRequest}
     */
    it('should not retry request on validation error', async () => {
      let requestCounter = 0;
      server.on('request', data => {
        if (requestCounter > 0 && data.type === 'subscribeToMarketData' && data.accountId === 'accountId' && data.symbol === 'EURUSD' && data.application === 'application' && data.instanceIndex === 1) {
          server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId });
        } else {
          server.emit('processingError', {
            id: 1, error: 'ValidationError', message: 'Error message', requestId: data.requestId
          });
        }
        requestCounter++;
      });
      try {
        await client.subscribeToMarketData('accountId', 1, 'EURUSD');
        throw new Error('ValidationError expected');
      } catch (err) {
        err.name.should.equal('ValidationError');
      }
      _sinon2.default.assert.match(requestCounter, 1);
    }).timeout(6000);

    /**
     * @test {MetaApiWebsocketClient#_rpcRequest}
     */
    it('should not retry trade requests on fail', async () => {
      let requestCounter = 0;
      let trade = {
        actionType: 'ORDER_TYPE_SELL',
        symbol: 'AUDNZD',
        volume: 0.07
      };
      server.on('request', data => {
        if (data.type === 'trade' && data.accountId === 'accountId' && data.application === 'application') {
          if (requestCounter > 0) {
            _sinon2.default.assert.fail();
          }
          requestCounter++;
        }
      });
      try {
        await client.trade(trade);
        throw new Error('TimeoutError expected');
      } catch (err) {
        err.name.should.equal('TimeoutError');
      }
    }).timeout(6000);

    /**
     * @test {MetaApiWebsocketClient#_rpcRequest}
     */
    it('should not retry request if connection closed between retries', async () => {
      let requestCounter = 0;
      let response = { type: 'response', accountId: 'accountId' };
      server.on('request', async data => {
        if (data.type === 'unsubscribe' && data.accountId === 'accountId') {
          server.emit('response', (0, _assign2.default)({ requestId: data.requestId }, response));
        }

        if (data.type === 'getOrders' && data.accountId === 'accountId' && data.application === 'RPC') {
          requestCounter++;
          server.emit('processingError', {
            id: 1, error: 'NotSynchronizedError', message: 'Error message',
            requestId: data.requestId
          });
        }
      });
      client.unsubscribe('accountId');
      try {
        await client.getOrders('accountId');
        throw new Error('NotSynchronizedError expected');
      } catch (err) {
        err.name.should.equal('NotSynchronizedError');
      }
      requestCounter.should.equal(1);
      client.socketInstancesByAccounts.should.not.have.property('accountId');
    });

    /**
     * @test {MetaApiWebsocketClient#_rpcRequest}
     */
    it('should return timeout error if no server response received', async () => {
      let trade = {
        actionType: 'ORDER_TYPE_SELL',
        symbol: 'AUDNZD',
        volume: 0.07
      };
      server.on('request', data => {});
      try {
        await client.trade(trade);
        throw new Error('TimeoutError extected');
      } catch (err) {
        err.name.should.equal('TimeoutError');
      }
    }).timeout(20000);

    /**
     * @test {MetaApiWebsocketClient#subscribeToMarketData}
     */
    it('should subscribe to market data with MetaTrader terminal', async () => {
      let requestReceived = false;
      server.on('request', data => {
        if (data.type === 'subscribeToMarketData' && data.accountId === 'accountId' && data.symbol === 'EURUSD' && data.application === 'application' && data.instanceIndex === 1 && (0, _stringify2.default)(data.subscriptions) === (0, _stringify2.default)([{ type: 'quotes' }])) {
          requestReceived = true;
          server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId });
        }
      });
      await client.subscribeToMarketData('accountId', 1, 'EURUSD', [{ type: 'quotes' }]);
      requestReceived.should.be.true();
    });

    /**
     * @test {MetaApiWebsocketClient#unsubscribeFromMarketData}
     */
    it('should unsubscribe from market data with MetaTrader terminal', async () => {
      let requestReceived = false;
      server.on('request', data => {
        if (data.type === 'unsubscribeFromMarketData' && data.accountId === 'accountId' && data.symbol === 'EURUSD' && data.application === 'application' && data.instanceIndex === 1 && (0, _stringify2.default)(data.subscriptions) === (0, _stringify2.default)([{ type: 'quotes' }])) {
          requestReceived = true;
          server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId });
        }
      });
      await client.unsubscribeFromMarketData('accountId', 1, 'EURUSD', [{ type: 'quotes' }]);
      requestReceived.should.be.true();
    });

    it('should synchronize symbol specifications', async () => {
      let specifications = [{
        symbol: 'EURUSD',
        tickSize: 0.00001,
        minVolume: 0.01,
        maxVolume: 200,
        volumeStep: 0.01
      }];
      let listener = {
        onSymbolSpecificationsUpdated: () => {},
        onSymbolSpecificationUpdated: () => {},
        onSymbolSpecificationRemoved: () => {}
      };
      sandbox.stub(listener, 'onSymbolSpecificationsUpdated').resolves();
      sandbox.stub(listener, 'onSymbolSpecificationUpdated').resolves();
      sandbox.stub(listener, 'onSymbolSpecificationRemoved').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'specifications', accountId: 'accountId', specifications, instanceIndex: 1, host: 'ps-mpa-1',
        removedSymbols: ['AUDNZD'] });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onSymbolSpecificationsUpdated, '1:ps-mpa-1', specifications, ['AUDNZD']);
      _sinon2.default.assert.calledWith(listener.onSymbolSpecificationUpdated, '1:ps-mpa-1', specifications[0]);
      _sinon2.default.assert.calledWith(listener.onSymbolSpecificationRemoved, '1:ps-mpa-1', 'AUDNZD');
    });

    it('should synchronize symbol prices', async () => {
      let prices = [{
        symbol: 'AUDNZD',
        bid: 1.05916,
        ask: 1.05927,
        profitTickValue: 0.602,
        lossTickValue: 0.60203
      }];
      let ticks = [{
        symbol: 'AUDNZD',
        time: new Date('2020-04-07T03:45:00.000Z'),
        brokerTime: '2020-04-07 06:45:00.000',
        bid: 1.05297,
        ask: 1.05309,
        last: 0.5298,
        volume: 0.13,
        side: 'buy'
      }];
      let candles = [{
        symbol: 'AUDNZD',
        timeframe: '15m',
        time: new Date('2020-04-07T03:45:00.000Z'),
        brokerTime: '2020-04-07 06:45:00.000',
        open: 1.03297,
        high: 1.06309,
        low: 1.02705,
        close: 1.043,
        tickVolume: 1435,
        spread: 17,
        volume: 345
      }];
      let books = [{
        symbol: 'AUDNZD',
        time: new Date('2020-04-07T03:45:00.000Z'),
        brokerTime: '2020-04-07 06:45:00.000',
        book: [{
          type: 'BOOK_TYPE_SELL',
          price: 1.05309,
          volume: 5.67
        }, {
          type: 'BOOK_TYPE_BUY',
          price: 1.05297,
          volume: 3.45
        }]
      }];
      let listener = {
        onSymbolPriceUpdated: () => {},
        onSymbolPricesUpdated: () => {},
        onCandlesUpdated: () => {},
        onTicksUpdated: () => {},
        onBooksUpdated: () => {}
      };
      sandbox.stub(listener, 'onSymbolPriceUpdated').resolves();
      sandbox.stub(listener, 'onSymbolPricesUpdated').resolves();
      sandbox.stub(listener, 'onCandlesUpdated').resolves();
      sandbox.stub(listener, 'onTicksUpdated').resolves();
      sandbox.stub(listener, 'onBooksUpdated').resolves();
      client.addSynchronizationListener('accountId', listener);
      server.emit('synchronization', { type: 'prices', accountId: 'accountId', host: 'ps-mpa-1', prices,
        ticks, candles, books, equity: 100, margin: 200, freeMargin: 400, marginLevel: 40000, instanceIndex: 1 });
      await new _promise2.default(res => setTimeout(res, 50));
      _sinon2.default.assert.calledWith(listener.onSymbolPricesUpdated, '1:ps-mpa-1', prices, 100, 200, 400, 40000);
      _sinon2.default.assert.calledWith(listener.onCandlesUpdated, '1:ps-mpa-1', candles, 100, 200, 400, 40000);
      _sinon2.default.assert.calledWith(listener.onTicksUpdated, '1:ps-mpa-1', ticks, 100, 200, 400, 40000);
      _sinon2.default.assert.calledWith(listener.onBooksUpdated, '1:ps-mpa-1', books, 100, 200, 400, 40000);
      _sinon2.default.assert.calledWith(listener.onSymbolPriceUpdated, '1:ps-mpa-1', prices[0]);
    });
  });

  describe('wait for server-side terminal state synchronization', () => {

    afterEach(() => {
      client.removeAllListeners();
    });

    /**
     * @test {MetaApiWebsocketClient#waitSynchronized}
     */
    it('should wait for server-side terminal state synchronization', async () => {
      let requestReceived = false;
      server.on('request', data => {
        if (data.type === 'waitSynchronized' && data.accountId === 'accountId' && data.applicationPattern === 'app.*' && data.timeoutInSeconds === 10 && data.application === 'application' && data.instanceIndex === 1) {
          requestReceived = true;
          server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId });
        }
      });
      await client.waitSynchronized('accountId', 1, 'app.*', 10);
      requestReceived.should.be.true();
    });
  });

  describe('latency monitoring', () => {

    /**
     * @test {LatencyListener#onResponse}
     */
    it('should invoke latency listener on response', async () => {
      let accountId;
      let requestType;
      let actualTimestamps;
      let listener = {
        onResponse: (aid, type, ts) => {
          accountId = aid;
          requestType = type;
          actualTimestamps = ts;
        }
      };
      client.addLatencyListener(listener);
      let price = {};
      let timestamps;
      server.on('request', data => {
        if (data.type === 'getSymbolPrice' && data.accountId === 'accountId' && data.symbol === 'AUDNZD' && data.application === 'RPC' && data.timestamps.clientProcessingStarted) {
          timestamps = (0, _assign2.default)(data.timestamps, { serverProcessingStarted: new Date(),
            serverProcessingFinished: new Date() });
          timestamps.clientProcessingStarted = new Date(timestamps.clientProcessingStarted);
          server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, price,
            timestamps });
        }
      });
      await client.getSymbolPrice('accountId', 'AUDNZD');
      await new _promise2.default(res => setTimeout(res, 100));
      accountId.should.equal('accountId');
      requestType.should.equal('getSymbolPrice');
      actualTimestamps.should.match(timestamps);
      _should2.default.exist(actualTimestamps.clientProcessingStarted);
      _should2.default.exist(actualTimestamps.clientProcessingFinished);
      _should2.default.exist(actualTimestamps.serverProcessingStarted);
      _should2.default.exist(actualTimestamps.serverProcessingFinished);
    });

    /**
     * @test {LatencyListener#onSymbolPrice}
     */
    it('should measure price streaming latencies', async () => {
      let prices = [{
        symbol: 'AUDNZD',
        timestamps: {
          eventGenerated: new Date(),
          serverProcessingStarted: new Date(),
          serverProcessingFinished: new Date()
        }
      }];
      let accountId;
      let symbol;
      let actualTimestamps;
      let listener = {
        onSymbolPrice: (aid, sym, ts) => {
          accountId = aid;
          symbol = sym;
          actualTimestamps = ts;
        }
      };
      client.addLatencyListener(listener);
      server.emit('synchronization', { type: 'prices', accountId: 'accountId', prices, equity: 100, margin: 200,
        freeMargin: 400, marginLevel: 40000 });
      await new _promise2.default(res => setTimeout(res, 50));
      accountId.should.equal('accountId');
      symbol.should.equal('AUDNZD');
      actualTimestamps.should.match(prices[0].timestamps);
      _should2.default.exist(actualTimestamps.clientProcessingFinished);
    });

    /**
     * @test {LatencyListener#onUpdate}
     */
    it('should measure update latencies', async () => {
      let update = {
        timestamps: {
          eventGenerated: new Date(),
          serverProcessingStarted: new Date(),
          serverProcessingFinished: new Date()
        }
      };
      let accountId;
      let actualTimestamps;
      let listener = {
        onUpdate: (aid, ts) => {
          accountId = aid;
          actualTimestamps = ts;
        }
      };
      client.addLatencyListener(listener);
      server.emit('synchronization', (0, _assign2.default)({ type: 'update', accountId: 'accountId' }, update));
      await new _promise2.default(res => setTimeout(res, 50));
      accountId.should.equal('accountId');
      actualTimestamps.should.match(update.timestamps);
      _should2.default.exist(actualTimestamps.clientProcessingFinished);
    });

    /**
     * @test {LatencyListener#onTrade}
     */
    it('should process trade latency', async () => {
      let trade = {};
      let response = {
        numericCode: 10009,
        stringCode: 'TRADE_RETCODE_DONE',
        message: 'Request completed',
        orderId: '46870472'
      };
      let timestamps = {
        clientExecutionStarted: new Date(),
        serverExecutionStarted: new Date(),
        serverExecutionFinished: new Date(),
        tradeExecuted: new Date()
      };
      let accountId;
      let actualTimestamps;
      let listener = {
        onTrade: (aid, ts) => {
          accountId = aid;
          actualTimestamps = ts;
        }
      };
      client.addLatencyListener(listener);
      server.on('request', data => {
        data.trade.should.match(trade);
        if (data.type === 'trade' && data.accountId === 'accountId' && data.application === 'application') {
          server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, response,
            timestamps });
        }
      });
      await client.trade('accountId', trade);
      accountId.should.equal('accountId');
      actualTimestamps.should.match(timestamps);
      _should2.default.exist(actualTimestamps.clientProcessingFinished);
    });
  });

  it('should reconnect to server on disconnect', async () => {
    const clock = _sinon2.default.useFakeTimers({ shouldAdvanceTime: true });
    const trade = {
      actionType: 'ORDER_TYPE_SELL',
      symbol: 'AUDNZD',
      volume: 0.07
    };
    const response = {
      numericCode: 10009,
      stringCode: 'TRADE_RETCODE_DONE',
      message: 'Request completed',
      orderId: '46870472'
    };
    let listener = {
      onReconnected: () => {}
    };
    sandbox.stub(listener, 'onReconnected').resolves();
    sandbox.stub(client._packetOrderer, 'onReconnected').resolves();
    sandbox.stub(client._subscriptionManager, 'onReconnected').resolves();
    client.addReconnectListener(listener, 'accountId');
    let requestCounter = 0;
    server.on('request', async data => {
      if (data.type === 'trade' && data.accountId === 'accountId' && data.application === 'application') {
        requestCounter++;
        await server.emit('response', { type: 'response', accountId: data.accountId,
          requestId: data.requestId, response });
      }
      await server.disconnect();
    });

    client.trade('accountId', trade);
    await new _promise2.default(res => setTimeout(res, 50));
    await clock.tickAsync(1500);
    await new _promise2.default(res => setTimeout(res, 50));
    _sinon2.default.assert.calledOnce(listener.onReconnected);
    _sinon2.default.assert.calledWith(client._subscriptionManager.onReconnected, 0, ['accountId']);
    _sinon2.default.assert.calledWith(client._packetOrderer.onReconnected, ['accountId']);

    server.on('request', async data => {
      if (data.type === 'trade' && data.accountId === 'accountId' && data.application === 'application') {
        requestCounter++;
        await server.emit('response', { type: 'response', accountId: data.accountId,
          requestId: data.requestId, response });
      }
      await server.disconnect();
    });

    client.trade('accountId', trade);
    await new _promise2.default(res => setTimeout(res, 50));
    await clock.tickAsync(1500);
    await new _promise2.default(res => setTimeout(res, 50));
    _sinon2.default.assert.match(requestCounter, 2);
    clock.restore();
  });

  /**
   * @test {MetaApiWebsocketClient#_rpcRequest}
   */
  it('should remove reconnect listener', async () => {
    const clock = _sinon2.default.useFakeTimers({ shouldAdvanceTime: true });

    let trade = {
      actionType: 'ORDER_TYPE_SELL',
      symbol: 'AUDNZD',
      volume: 0.07
    };
    let response = {
      numericCode: 10009,
      stringCode: 'TRADE_RETCODE_DONE',
      message: 'Request completed',
      orderId: '46870472'
    };
    const listener = { onReconnected: async () => {} };
    sandbox.stub(listener, 'onReconnected').resolves();
    client.addReconnectListener(listener, 'accountId');
    sandbox.stub(client._subscriptionManager, 'onReconnected');
    let requestCounter = 0;
    server.on('request', data => {
      data.trade.should.match(trade);
      requestCounter++;
      if (data.type === 'trade' && data.accountId === 'accountId' && data.application === 'application') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, response });
      }
      server.disconnect();
    });

    await client.trade('accountId', trade);
    await new _promise2.default(res => setTimeout(res, 50));
    await clock.tickAsync(1100);
    await new _promise2.default(res => setTimeout(res, 50));
    _sinon2.default.assert.calledOnce(listener.onReconnected);
    client.removeReconnectListener(listener);

    server.on('request', data => {
      data.trade.should.match(trade);
      requestCounter++;
      if (data.type === 'trade' && data.accountId === 'accountId' && data.application === 'application') {
        server.emit('response', { type: 'response', accountId: data.accountId, requestId: data.requestId, response });
      }
      server.disconnect();
    });

    await client.trade('accountId', trade);
    await new _promise2.default(res => setTimeout(res, 50));
    await clock.tickAsync(1100);
    await new _promise2.default(res => setTimeout(res, 50));
    _sinon2.default.assert.calledOnce(listener.onReconnected);
    _sinon2.default.assert.match(requestCounter, 2);
    clock.restore();
  });

  /**
   * @test {MetaApiWebsocketClient#queuePacket}
   */
  it('should process packets in order', async () => {
    const clock = _sinon2.default.useFakeTimers({ shouldAdvanceTime: true });
    let ordersCallTime = 0;
    let positionsCallTime = 0;
    let disconnectedCallTime = 0;
    let pricesCallTime = 0;
    let listener = {
      onConnected: () => {},
      onDisconnected: async () => {
        await new _promise2.default(res => setTimeout(res, 5000));
        disconnectedCallTime = Date.now();
      },
      onOrdersReplaced: async () => {
        await new _promise2.default(res => setTimeout(res, 10000));
        ordersCallTime = Date.now();
      },
      onPositionsReplaced: async () => {
        await new _promise2.default(res => setTimeout(res, 1000));
        positionsCallTime = Date.now();
      },
      onSymbolPricesUpdated: async () => {
        await new _promise2.default(res => setTimeout(res, 1000));
        pricesCallTime = Date.now();
      }
    };
    let resolve;
    let promise = new _promise2.default(res => resolve = res);
    client.close();
    io.close(() => resolve());
    await promise;
    io = new _socket2.default(6785, { path: '/ws', pingTimeout: 1000000 });
    sandbox.stub(httpClient, 'request').resolves({ url: 'http://localhost:6785' });
    client = new _metaApiWebsocket2.default(httpClient, 'token', { application: 'application',
      domain: 'project-stock.agiliumlabs.cloud', requestTimeout: 1.5, useSharedClientApi: false,
      retryOpts: { retries: 3, minDelayInSeconds: 0.1, maxDelayInSeconds: 0.5 },
      eventProcessing: { sequentialProcessing: true } });
    io.on('connect', socket => {
      server = socket;
      if (socket.request._query['auth-token'] !== 'token') {
        socket.emit({ error: 'UnauthorizedError', message: 'Authorization token invalid' });
        socket.close();
      }
      server.on('request', data => {
        if (data.type === 'getPositions' && data.accountId === 'accountId' && data.application === 'RPC') {
          server.emit('response', { type: 'response', accountId: data.accountId,
            requestId: data.requestId, positions: [] });
        }
      });
    });
    await client.getPositions('accountId');
    client.addSynchronizationListener('accountId', listener);
    sandbox.stub(client._packetOrderer, 'restoreOrder').callsFake(arg => {
      return [arg];
    });
    server.emit('synchronization', { type: 'authenticated', accountId: 'accountId', host: 'ps-mpa-1',
      instanceIndex: 1, replicas: 2, sequenceNumber: 1 });
    await new _promise2.default(res => setTimeout(res, 50));
    await clock.tickAsync(59000);
    server.emit('synchronization', { type: 'orders', accountId: 'accountId', orders: [], instanceIndex: 1,
      host: 'ps-mpa-1', sequenceNumber: 2 });
    server.emit('synchronization', { type: 'prices', accountId: 'accountId', prices: [{ symbol: 'EURUSD' }],
      instanceIndex: 1, host: 'ps-mpa-1', equity: 100, margin: 200, freeMargin: 400, marginLevel: 40000 });
    await new _promise2.default(res => setTimeout(res, 50));
    await clock.tickAsync(3000);
    server.emit('synchronization', { type: 'positions', accountId: 'accountId', positions: [], instanceIndex: 1,
      host: 'ps-mpa-1', sequenceNumber: 3 });
    await new _promise2.default(res => setTimeout(res, 50));
    await clock.tickAsync(20000);
    await new _promise2.default(res => setTimeout(res, 50));
    pricesCallTime.should.not.eql(0);
    ordersCallTime.should.be.above(pricesCallTime);
    disconnectedCallTime.should.be.above(ordersCallTime);
    positionsCallTime.should.be.above(disconnectedCallTime);
    clock.restore();
  });

  /**
   * @test {MetaApiWebsocketClient#queuePacket}
   */
  it('should not process old synchronization packet without gaps in sequence numbers', async () => {
    let listener = {
      onSynchronizationStarted: _sinon2.default.fake(),
      onOrdersReplaced: _sinon2.default.fake()
    };
    client.addSynchronizationListener('accountId', listener);
    sandbox.stub(client._packetOrderer, 'restoreOrder').callsFake(arg => [arg]);

    sandbox.stub(client._socketInstances[0].synchronizationThrottler, 'activeSynchronizationIds').get(() => ['ABC']);
    server.emit('synchronization', { type: 'synchronizationStarted', accountId: 'accountId',
      sequenceNumber: 1, sequenceTimestamp: 1603124267178, synchronizationId: 'ABC' });
    server.emit('synchronization', { type: 'orders', accountId: 'accountId', orders: [],
      sequenceNumber: 2, sequenceTimestamp: 1603124267181, synchronizationId: 'ABC' });
    await new _promise2.default(res => setTimeout(res, 50));
    _sinon2.default.assert.calledOnce(listener.onSynchronizationStarted);
    _sinon2.default.assert.calledOnce(listener.onOrdersReplaced);

    sandbox.stub(client._socketInstances[0].synchronizationThrottler, 'activeSynchronizationIds').get(() => ['DEF']);
    server.emit('synchronization', { type: 'synchronizationStarted', accountId: 'accountId',
      sequenceNumber: 3, sequenceTimestamp: 1603124267190, synchronizationId: 'DEF' });
    server.emit('synchronization', { type: 'orders', accountId: 'accountId', orders: [],
      sequenceNumber: 4, sequenceTimestamp: 1603124267192, synchronizationId: 'ABC' });
    server.emit('synchronization', { type: 'orders', accountId: 'accountId', orders: [],
      sequenceNumber: 5, sequenceTimestamp: 1603124267195, synchronizationId: 'DEF' });
    await new _promise2.default(res => setTimeout(res, 50));
    _sinon2.default.assert.calledTwice(listener.onSynchronizationStarted);
    _sinon2.default.assert.calledTwice(listener.onOrdersReplaced);
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9jbGllbnRzL21ldGFBcGkvbWV0YUFwaVdlYnNvY2tldC5jbGllbnQuc3BlYy5lczYiXSwibmFtZXMiOlsibWV0YWFwaUFwaVVybCIsImRlc2NyaWJlIiwiaW8iLCJzZXJ2ZXIiLCJjbGllbnQiLCJzYW5kYm94IiwiaHR0cENsaWVudCIsIkh0dHBDbGllbnQiLCJiZWZvcmUiLCJzaW5vbiIsImNyZWF0ZVNhbmRib3giLCJiZWZvcmVFYWNoIiwiTWV0YUFwaVdlYnNvY2tldENsaWVudCIsImFwcGxpY2F0aW9uIiwiZG9tYWluIiwicmVxdWVzdFRpbWVvdXQiLCJ1c2VTaGFyZWRDbGllbnRBcGkiLCJyZXRyeU9wdHMiLCJyZXRyaWVzIiwibWluRGVsYXlJblNlY29uZHMiLCJtYXhEZWxheUluU2Vjb25kcyIsInVybCIsIlNlcnZlciIsInBhdGgiLCJwaW5nVGltZW91dCIsIm9uIiwic29ja2V0IiwicmVxdWVzdCIsIl9xdWVyeSIsImVtaXQiLCJlcnJvciIsIm1lc3NhZ2UiLCJjbG9zZSIsIl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzIiwiYWNjb3VudElkIiwiY29ubmVjdCIsInN0dWIiLCJfc29ja2V0SW5zdGFuY2VzIiwic3luY2hyb25pemF0aW9uVGhyb3R0bGVyIiwiZ2V0IiwiYWZ0ZXJFYWNoIiwicmVzdG9yZSIsInJlc29sdmUiLCJwcm9taXNlIiwicmVzIiwiaXQiLCJjbG9jayIsInVzZUZha2VUaW1lcnMiLCJzaG91bGRBZHZhbmNlVGltZSIsImNsaWVudElkIiwiY29ubmVjdEFtb3VudCIsImhlYWRlcnMiLCJzaG91bGQiLCJlcXVhbCIsIm5vdCIsImRpc2Nvbm5lY3QiLCJzZXRUaW1lb3V0IiwidGlja0FzeW5jIiwiYmUiLCJhYm92ZU9yRXF1YWwiLCJwb3NpdGlvbnMiLCJpZCIsInR5cGUiLCJzeW1ib2wiLCJtYWdpYyIsInRpbWUiLCJEYXRlIiwidXBkYXRlVGltZSIsIm9wZW5QcmljZSIsImN1cnJlbnRQcmljZSIsImN1cnJlbnRUaWNrVmFsdWUiLCJ2b2x1bWUiLCJzd2FwIiwicHJvZml0IiwiY29tbWlzc2lvbiIsInN0b3BMb3NzIiwidW5yZWFsaXplZFByb2ZpdCIsInJlYWxpemVkUHJvZml0IiwicmVzb2x2ZXMiLCJkYXRhIiwicmVxdWVzdElkIiwiYWN0dWFsIiwiZ2V0UG9zaXRpb25zIiwibWF0Y2giLCJhY2NvdW50SW5mb3JtYXRpb24iLCJicm9rZXIiLCJjdXJyZW5jeSIsImJhbGFuY2UiLCJlcXVpdHkiLCJtYXJnaW4iLCJmcmVlTWFyZ2luIiwibGV2ZXJhZ2UiLCJtYXJnaW5MZXZlbCIsImdldEFjY291bnRJbmZvcm1hdGlvbiIsInBvc2l0aW9uIiwicG9zaXRpb25JZCIsImdldFBvc2l0aW9uIiwib3JkZXJzIiwic3RhdGUiLCJwbGF0Zm9ybSIsImN1cnJlbnRWb2x1bWUiLCJjb21tZW50IiwiZ2V0T3JkZXJzIiwib3JkZXIiLCJvcmRlcklkIiwiZ2V0T3JkZXIiLCJoaXN0b3J5T3JkZXJzIiwiZG9uZVRpbWUiLCJ0aWNrZXQiLCJzeW5jaHJvbml6aW5nIiwiZ2V0SGlzdG9yeU9yZGVyc0J5VGlja2V0IiwiZ2V0SGlzdG9yeU9yZGVyc0J5UG9zaXRpb24iLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwib2Zmc2V0IiwibGltaXQiLCJnZXRIaXN0b3J5T3JkZXJzQnlUaW1lUmFuZ2UiLCJkZWFscyIsImVudHJ5VHlwZSIsInByaWNlIiwiZ2V0RGVhbHNCeVRpY2tldCIsImdldERlYWxzQnlQb3NpdGlvbiIsImdldERlYWxzQnlUaW1lUmFuZ2UiLCJyZXF1ZXN0UmVjZWl2ZWQiLCJyZW1vdmVIaXN0b3J5IiwidHJ1ZSIsInJlbW92ZUFwcGxpY2F0aW9uIiwidHJhZGUiLCJhY3Rpb25UeXBlIiwicmVzcG9uc2UiLCJudW1lcmljQ29kZSIsInN0cmluZ0NvZGUiLCJkZXNjcmlwdGlvbiIsImZhaWwiLCJlcnIiLCJuYW1lIiwiaW5zdGFuY2VJbmRleCIsInN1YnNjcmliZSIsImFzc2VydCIsInNvY2tldEluc3RhbmNlcyIsImxlbmd0aCIsImkiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJzdWNjZXNzIiwicmVjb25uZWN0Iiwic3ltYm9scyIsImdldFN5bWJvbHMiLCJzcGVjaWZpY2F0aW9uIiwidGlja1NpemUiLCJtaW5Wb2x1bWUiLCJtYXhWb2x1bWUiLCJ2b2x1bWVTdGVwIiwiZ2V0U3ltYm9sU3BlY2lmaWNhdGlvbiIsImJpZCIsImFzayIsInByb2ZpdFRpY2tWYWx1ZSIsImxvc3NUaWNrVmFsdWUiLCJnZXRTeW1ib2xQcmljZSIsImNhbmRsZSIsInRpbWVmcmFtZSIsImJyb2tlclRpbWUiLCJvcGVuIiwiaGlnaCIsImxvdyIsInRpY2tWb2x1bWUiLCJzcHJlYWQiLCJnZXRDYW5kbGUiLCJ0aWNrIiwibGFzdCIsInNpZGUiLCJnZXRUaWNrIiwiYm9vayIsImdldEJvb2siLCJ1cHRpbWUiLCJzYXZlVXB0aW1lIiwidW5zdWJzY3JpYmUiLCJzb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzIiwiaGF2ZSIsInByb3BlcnR5IiwiZGV0YWlscyIsInBhcmFtZXRlciIsIkVycm9yIiwidGltZW91dCIsImxpc3RlbmVyIiwib25Db25uZWN0ZWQiLCJhZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lciIsImhvc3QiLCJyZXBsaWNhcyIsImNhbGxlZFdpdGgiLCJzZXNzaW9uSWQiLCJfc2Vzc2lvbklkIiwiY2FsbENvdW50Iiwib25Ccm9rZXJDb25uZWN0aW9uU3RhdHVzQ2hhbmdlZCIsImNvbm5lY3RlZCIsIm9uRGlzY29ubmVjdGVkIiwibm90Q2FsbGVkIiwib25TdHJlYW1DbG9zZWQiLCJvblRpbWVvdXRTdHViIiwiX3N1YnNjcmlwdGlvbk1hbmFnZXIiLCJvblN0cmVhbUNsb3NlZFN0dWIiLCJvbkRpc2Nvbm5lY3RlZFN0dWIiLCJvbkhlYWx0aFN0YXR1cyIsImhlYWx0aFN0YXR1cyIsInJlc3RBcGlIZWFsdGh5IiwiY2FsbGVkT25jZSIsIm9uQWNjb3VudEluZm9ybWF0aW9uVXBkYXRlZCIsInN5bmNocm9uaXphdGlvbklkIiwic3RhcnRpbmdIaXN0b3J5T3JkZXJUaW1lIiwic3RhcnRpbmdEZWFsVGltZSIsInN5bmNocm9uaXplIiwib25TeW5jaHJvbml6YXRpb25TdGFydGVkIiwib25Qb3NpdGlvbnNSZXBsYWNlZCIsIm9uT3JkZXJzUmVwbGFjZWQiLCJvbkhpc3RvcnlPcmRlckFkZGVkIiwib25EZWFsQWRkZWQiLCJ1cGRhdGUiLCJ1cGRhdGVkUG9zaXRpb25zIiwicmVtb3ZlZFBvc2l0aW9uSWRzIiwidXBkYXRlZE9yZGVycyIsImNvbXBsZXRlZE9yZGVySWRzIiwib25Qb3NpdGlvblVwZGF0ZWQiLCJvblBvc2l0aW9uUmVtb3ZlZCIsIm9uT3JkZXJVcGRhdGVkIiwib25PcmRlckNvbXBsZXRlZCIsInJlcXVlc3RDb3VudGVyIiwic3RhdHVzX2NvZGUiLCJtZXRhZGF0YSIsInBlcmlvZEluTWludXRlcyIsIm1heFJlcXVlc3RzRm9yUGVyaW9kIiwicmVjb21tZW5kZWRSZXRyeVRpbWUiLCJub3ciLCJhcHByb3hpbWF0ZWx5Iiwic3Vic2NyaWJlVG9NYXJrZXREYXRhIiwic3Vic2NyaXB0aW9ucyIsInVuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEiLCJzcGVjaWZpY2F0aW9ucyIsIm9uU3ltYm9sU3BlY2lmaWNhdGlvbnNVcGRhdGVkIiwib25TeW1ib2xTcGVjaWZpY2F0aW9uVXBkYXRlZCIsIm9uU3ltYm9sU3BlY2lmaWNhdGlvblJlbW92ZWQiLCJyZW1vdmVkU3ltYm9scyIsInByaWNlcyIsInRpY2tzIiwiY2FuZGxlcyIsImJvb2tzIiwib25TeW1ib2xQcmljZVVwZGF0ZWQiLCJvblN5bWJvbFByaWNlc1VwZGF0ZWQiLCJvbkNhbmRsZXNVcGRhdGVkIiwib25UaWNrc1VwZGF0ZWQiLCJvbkJvb2tzVXBkYXRlZCIsImFwcGxpY2F0aW9uUGF0dGVybiIsInRpbWVvdXRJblNlY29uZHMiLCJ3YWl0U3luY2hyb25pemVkIiwicmVxdWVzdFR5cGUiLCJhY3R1YWxUaW1lc3RhbXBzIiwib25SZXNwb25zZSIsImFpZCIsInRzIiwiYWRkTGF0ZW5jeUxpc3RlbmVyIiwidGltZXN0YW1wcyIsImNsaWVudFByb2Nlc3NpbmdTdGFydGVkIiwic2VydmVyUHJvY2Vzc2luZ1N0YXJ0ZWQiLCJzZXJ2ZXJQcm9jZXNzaW5nRmluaXNoZWQiLCJleGlzdCIsImNsaWVudFByb2Nlc3NpbmdGaW5pc2hlZCIsImV2ZW50R2VuZXJhdGVkIiwib25TeW1ib2xQcmljZSIsInN5bSIsIm9uVXBkYXRlIiwiY2xpZW50RXhlY3V0aW9uU3RhcnRlZCIsInNlcnZlckV4ZWN1dGlvblN0YXJ0ZWQiLCJzZXJ2ZXJFeGVjdXRpb25GaW5pc2hlZCIsInRyYWRlRXhlY3V0ZWQiLCJvblRyYWRlIiwib25SZWNvbm5lY3RlZCIsIl9wYWNrZXRPcmRlcmVyIiwiYWRkUmVjb25uZWN0TGlzdGVuZXIiLCJyZW1vdmVSZWNvbm5lY3RMaXN0ZW5lciIsIm9yZGVyc0NhbGxUaW1lIiwicG9zaXRpb25zQ2FsbFRpbWUiLCJkaXNjb25uZWN0ZWRDYWxsVGltZSIsInByaWNlc0NhbGxUaW1lIiwiZXZlbnRQcm9jZXNzaW5nIiwic2VxdWVudGlhbFByb2Nlc3NpbmciLCJjYWxsc0Zha2UiLCJhcmciLCJzZXF1ZW5jZU51bWJlciIsImVxbCIsImFib3ZlIiwiZmFrZSIsInNlcXVlbmNlVGltZXN0YW1wIiwiY2FsbGVkVHdpY2UiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7Ozs7O0FBRUEsTUFBTUEsZ0JBQWdCLHVEQUF0Qjs7QUFFQTs7O0FBR0E7QUFDQUMsU0FBUyx3QkFBVCxFQUFtQyxNQUFNOztBQUV2QyxNQUFJQyxFQUFKO0FBQ0EsTUFBSUMsTUFBSjtBQUNBLE1BQUlDLE1BQUo7QUFDQSxNQUFJQyxPQUFKO0FBQ0EsTUFBSUMsYUFBYSxJQUFJQyxvQkFBSixFQUFqQjs7QUFFQUMsU0FBTyxNQUFNO0FBQ1hILGNBQVVJLGdCQUFNQyxhQUFOLEVBQVY7QUFDRCxHQUZE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bnBFRCIsImZpbGUiOiJtZXRhQXBpV2Vic29ja2V0LmNsaWVudC5zcGVjLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgc2hvdWxkIGZyb20gJ3Nob3VsZCc7XG5pbXBvcnQgc2lub24gZnJvbSAnc2lub24nO1xuaW1wb3J0IE1ldGFBcGlXZWJzb2NrZXRDbGllbnQgZnJvbSAnLi9tZXRhQXBpV2Vic29ja2V0LmNsaWVudCc7XG5pbXBvcnQgU2VydmVyIGZyb20gJ3NvY2tldC5pbyc7XG5pbXBvcnQgTm90Q29ubmVjdGVkRXJyb3IgZnJvbSAnLi9ub3RDb25uZWN0ZWRFcnJvcic7XG5pbXBvcnQge0ludGVybmFsRXJyb3J9IGZyb20gJy4uL2Vycm9ySGFuZGxlcic7XG5pbXBvcnQgSHR0cENsaWVudCBmcm9tICcuLi9odHRwQ2xpZW50JztcblxuY29uc3QgbWV0YWFwaUFwaVVybCA9ICdodHRwczovL210LWNsaWVudC1hcGktdjEuYWdpbGl1bXRyYWRlLmFnaWxpdW10cmFkZS5haSc7XG5cbi8qKlxuICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnR9XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuZGVzY3JpYmUoJ01ldGFBcGlXZWJzb2NrZXRDbGllbnQnLCAoKSA9PiB7XG5cbiAgbGV0IGlvO1xuICBsZXQgc2VydmVyO1xuICBsZXQgY2xpZW50O1xuICBsZXQgc2FuZGJveDtcbiAgbGV0IGh0dHBDbGllbnQgPSBuZXcgSHR0cENsaWVudCgpO1xuXG4gIGJlZm9yZSgoKSA9PiB7XG4gICAgc2FuZGJveCA9IHNpbm9uLmNyZWF0ZVNhbmRib3goKTtcbiAgfSk7XG5cbiAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgY2xpZW50ID0gbmV3IE1ldGFBcGlXZWJzb2NrZXRDbGllbnQoaHR0cENsaWVudCwgJ3Rva2VuJywge2FwcGxpY2F0aW9uOiAnYXBwbGljYXRpb24nLCBcbiAgICAgIGRvbWFpbjogJ3Byb2plY3Qtc3RvY2suYWdpbGl1bWxhYnMuY2xvdWQnLCByZXF1ZXN0VGltZW91dDogMS41LCB1c2VTaGFyZWRDbGllbnRBcGk6IHRydWUsXG4gICAgICByZXRyeU9wdHM6IHtyZXRyaWVzOiAzLCBtaW5EZWxheUluU2Vjb25kczogMC4xLCBtYXhEZWxheUluU2Vjb25kczogMC41fX0pO1xuICAgIGNsaWVudC51cmwgPSAnaHR0cDovL2xvY2FsaG9zdDo2Nzg0JztcbiAgICBpbyA9IG5ldyBTZXJ2ZXIoNjc4NCwge3BhdGg6ICcvd3MnLCBwaW5nVGltZW91dDogMTAwMDAwMH0pO1xuICAgIGlvLm9uKCdjb25uZWN0Jywgc29ja2V0ID0+IHtcbiAgICAgIHNlcnZlciA9IHNvY2tldDtcbiAgICAgIGlmIChzb2NrZXQucmVxdWVzdC5fcXVlcnlbJ2F1dGgtdG9rZW4nXSAhPT0gJ3Rva2VuJykge1xuICAgICAgICBzb2NrZXQuZW1pdCh7ZXJyb3I6ICdVbmF1dGhvcml6ZWRFcnJvcicsIG1lc3NhZ2U6ICdBdXRob3JpemF0aW9uIHRva2VuIGludmFsaWQnfSk7XG4gICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNsaWVudC5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50cyA9IHthY2NvdW50SWQ6IDB9O1xuICAgIGF3YWl0IGNsaWVudC5jb25uZWN0KCk7XG4gICAgc2FuZGJveC5zdHViKGNsaWVudC5fc29ja2V0SW5zdGFuY2VzWzBdLnN5bmNocm9uaXphdGlvblRocm90dGxlciwgJ2FjdGl2ZVN5bmNocm9uaXphdGlvbklkcycpLmdldCgoKSA9PiBbXSk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XG4gICAgc2FuZGJveC5yZXN0b3JlKCk7XG4gICAgbGV0IHJlc29sdmU7XG4gICAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXMgPT4gcmVzb2x2ZSA9IHJlcyk7XG4gICAgY2xpZW50LmNsb3NlKCk7XG4gICAgaW8uY2xvc2UoKCkgPT4gcmVzb2x2ZSgpKTtcbiAgICBhd2FpdCBwcm9taXNlO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjX3RyeVJlY29ubmVjdH1cbiAgICovXG4gIGl0KCdzaG91bGQgY2hhbmdlIGNsaWVudCBpZCBvbiByZWNvbm5lY3QnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgY2xvY2sgPSBzaW5vbi51c2VGYWtlVGltZXJzKHtzaG91bGRBZHZhbmNlVGltZTogdHJ1ZX0pO1xuICAgIGNsaWVudC5jbG9zZSgpO1xuICAgIGxldCBjbGllbnRJZDtcbiAgICBsZXQgY29ubmVjdEFtb3VudCA9IDA7XG4gICAgaW8ub24oJ2Nvbm5lY3QnLCBzb2NrZXQgPT4ge1xuICAgICAgY29ubmVjdEFtb3VudCsrO1xuICAgICAgc29ja2V0LnJlcXVlc3QuaGVhZGVyc1snY2xpZW50LWlkJ10uc2hvdWxkLmVxdWFsKHNvY2tldC5yZXF1ZXN0Ll9xdWVyeS5jbGllbnRJZCk7XG4gICAgICBzb2NrZXQucmVxdWVzdC5oZWFkZXJzWydjbGllbnQtaWQnXS5zaG91bGQubm90LmVxdWFsKGNsaWVudElkKTtcbiAgICAgIHNvY2tldC5yZXF1ZXN0Ll9xdWVyeS5jbGllbnRJZC5zaG91bGQubm90LmVxdWFsKGNsaWVudElkKTtcbiAgICAgIGNsaWVudElkID0gc29ja2V0LnJlcXVlc3QuX3F1ZXJ5LmNsaWVudElkO1xuICAgICAgc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICB9KTtcbiAgICBhd2FpdCBjbGllbnQuY29ubmVjdCgpO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICBhd2FpdCBjbG9jay50aWNrQXN5bmMoMTUwMCk7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgIGNvbm5lY3RBbW91bnQuc2hvdWxkLmJlLmFib3ZlT3JFcXVhbCgyKTtcbiAgICBjbG9jay5yZXN0b3JlKCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNfZ2V0U2VydmVyVXJsfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBjb25uZWN0IHRvIGRlZGljYXRlZCBzZXJ2ZXInLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IHBvc2l0aW9ucyA9IFt7XG4gICAgICBpZDogJzQ2MjE0NjkyJyxcbiAgICAgIHR5cGU6ICdQT1NJVElPTl9UWVBFX0JVWScsXG4gICAgICBzeW1ib2w6ICdHQlBVU0QnLFxuICAgICAgbWFnaWM6IDEwMDAsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0xNVQwMjo0NTowNi41MjFaJyksXG4gICAgICB1cGRhdGVUaW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0xNVQwMjo0NTowNi41MjFaJyksXG4gICAgICBvcGVuUHJpY2U6IDEuMjYxMDEsXG4gICAgICBjdXJyZW50UHJpY2U6IDEuMjQ4ODMsXG4gICAgICBjdXJyZW50VGlja1ZhbHVlOiAxLFxuICAgICAgdm9sdW1lOiAwLjA3LFxuICAgICAgc3dhcDogMCxcbiAgICAgIHByb2ZpdDogLTg1LjI1OTk5OTk5OTk5OTY2LFxuICAgICAgY29tbWlzc2lvbjogLTAuMjUsXG4gICAgICBjbGllbnRJZDogJ1RFX0dCUFVTRF83aHlJTldxQWxFJyxcbiAgICAgIHN0b3BMb3NzOiAxLjE3NzIxLFxuICAgICAgdW5yZWFsaXplZFByb2ZpdDogLTg1LjI1OTk5OTk5OTk5OTAxLFxuICAgICAgcmVhbGl6ZWRQcm9maXQ6IC02LjUzNjk5MzE2ODk5MjkyMmUtMTNcbiAgICB9XTtcbiAgICBsZXQgcmVzb2x2ZTtcbiAgICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlcyA9PiByZXNvbHZlID0gcmVzKTtcbiAgICBjbGllbnQuY2xvc2UoKTtcbiAgICBpby5jbG9zZSgoKSA9PiByZXNvbHZlKCkpO1xuICAgIGF3YWl0IHByb21pc2U7XG4gICAgaW8gPSBuZXcgU2VydmVyKDY3ODUsIHtwYXRoOiAnL3dzJywgcGluZ1RpbWVvdXQ6IDEwMDAwMDB9KTtcbiAgICBzYW5kYm94LnN0dWIoaHR0cENsaWVudCwgJ3JlcXVlc3QnKS5yZXNvbHZlcyh7dXJsOiAnaHR0cDovL2xvY2FsaG9zdDo2Nzg1J30pO1xuICAgIGNsaWVudCA9IG5ldyBNZXRhQXBpV2Vic29ja2V0Q2xpZW50KGh0dHBDbGllbnQsICd0b2tlbicsIHthcHBsaWNhdGlvbjogJ2FwcGxpY2F0aW9uJywgXG4gICAgICBkb21haW46ICdwcm9qZWN0LXN0b2NrLmFnaWxpdW1sYWJzLmNsb3VkJywgcmVxdWVzdFRpbWVvdXQ6IDEuNSwgdXNlU2hhcmVkQ2xpZW50QXBpOiBmYWxzZSxcbiAgICAgIHJldHJ5T3B0czogeyByZXRyaWVzOiAzLCBtaW5EZWxheUluU2Vjb25kczogMC4xLCBtYXhEZWxheUluU2Vjb25kczogMC41fX0pO1xuICAgIGlvLm9uKCdjb25uZWN0Jywgc29ja2V0ID0+IHtcbiAgICAgIHNlcnZlciA9IHNvY2tldDtcbiAgICAgIGlmIChzb2NrZXQucmVxdWVzdC5fcXVlcnlbJ2F1dGgtdG9rZW4nXSAhPT0gJ3Rva2VuJykge1xuICAgICAgICBzb2NrZXQuZW1pdCh7ZXJyb3I6ICdVbmF1dGhvcml6ZWRFcnJvcicsIG1lc3NhZ2U6ICdBdXRob3JpemF0aW9uIHRva2VuIGludmFsaWQnfSk7XG4gICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgfVxuICAgICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdnZXRQb3NpdGlvbnMnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLmFwcGxpY2F0aW9uID09PSAnUlBDJykge1xuICAgICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLCBwb3NpdGlvbnN9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgbGV0IGFjdHVhbCA9IGF3YWl0IGNsaWVudC5nZXRQb3NpdGlvbnMoJ2FjY291bnRJZCcpO1xuICAgIGFjdHVhbC5zaG91bGQubWF0Y2gocG9zaXRpb25zKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I2dldEFjY291bnRJbmZvcm1hdGlvbn1cbiAgICovXG4gIGl0KCdzaG91bGQgcmV0cmlldmUgTWV0YVRyYWRlciBhY2NvdW50IGluZm9ybWF0aW9uIGZyb20gQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBhY2NvdW50SW5mb3JtYXRpb24gPSB7XG4gICAgICBicm9rZXI6ICdUcnVlIEVDTiBUcmFkaW5nIEx0ZCcsXG4gICAgICBjdXJyZW5jeTogJ1VTRCcsXG4gICAgICBzZXJ2ZXI6ICdJQ01hcmtldHNTQy1EZW1vJyxcbiAgICAgIGJhbGFuY2U6IDczMTkuOSxcbiAgICAgIGVxdWl0eTogNzMwNi42NDk5MTMyMDAwMDEsXG4gICAgICBtYXJnaW46IDE4NC4xLFxuICAgICAgZnJlZU1hcmdpbjogNzEyMC4yMixcbiAgICAgIGxldmVyYWdlOiAxMDAsXG4gICAgICBtYXJnaW5MZXZlbDogMzk2Ny41ODI4MzU0MlxuICAgIH07XG4gICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAnZ2V0QWNjb3VudEluZm9ybWF0aW9uJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiZcbiAgICAgICAgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ1JQQycpIHtcbiAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge1xuICAgICAgICAgIHR5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWQsXG4gICAgICAgICAgYWNjb3VudEluZm9ybWF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBhY3R1YWwgPSBhd2FpdCBjbGllbnQuZ2V0QWNjb3VudEluZm9ybWF0aW9uKCdhY2NvdW50SWQnKTtcbiAgICBhY3R1YWwuc2hvdWxkLm1hdGNoKGFjY291bnRJbmZvcm1hdGlvbik7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNnZXRQb3NpdGlvbnN9XG4gICAqL1xuICBpdCgnc2hvdWxkIHJldHJpZXZlIE1ldGFUcmFkZXIgcG9zaXRpb25zIGZyb20gQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBwb3NpdGlvbnMgPSBbe1xuICAgICAgaWQ6ICc0NjIxNDY5MicsXG4gICAgICB0eXBlOiAnUE9TSVRJT05fVFlQRV9CVVknLFxuICAgICAgc3ltYm9sOiAnR0JQVVNEJyxcbiAgICAgIG1hZ2ljOiAxMDAwLFxuICAgICAgdGltZTogbmV3IERhdGUoJzIwMjAtMDQtMTVUMDI6NDU6MDYuNTIxWicpLFxuICAgICAgdXBkYXRlVGltZTogbmV3IERhdGUoJzIwMjAtMDQtMTVUMDI6NDU6MDYuNTIxWicpLFxuICAgICAgb3BlblByaWNlOiAxLjI2MTAxLFxuICAgICAgY3VycmVudFByaWNlOiAxLjI0ODgzLFxuICAgICAgY3VycmVudFRpY2tWYWx1ZTogMSxcbiAgICAgIHZvbHVtZTogMC4wNyxcbiAgICAgIHN3YXA6IDAsXG4gICAgICBwcm9maXQ6IC04NS4yNTk5OTk5OTk5OTk2NixcbiAgICAgIGNvbW1pc3Npb246IC0wLjI1LFxuICAgICAgY2xpZW50SWQ6ICdURV9HQlBVU0RfN2h5SU5XcUFsRScsXG4gICAgICBzdG9wTG9zczogMS4xNzcyMSxcbiAgICAgIHVucmVhbGl6ZWRQcm9maXQ6IC04NS4yNTk5OTk5OTk5OTkwMSxcbiAgICAgIHJlYWxpemVkUHJvZml0OiAtNi41MzY5OTMxNjg5OTI5MjJlLTEzXG4gICAgfV07XG4gICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAnZ2V0UG9zaXRpb25zJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ1JQQycpIHtcbiAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge3R5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWQsIHBvc2l0aW9uc30pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBhY3R1YWwgPSBhd2FpdCBjbGllbnQuZ2V0UG9zaXRpb25zKCdhY2NvdW50SWQnKTtcbiAgICBhY3R1YWwuc2hvdWxkLm1hdGNoKHBvc2l0aW9ucyk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNnZXRQb3NpdGlvbn1cbiAgICovXG4gIGl0KCdzaG91bGQgcmV0cmlldmUgTWV0YVRyYWRlciBwb3NpdGlvbiBmcm9tIEFQSSBieSBpZCcsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgcG9zaXRpb24gPSB7XG4gICAgICBpZDogJzQ2MjE0NjkyJyxcbiAgICAgIHR5cGU6ICdQT1NJVElPTl9UWVBFX0JVWScsXG4gICAgICBzeW1ib2w6ICdHQlBVU0QnLFxuICAgICAgbWFnaWM6IDEwMDAsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0xNVQwMjo0NTowNi41MjFaJyksXG4gICAgICB1cGRhdGVUaW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0xNVQwMjo0NTowNi41MjFaJyksXG4gICAgICBvcGVuUHJpY2U6IDEuMjYxMDEsXG4gICAgICBjdXJyZW50UHJpY2U6IDEuMjQ4ODMsXG4gICAgICBjdXJyZW50VGlja1ZhbHVlOiAxLFxuICAgICAgdm9sdW1lOiAwLjA3LFxuICAgICAgc3dhcDogMCxcbiAgICAgIHByb2ZpdDogLTg1LjI1OTk5OTk5OTk5OTY2LFxuICAgICAgY29tbWlzc2lvbjogLTAuMjUsXG4gICAgICBjbGllbnRJZDogJ1RFX0dCUFVTRF83aHlJTldxQWxFJyxcbiAgICAgIHN0b3BMb3NzOiAxLjE3NzIxLFxuICAgICAgdW5yZWFsaXplZFByb2ZpdDogLTg1LjI1OTk5OTk5OTk5OTAxLFxuICAgICAgcmVhbGl6ZWRQcm9maXQ6IC02LjUzNjk5MzE2ODk5MjkyMmUtMTNcbiAgICB9O1xuICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ2dldFBvc2l0aW9uJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgZGF0YS5wb3NpdGlvbklkID09PSAnNDYyMTQ2OTInICYmXG4gICAgICAgIGRhdGEuYXBwbGljYXRpb24gPT09ICdSUEMnKSB7XG4gICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLCBwb3NpdGlvbn0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBhY3R1YWwgPSBhd2FpdCBjbGllbnQuZ2V0UG9zaXRpb24oJ2FjY291bnRJZCcsICc0NjIxNDY5MicpO1xuICAgIGFjdHVhbC5zaG91bGQubWF0Y2gocG9zaXRpb24pO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjZ2V0T3JkZXJzfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBNZXRhVHJhZGVyIG9yZGVycyBmcm9tIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgb3JkZXJzID0gW3tcbiAgICAgIGlkOiAnNDY4NzEyODQnLFxuICAgICAgdHlwZTogJ09SREVSX1RZUEVfQlVZX0xJTUlUJyxcbiAgICAgIHN0YXRlOiAnT1JERVJfU1RBVEVfUExBQ0VEJyxcbiAgICAgIHN5bWJvbDogJ0FVRE5aRCcsXG4gICAgICBtYWdpYzogMTIzNDU2LFxuICAgICAgcGxhdGZvcm06ICdtdDUnLFxuICAgICAgdGltZTogbmV3IERhdGUoJzIwMjAtMDQtMjBUMDg6Mzg6NTguMjcwWicpLFxuICAgICAgb3BlblByaWNlOiAxLjAzLFxuICAgICAgY3VycmVudFByaWNlOiAxLjA1MjA2LFxuICAgICAgdm9sdW1lOiAwLjAxLFxuICAgICAgY3VycmVudFZvbHVtZTogMC4wMSxcbiAgICAgIGNvbW1lbnQ6ICdDT01NRU5UMidcbiAgICB9XTtcbiAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdnZXRPcmRlcnMnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLmFwcGxpY2F0aW9uID09PSAnUlBDJykge1xuICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCwgb3JkZXJzfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGFjdHVhbCA9IGF3YWl0IGNsaWVudC5nZXRPcmRlcnMoJ2FjY291bnRJZCcpO1xuICAgIGFjdHVhbC5zaG91bGQubWF0Y2gob3JkZXJzKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I2dldE9yZGVyfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBNZXRhVHJhZGVyIG9yZGVyIGZyb20gQVBJIGJ5IGlkJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBvcmRlciA9IHtcbiAgICAgIGlkOiAnNDY4NzEyODQnLFxuICAgICAgdHlwZTogJ09SREVSX1RZUEVfQlVZX0xJTUlUJyxcbiAgICAgIHN0YXRlOiAnT1JERVJfU1RBVEVfUExBQ0VEJyxcbiAgICAgIHN5bWJvbDogJ0FVRE5aRCcsXG4gICAgICBtYWdpYzogMTIzNDU2LFxuICAgICAgcGxhdGZvcm06ICdtdDUnLFxuICAgICAgdGltZTogbmV3IERhdGUoJzIwMjAtMDQtMjBUMDg6Mzg6NTguMjcwWicpLFxuICAgICAgb3BlblByaWNlOiAxLjAzLFxuICAgICAgY3VycmVudFByaWNlOiAxLjA1MjA2LFxuICAgICAgdm9sdW1lOiAwLjAxLFxuICAgICAgY3VycmVudFZvbHVtZTogMC4wMSxcbiAgICAgIGNvbW1lbnQ6ICdDT01NRU5UMidcbiAgICB9O1xuICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ2dldE9yZGVyJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgZGF0YS5vcmRlcklkID09PSAnNDY4NzEyODQnICYmXG4gICAgICAgIGRhdGEuYXBwbGljYXRpb24gPT09ICdSUEMnKSB7XG4gICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLCBvcmRlcn0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBhY3R1YWwgPSBhd2FpdCBjbGllbnQuZ2V0T3JkZXIoJ2FjY291bnRJZCcsICc0Njg3MTI4NCcpO1xuICAgIGFjdHVhbC5zaG91bGQubWF0Y2gob3JkZXIpO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjZ2V0SGlzdG9yeU9yZGVyc0J5VGlja2V0fVxuICAgKi9cbiAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBNZXRhVHJhZGVyIGhpc3Rvcnkgb3JkZXJzIGZyb20gQVBJIGJ5IHRpY2tldCcsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgaGlzdG9yeU9yZGVycyA9IFt7XG4gICAgICBjbGllbnRJZDogJ1RFX0dCUFVTRF83aHlJTldxQWxFJyxcbiAgICAgIGN1cnJlbnRQcmljZTogMS4yNjEsXG4gICAgICBjdXJyZW50Vm9sdW1lOiAwLFxuICAgICAgZG9uZVRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTE1VDAyOjQ1OjA2LjUyMVonKSxcbiAgICAgIGlkOiAnNDYyMTQ2OTInLFxuICAgICAgbWFnaWM6IDEwMDAsXG4gICAgICBwbGF0Zm9ybTogJ210NScsXG4gICAgICBwb3NpdGlvbklkOiAnNDYyMTQ2OTInLFxuICAgICAgc3RhdGU6ICdPUkRFUl9TVEFURV9GSUxMRUQnLFxuICAgICAgc3ltYm9sOiAnR0JQVVNEJyxcbiAgICAgIHRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTE1VDAyOjQ1OjA2LjI2MFonKSxcbiAgICAgIHR5cGU6ICdPUkRFUl9UWVBFX0JVWScsXG4gICAgICB2b2x1bWU6IDAuMDdcbiAgICB9XTtcbiAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdnZXRIaXN0b3J5T3JkZXJzQnlUaWNrZXQnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLnRpY2tldCA9PT0gJzQ2MjE0NjkyJyAmJlxuICAgICAgICBkYXRhLmFwcGxpY2F0aW9uID09PSAnUlBDJykge1xuICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7XG4gICAgICAgICAgdHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCwgaGlzdG9yeU9yZGVycyxcbiAgICAgICAgICBzeW5jaHJvbml6aW5nOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgYWN0dWFsID0gYXdhaXQgY2xpZW50LmdldEhpc3RvcnlPcmRlcnNCeVRpY2tldCgnYWNjb3VudElkJywgJzQ2MjE0NjkyJyk7XG4gICAgYWN0dWFsLnNob3VsZC5tYXRjaCh7aGlzdG9yeU9yZGVycywgc3luY2hyb25pemluZzogZmFsc2V9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I2dldEhpc3RvcnlPcmRlcnNCeVBvc2l0aW9ufVxuICAgKi9cbiAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBNZXRhVHJhZGVyIGhpc3Rvcnkgb3JkZXJzIGZyb20gQVBJIGJ5IHBvc2l0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBoaXN0b3J5T3JkZXJzID0gW3tcbiAgICAgIGNsaWVudElkOiAnVEVfR0JQVVNEXzdoeUlOV3FBbEUnLFxuICAgICAgY3VycmVudFByaWNlOiAxLjI2MSxcbiAgICAgIGN1cnJlbnRWb2x1bWU6IDAsXG4gICAgICBkb25lVGltZTogbmV3IERhdGUoJzIwMjAtMDQtMTVUMDI6NDU6MDYuNTIxWicpLFxuICAgICAgaWQ6ICc0NjIxNDY5MicsXG4gICAgICBtYWdpYzogMTAwMCxcbiAgICAgIHBsYXRmb3JtOiAnbXQ1JyxcbiAgICAgIHBvc2l0aW9uSWQ6ICc0NjIxNDY5MicsXG4gICAgICBzdGF0ZTogJ09SREVSX1NUQVRFX0ZJTExFRCcsXG4gICAgICBzeW1ib2w6ICdHQlBVU0QnLFxuICAgICAgdGltZTogbmV3IERhdGUoJzIwMjAtMDQtMTVUMDI6NDU6MDYuMjYwWicpLFxuICAgICAgdHlwZTogJ09SREVSX1RZUEVfQlVZJyxcbiAgICAgIHZvbHVtZTogMC4wN1xuICAgIH1dO1xuICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ2dldEhpc3RvcnlPcmRlcnNCeVBvc2l0aW9uJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiZcbiAgICAgICAgZGF0YS5wb3NpdGlvbklkID09PSAnNDYyMTQ2OTInICYmIGRhdGEuYXBwbGljYXRpb24gPT09ICdSUEMnKSB7XG4gICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHtcbiAgICAgICAgICB0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLCBoaXN0b3J5T3JkZXJzLFxuICAgICAgICAgIHN5bmNocm9uaXppbmc6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBhY3R1YWwgPSBhd2FpdCBjbGllbnQuZ2V0SGlzdG9yeU9yZGVyc0J5UG9zaXRpb24oJ2FjY291bnRJZCcsICc0NjIxNDY5MicpO1xuICAgIGFjdHVhbC5zaG91bGQubWF0Y2goe2hpc3RvcnlPcmRlcnMsIHN5bmNocm9uaXppbmc6IGZhbHNlfSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNnZXRIaXN0b3J5T3JkZXJzQnlUaW1lUmFuZ2V9XG4gICAqL1xuICBpdCgnc2hvdWxkIHJldHJpZXZlIE1ldGFUcmFkZXIgaGlzdG9yeSBvcmRlcnMgZnJvbSBBUEkgYnkgdGltZSByYW5nZScsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgaGlzdG9yeU9yZGVycyA9IFt7XG4gICAgICBjbGllbnRJZDogJ1RFX0dCUFVTRF83aHlJTldxQWxFJyxcbiAgICAgIGN1cnJlbnRQcmljZTogMS4yNjEsXG4gICAgICBjdXJyZW50Vm9sdW1lOiAwLFxuICAgICAgZG9uZVRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTE1VDAyOjQ1OjA2LjUyMVonKSxcbiAgICAgIGlkOiAnNDYyMTQ2OTInLFxuICAgICAgbWFnaWM6IDEwMDAsXG4gICAgICBwbGF0Zm9ybTogJ210NScsXG4gICAgICBwb3NpdGlvbklkOiAnNDYyMTQ2OTInLFxuICAgICAgc3RhdGU6ICdPUkRFUl9TVEFURV9GSUxMRUQnLFxuICAgICAgc3ltYm9sOiAnR0JQVVNEJyxcbiAgICAgIHRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTE1VDAyOjQ1OjA2LjI2MFonKSxcbiAgICAgIHR5cGU6ICdPUkRFUl9UWVBFX0JVWScsXG4gICAgICB2b2x1bWU6IDAuMDdcbiAgICB9XTtcbiAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdnZXRIaXN0b3J5T3JkZXJzQnlUaW1lUmFuZ2UnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJlxuICAgICAgICBkYXRhLnN0YXJ0VGltZSA9PT0gJzIwMjAtMDQtMTVUMDI6NDU6MDAuMDAwWicgJiYgZGF0YS5lbmRUaW1lID09PSAnMjAyMC0wNC0xNVQwMjo0NjowMC4wMDBaJyAmJlxuICAgICAgICBkYXRhLm9mZnNldCA9PT0gMSAmJiBkYXRhLmxpbWl0ID09PSAxMDAgJiYgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ1JQQycpIHtcbiAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge1xuICAgICAgICAgIHR5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWQsIGhpc3RvcnlPcmRlcnMsXG4gICAgICAgICAgc3luY2hyb25pemluZzogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGFjdHVhbCA9IGF3YWl0IGNsaWVudC5nZXRIaXN0b3J5T3JkZXJzQnlUaW1lUmFuZ2UoJ2FjY291bnRJZCcsIG5ldyBEYXRlKCcyMDIwLTA0LTE1VDAyOjQ1OjAwLjAwMFonKSxcbiAgICAgIG5ldyBEYXRlKCcyMDIwLTA0LTE1VDAyOjQ2OjAwLjAwMFonKSwgMSwgMTAwKTtcbiAgICBhY3R1YWwuc2hvdWxkLm1hdGNoKHtoaXN0b3J5T3JkZXJzLCBzeW5jaHJvbml6aW5nOiBmYWxzZX0pO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjZ2V0RGVhbHNCeVRpY2tldH1cbiAgICovXG4gIGl0KCdzaG91bGQgcmV0cmlldmUgTWV0YVRyYWRlciBkZWFscyBmcm9tIEFQSSBieSB0aWNrZXQnLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IGRlYWxzID0gW3tcbiAgICAgIGNsaWVudElkOiAnVEVfR0JQVVNEXzdoeUlOV3FBbEUnLFxuICAgICAgY29tbWlzc2lvbjogLTAuMjUsXG4gICAgICBlbnRyeVR5cGU6ICdERUFMX0VOVFJZX0lOJyxcbiAgICAgIGlkOiAnMzMyMzAwOTknLFxuICAgICAgbWFnaWM6IDEwMDAsXG4gICAgICBwbGF0Zm9ybTogJ210NScsXG4gICAgICBvcmRlcklkOiAnNDYyMTQ2OTInLFxuICAgICAgcG9zaXRpb25JZDogJzQ2MjE0NjkyJyxcbiAgICAgIHByaWNlOiAxLjI2MTAxLFxuICAgICAgcHJvZml0OiAwLFxuICAgICAgc3dhcDogMCxcbiAgICAgIHN5bWJvbDogJ0dCUFVTRCcsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0xNVQwMjo0NTowNi41MjFaJyksXG4gICAgICB0eXBlOiAnREVBTF9UWVBFX0JVWScsXG4gICAgICB2b2x1bWU6IDAuMDdcbiAgICB9XTtcbiAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdnZXREZWFsc0J5VGlja2V0JyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgZGF0YS50aWNrZXQgPT09ICc0NjIxNDY5MicgJiZcbiAgICAgICAgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ1JQQycpIHtcbiAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge1xuICAgICAgICAgIHR5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWQsIGRlYWxzLFxuICAgICAgICAgIHN5bmNocm9uaXppbmc6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBhY3R1YWwgPSBhd2FpdCBjbGllbnQuZ2V0RGVhbHNCeVRpY2tldCgnYWNjb3VudElkJywgJzQ2MjE0NjkyJyk7XG4gICAgYWN0dWFsLnNob3VsZC5tYXRjaCh7ZGVhbHMsIHN5bmNocm9uaXppbmc6IGZhbHNlfSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNnZXREZWFsc0J5UG9zaXRpb259XG4gICAqL1xuICBpdCgnc2hvdWxkIHJldHJpZXZlIE1ldGFUcmFkZXIgZGVhbHMgZnJvbSBBUEkgYnkgcG9zaXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IGRlYWxzID0gW3tcbiAgICAgIGNsaWVudElkOiAnVEVfR0JQVVNEXzdoeUlOV3FBbEUnLFxuICAgICAgY29tbWlzc2lvbjogLTAuMjUsXG4gICAgICBlbnRyeVR5cGU6ICdERUFMX0VOVFJZX0lOJyxcbiAgICAgIGlkOiAnMzMyMzAwOTknLFxuICAgICAgbWFnaWM6IDEwMDAsXG4gICAgICBwbGF0Zm9ybTogJ210NScsXG4gICAgICBvcmRlcklkOiAnNDYyMTQ2OTInLFxuICAgICAgcG9zaXRpb25JZDogJzQ2MjE0NjkyJyxcbiAgICAgIHByaWNlOiAxLjI2MTAxLFxuICAgICAgcHJvZml0OiAwLFxuICAgICAgc3dhcDogMCxcbiAgICAgIHN5bWJvbDogJ0dCUFVTRCcsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0xNVQwMjo0NTowNi41MjFaJyksXG4gICAgICB0eXBlOiAnREVBTF9UWVBFX0JVWScsXG4gICAgICB2b2x1bWU6IDAuMDdcbiAgICB9XTtcbiAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdnZXREZWFsc0J5UG9zaXRpb24nICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLnBvc2l0aW9uSWQgPT09ICc0NjIxNDY5MicgJiZcbiAgICAgICAgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ1JQQycpIHtcbiAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge1xuICAgICAgICAgIHR5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWQsIGRlYWxzLFxuICAgICAgICAgIHN5bmNocm9uaXppbmc6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBhY3R1YWwgPSBhd2FpdCBjbGllbnQuZ2V0RGVhbHNCeVBvc2l0aW9uKCdhY2NvdW50SWQnLCAnNDYyMTQ2OTInKTtcbiAgICBhY3R1YWwuc2hvdWxkLm1hdGNoKHtkZWFscywgc3luY2hyb25pemluZzogZmFsc2V9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I2dldERlYWxzQnlUaW1lUmFuZ2V9XG4gICAqL1xuICBpdCgnc2hvdWxkIHJldHJpZXZlIE1ldGFUcmFkZXIgZGVhbHMgZnJvbSBBUEkgYnkgdGltZSByYW5nZScsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgZGVhbHMgPSBbe1xuICAgICAgY2xpZW50SWQ6ICdURV9HQlBVU0RfN2h5SU5XcUFsRScsXG4gICAgICBjb21taXNzaW9uOiAtMC4yNSxcbiAgICAgIGVudHJ5VHlwZTogJ0RFQUxfRU5UUllfSU4nLFxuICAgICAgaWQ6ICczMzIzMDA5OScsXG4gICAgICBtYWdpYzogMTAwMCxcbiAgICAgIHBsYXRmb3JtOiAnbXQ1JyxcbiAgICAgIG9yZGVySWQ6ICc0NjIxNDY5MicsXG4gICAgICBwb3NpdGlvbklkOiAnNDYyMTQ2OTInLFxuICAgICAgcHJpY2U6IDEuMjYxMDEsXG4gICAgICBwcm9maXQ6IDAsXG4gICAgICBzd2FwOiAwLFxuICAgICAgc3ltYm9sOiAnR0JQVVNEJyxcbiAgICAgIHRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTE1VDAyOjQ1OjA2LjUyMVonKSxcbiAgICAgIHR5cGU6ICdERUFMX1RZUEVfQlVZJyxcbiAgICAgIHZvbHVtZTogMC4wN1xuICAgIH1dO1xuICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ2dldERlYWxzQnlUaW1lUmFuZ2UnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJlxuICAgICAgICBkYXRhLnN0YXJ0VGltZSA9PT0gJzIwMjAtMDQtMTVUMDI6NDU6MDAuMDAwWicgJiYgZGF0YS5lbmRUaW1lID09PSAnMjAyMC0wNC0xNVQwMjo0NjowMC4wMDBaJyAmJlxuICAgICAgICBkYXRhLm9mZnNldCA9PT0gMSAmJiBkYXRhLmxpbWl0ID09PSAxMDAgJiYgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ1JQQycpIHtcbiAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge1xuICAgICAgICAgIHR5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWQsIGRlYWxzLFxuICAgICAgICAgIHN5bmNocm9uaXppbmc6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBhY3R1YWwgPSBhd2FpdCBjbGllbnQuZ2V0RGVhbHNCeVRpbWVSYW5nZSgnYWNjb3VudElkJywgbmV3IERhdGUoJzIwMjAtMDQtMTVUMDI6NDU6MDAuMDAwWicpLFxuICAgICAgbmV3IERhdGUoJzIwMjAtMDQtMTVUMDI6NDY6MDAuMDAwWicpLCAxLCAxMDApO1xuICAgIGFjdHVhbC5zaG91bGQubWF0Y2goe2RlYWxzLCBzeW5jaHJvbml6aW5nOiBmYWxzZX0pO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjcmVtb3ZlSGlzdG9yeX1cbiAgICovXG4gIGl0KCdzaG91bGQgcmVtb3ZlIGhpc3RvcnkgZnJvbSBBUEknLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IHJlcXVlc3RSZWNlaXZlZCA9IGZhbHNlO1xuICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ3JlbW92ZUhpc3RvcnknICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLmFwcGxpY2F0aW9uID09PSAnYXBwJykge1xuICAgICAgICByZXF1ZXN0UmVjZWl2ZWQgPSB0cnVlO1xuICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGF3YWl0IGNsaWVudC5yZW1vdmVIaXN0b3J5KCdhY2NvdW50SWQnLCAnYXBwJyk7XG4gICAgcmVxdWVzdFJlY2VpdmVkLnNob3VsZC5iZS50cnVlKCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNyZW1vdmVBcHBsaWNhdGlvbn1cbiAgICovXG4gIGl0KCdzaG91bGQgcmVtb3ZlIGFwcGxpY2F0aW9uIGZyb20gQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCByZXF1ZXN0UmVjZWl2ZWQgPSBmYWxzZTtcbiAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdyZW1vdmVBcHBsaWNhdGlvbicgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnICYmIGRhdGEuYXBwbGljYXRpb24gPT09ICdhcHBsaWNhdGlvbicpIHtcbiAgICAgICAgcmVxdWVzdFJlY2VpdmVkID0gdHJ1ZTtcbiAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge3R5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWR9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBhd2FpdCBjbGllbnQucmVtb3ZlQXBwbGljYXRpb24oJ2FjY291bnRJZCcpO1xuICAgIHJlcXVlc3RSZWNlaXZlZC5zaG91bGQuYmUudHJ1ZSgpO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjdHJhZGV9XG4gICAqL1xuICBpdCgnc2hvdWxkIGV4ZWN1dGUgYSB0cmFkZSB2aWEgbmV3IEFQSSB2ZXJzaW9uJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCB0cmFkZSA9IHtcbiAgICAgIGFjdGlvblR5cGU6ICdPUkRFUl9UWVBFX1NFTEwnLFxuICAgICAgc3ltYm9sOiAnQVVETlpEJyxcbiAgICAgIHZvbHVtZTogMC4wN1xuICAgIH07XG4gICAgbGV0IHJlc3BvbnNlID0ge1xuICAgICAgbnVtZXJpY0NvZGU6IDEwMDA5LFxuICAgICAgc3RyaW5nQ29kZTogJ1RSQURFX1JFVENPREVfRE9ORScsXG4gICAgICBtZXNzYWdlOiAnUmVxdWVzdCBjb21wbGV0ZWQnLFxuICAgICAgb3JkZXJJZDogJzQ2ODcwNDcyJ1xuICAgIH07XG4gICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICBkYXRhLnRyYWRlLnNob3VsZC5tYXRjaCh0cmFkZSk7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAndHJhZGUnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLmFwcGxpY2F0aW9uID09PSAnYXBwbGljYXRpb24nKSB7XG4gICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLCByZXNwb25zZX0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBhY3R1YWwgPSBhd2FpdCBjbGllbnQudHJhZGUoJ2FjY291bnRJZCcsIHRyYWRlKTtcbiAgICBhY3R1YWwuc2hvdWxkLm1hdGNoKHJlc3BvbnNlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I3RyYWRlfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBleGVjdXRlIGEgdHJhZGUgdmlhIEFQSSBhbmQgcmVjZWl2ZSB0cmFkZSBlcnJvciBmcm9tIG9sZCBBUEkgdmVyc2lvbicsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgdHJhZGUgPSB7XG4gICAgICBhY3Rpb25UeXBlOiAnT1JERVJfVFlQRV9TRUxMJyxcbiAgICAgIHN5bWJvbDogJ0FVRE5aRCcsXG4gICAgICB2b2x1bWU6IDAuMDdcbiAgICB9O1xuICAgIGxldCByZXNwb25zZSA9IHtcbiAgICAgIGVycm9yOiAxMDAwNixcbiAgICAgIGRlc2NyaXB0aW9uOiAnVFJBREVfUkVUQ09ERV9SRUpFQ1QnLFxuICAgICAgbWVzc2FnZTogJ1JlcXVlc3QgcmVqZWN0ZWQnLFxuICAgICAgb3JkZXJJZDogJzQ2ODcwNDcyJ1xuICAgIH07XG4gICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICBkYXRhLnRyYWRlLnNob3VsZC5tYXRjaCh0cmFkZSk7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAndHJhZGUnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLmFwcGxpY2F0aW9uID09PSAnYXBwbGljYXRpb24nKSB7XG4gICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLCByZXNwb25zZX0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjbGllbnQudHJhZGUoJ2FjY291bnRJZCcsIHRyYWRlKTtcbiAgICAgIHNob3VsZC5mYWlsKCdUcmFkZSBlcnJvciBleHBlY3RlZCcpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXJyLm1lc3NhZ2Uuc2hvdWxkLmVxdWFsKCdSZXF1ZXN0IHJlamVjdGVkJyk7XG4gICAgICBlcnIubmFtZS5zaG91bGQuZXF1YWwoJ1RyYWRlRXJyb3InKTtcbiAgICAgIGVyci5zdHJpbmdDb2RlLnNob3VsZC5lcXVhbCgnVFJBREVfUkVUQ09ERV9SRUpFQ1QnKTtcbiAgICAgIGVyci5udW1lcmljQ29kZS5zaG91bGQuZXF1YWwoMTAwMDYpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I3N1YnNjcmliZX1cbiAgICovXG4gIGl0KCdzaG91bGQgY29ubmVjdCB0byBNZXRhVHJhZGVyIHRlcm1pbmFsJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCByZXF1ZXN0UmVjZWl2ZWQgPSBmYWxzZTtcbiAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdzdWJzY3JpYmUnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLmFwcGxpY2F0aW9uID09PSAnYXBwbGljYXRpb24nICYmXG4gICAgICAgIGRhdGEuaW5zdGFuY2VJbmRleCA9PT0gMSkge1xuICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZH0pO1xuICAgICAgICByZXF1ZXN0UmVjZWl2ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGF3YWl0IGNsaWVudC5zdWJzY3JpYmUoJ2FjY291bnRJZCcsIDEpO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICByZXF1ZXN0UmVjZWl2ZWQuc2hvdWxkLmJlLnRydWUoKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I3N1YnNjcmliZX1cbiAgICovXG4gIGl0KCdzaG91bGQgY3JlYXRlIG5ldyBpbnN0YW5jZSB3aGVuIGFjY291bnQgbGltaXQgaXMgcmVhY2hlZCcsIGFzeW5jICgpID0+IHtcbiAgICBzaW5vbi5hc3NlcnQubWF0Y2goY2xpZW50LnNvY2tldEluc3RhbmNlcy5sZW5ndGgsIDEpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwOyBpKyspIHtcbiAgICAgIGNsaWVudC5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1snYWNjb3VudElkJyArIGldID0gMDtcbiAgICB9XG5cbiAgICBpby5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nvbm5lY3QnKTtcbiAgICBpby5vbignY29ubmVjdCcsIHNvY2tldCA9PiB7XG4gICAgICBzb2NrZXQub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ3N1YnNjcmliZScgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQxMDEnICYmIGRhdGEuYXBwbGljYXRpb24gPT09ICdhcHBsaWNhdGlvbicgJiZcbiAgICAgICAgICBkYXRhLmluc3RhbmNlSW5kZXggPT09IDEpIHtcbiAgICAgICAgICBzb2NrZXQuZW1pdCgncmVzcG9uc2UnLCB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBhd2FpdCBjbGllbnQuc3Vic2NyaWJlKCdhY2NvdW50SWQxMDEnLCAxKTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgc2lub24uYXNzZXJ0Lm1hdGNoKGNsaWVudC5zb2NrZXRJbnN0YW5jZXMubGVuZ3RoLCAyKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I3N1YnNjcmliZX1cbiAgICovXG4gIGl0KCdzaG91bGQgcmV0dXJuIGVycm9yIGlmIGNvbm5lY3QgdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCBmYWlsZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IHJlcXVlc3RSZWNlaXZlZCA9IGZhbHNlO1xuICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ3N1YnNjcmliZScgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnICYmIGRhdGEuYXBwbGljYXRpb24gPT09ICdhcHBsaWNhdGlvbicpIHtcbiAgICAgICAgcmVxdWVzdFJlY2VpdmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNlcnZlci5lbWl0KCdwcm9jZXNzaW5nRXJyb3InLCB7XG4gICAgICAgIGlkOiAxLCBlcnJvcjogJ05vdEF1dGhlbnRpY2F0ZWRFcnJvcicsIG1lc3NhZ2U6ICdFcnJvciBtZXNzYWdlJyxcbiAgICAgICAgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgbGV0IHN1Y2Nlc3MgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjbGllbnQuc3Vic2NyaWJlKCdhY2NvdW50SWQnKTtcbiAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVyci5uYW1lLnNob3VsZC5lcXVhbCgnTm90Q29ubmVjdGVkRXJyb3InKTtcbiAgICB9XG4gICAgc3VjY2Vzcy5zaG91bGQuYmUudHJ1ZSgpO1xuICAgIHJlcXVlc3RSZWNlaXZlZC5zaG91bGQuYmUudHJ1ZSgpO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjcmVjb25uZWN0fVxuICAgKi9cbiAgaXQoJ3Nob3VsZCByZWNvbm5lY3QgdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCcsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgcmVxdWVzdFJlY2VpdmVkID0gZmFsc2U7XG4gICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAncmVjb25uZWN0JyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ2FwcGxpY2F0aW9uJykge1xuICAgICAgICByZXF1ZXN0UmVjZWl2ZWQgPSB0cnVlO1xuICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGF3YWl0IGNsaWVudC5yZWNvbm5lY3QoJ2FjY291bnRJZCcpO1xuICAgIHJlcXVlc3RSZWNlaXZlZC5zaG91bGQuYmUudHJ1ZSgpO1xuICB9KTtcblxuICAvKipcbiAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjZ2V0U3ltYm9sc31cbiAgICovXG4gIGl0KCdzaG91bGQgcmV0cmlldmUgc3ltYm9scyBmcm9tIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgc3ltYm9scyA9IFsnRVVSVVNEJ107XG4gICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAnZ2V0U3ltYm9scycgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnICYmIGRhdGEuYXBwbGljYXRpb24gPT09ICdSUEMnKSB7XG4gICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHtcbiAgICAgICAgICB0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLCBzeW1ib2xzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBhY3R1YWwgPSBhd2FpdCBjbGllbnQuZ2V0U3ltYm9scygnYWNjb3VudElkJyk7XG4gICAgYWN0dWFsLnNob3VsZC5tYXRjaChzeW1ib2xzKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I2dldFN5bWJvbFNwZWNpZmljYXRpb259XG4gICAqL1xuICBpdCgnc2hvdWxkIHJldHJpZXZlIHN5bWJvbCBzcGVjaWZpY2F0aW9uIGZyb20gQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBzcGVjaWZpY2F0aW9uID0ge1xuICAgICAgc3ltYm9sOiAnQVVETlpEJyxcbiAgICAgIHRpY2tTaXplOiAwLjAwMDAxLFxuICAgICAgbWluVm9sdW1lOiAwLjAxLFxuICAgICAgbWF4Vm9sdW1lOiAxMDAsXG4gICAgICB2b2x1bWVTdGVwOiAwLjAxXG4gICAgfTtcbiAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdnZXRTeW1ib2xTcGVjaWZpY2F0aW9uJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgZGF0YS5zeW1ib2wgPT09ICdBVUROWkQnICYmXG4gICAgICAgIGRhdGEuYXBwbGljYXRpb24gPT09ICdSUEMnKSB7XG4gICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHtcbiAgICAgICAgICB0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLFxuICAgICAgICAgIHNwZWNpZmljYXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGFjdHVhbCA9IGF3YWl0IGNsaWVudC5nZXRTeW1ib2xTcGVjaWZpY2F0aW9uKCdhY2NvdW50SWQnLCAnQVVETlpEJyk7XG4gICAgYWN0dWFsLnNob3VsZC5tYXRjaChzcGVjaWZpY2F0aW9uKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I2dldFN5bWJvbFByaWNlfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBzeW1ib2wgcHJpY2UgZnJvbSBBUEknLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IHByaWNlID0ge1xuICAgICAgc3ltYm9sOiAnQVVETlpEJyxcbiAgICAgIGJpZDogMS4wNTI5NyxcbiAgICAgIGFzazogMS4wNTMwOSxcbiAgICAgIHByb2ZpdFRpY2tWYWx1ZTogMC41OTczMSxcbiAgICAgIGxvc3NUaWNrVmFsdWU6IDAuNTk3MzZcbiAgICB9O1xuICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ2dldFN5bWJvbFByaWNlJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgZGF0YS5zeW1ib2wgPT09ICdBVUROWkQnICYmXG4gICAgICAgIGRhdGEuYXBwbGljYXRpb24gPT09ICdSUEMnKSB7XG4gICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLCBwcmljZX0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBhY3R1YWwgPSBhd2FpdCBjbGllbnQuZ2V0U3ltYm9sUHJpY2UoJ2FjY291bnRJZCcsICdBVUROWkQnKTtcbiAgICBhY3R1YWwuc2hvdWxkLm1hdGNoKHByaWNlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I2dldENhbmRsZX1cbiAgICovXG4gIGl0KCdzaG91bGQgcmV0cmlldmUgY2FuZGxlIGZyb20gQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBjYW5kbGUgPSB7XG4gICAgICBzeW1ib2w6ICdBVUROWkQnLFxuICAgICAgdGltZWZyYW1lOiAnMTVtJyxcbiAgICAgIHRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTA3VDAzOjQ1OjAwLjAwMFonKSxcbiAgICAgIGJyb2tlclRpbWU6ICcyMDIwLTA0LTA3IDA2OjQ1OjAwLjAwMCcsXG4gICAgICBvcGVuOiAxLjAzMjk3LFxuICAgICAgaGlnaDogMS4wNjMwOSxcbiAgICAgIGxvdzogMS4wMjcwNSxcbiAgICAgIGNsb3NlOiAxLjA0MyxcbiAgICAgIHRpY2tWb2x1bWU6IDE0MzUsXG4gICAgICBzcHJlYWQ6IDE3LFxuICAgICAgdm9sdW1lOiAzNDVcbiAgICB9O1xuICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ2dldENhbmRsZScgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnICYmIGRhdGEuc3ltYm9sID09PSAnQVVETlpEJyAmJlxuICAgICAgICBkYXRhLmFwcGxpY2F0aW9uID09PSAnUlBDJyAmJiBkYXRhLnRpbWVmcmFtZSA9PT0gJzE1bScpIHtcbiAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge3R5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWQsIGNhbmRsZX0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBhY3R1YWwgPSBhd2FpdCBjbGllbnQuZ2V0Q2FuZGxlKCdhY2NvdW50SWQnLCAnQVVETlpEJywgJzE1bScpO1xuICAgIGFjdHVhbC5zaG91bGQubWF0Y2goY2FuZGxlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I2dldFRpY2t9XG4gICAqL1xuICBpdCgnc2hvdWxkIHJldHJpZXZlIGxhdGVzdCB0aWNrIGZyb20gQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCB0aWNrID0ge1xuICAgICAgc3ltYm9sOiAnQVVETlpEJyxcbiAgICAgIHRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTA3VDAzOjQ1OjAwLjAwMFonKSxcbiAgICAgIGJyb2tlclRpbWU6ICcyMDIwLTA0LTA3IDA2OjQ1OjAwLjAwMCcsXG4gICAgICBiaWQ6IDEuMDUyOTcsXG4gICAgICBhc2s6IDEuMDUzMDksXG4gICAgICBsYXN0OiAwLjUyOTgsXG4gICAgICB2b2x1bWU6IDAuMTMsXG4gICAgICBzaWRlOiAnYnV5J1xuICAgIH07XG4gICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAnZ2V0VGljaycgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnICYmIGRhdGEuc3ltYm9sID09PSAnQVVETlpEJyAmJlxuICAgICAgICBkYXRhLmFwcGxpY2F0aW9uID09PSAnUlBDJykge1xuICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCwgdGlja30pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBhY3R1YWwgPSBhd2FpdCBjbGllbnQuZ2V0VGljaygnYWNjb3VudElkJywgJ0FVRE5aRCcpO1xuICAgIGFjdHVhbC5zaG91bGQubWF0Y2godGljayk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNnZXRCb29rfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBsYXRlc3Qgb3JkZXIgYm9vayBmcm9tIEFQSScsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgYm9vayA9IHtcbiAgICAgIHN5bWJvbDogJ0FVRE5aRCcsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0wN1QwMzo0NTowMC4wMDBaJyksXG4gICAgICBicm9rZXJUaW1lOiAnMjAyMC0wNC0wNyAwNjo0NTowMC4wMDAnLFxuICAgICAgYm9vazogW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogJ0JPT0tfVFlQRV9TRUxMJyxcbiAgICAgICAgICBwcmljZTogMS4wNTMwOSxcbiAgICAgICAgICB2b2x1bWU6IDUuNjdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICdCT09LX1RZUEVfQlVZJyxcbiAgICAgICAgICBwcmljZTogMS4wNTI5NyxcbiAgICAgICAgICB2b2x1bWU6IDMuNDVcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAnZ2V0Qm9vaycgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnICYmIGRhdGEuc3ltYm9sID09PSAnQVVETlpEJyAmJlxuICAgICAgICBkYXRhLmFwcGxpY2F0aW9uID09PSAnUlBDJykge1xuICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCwgYm9va30pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBhY3R1YWwgPSBhd2FpdCBjbGllbnQuZ2V0Qm9vaygnYWNjb3VudElkJywgJ0FVRE5aRCcpO1xuICAgIGFjdHVhbC5zaG91bGQubWF0Y2goYm9vayk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNzZW5kVXB0aW1lfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBzZW50IHVwdGltZSBzdGF0cyB0byB0aGUgc2VydmVyJywgYXN5bmMgKCkgPT4ge1xuICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ3NhdmVVcHRpbWUnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJlxuICAgICAgICBKU09OLnN0cmluZ2lmeShkYXRhLnVwdGltZSkgPT09IEpTT04uc3RyaW5naWZ5KHsnMWgnOiAxMDB9KSAmJlxuICAgICAgICBkYXRhLmFwcGxpY2F0aW9uID09PSAnYXBwbGljYXRpb24nKSB7XG4gICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgYXdhaXQgY2xpZW50LnNhdmVVcHRpbWUoJ2FjY291bnRJZCcsIHsnMWgnOiAxMDB9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I3Vuc3Vic2NyaWJlfVxuICAgKi9cbiAgaXQoJ3Nob3VsZCB1bnN1YnNjcmliZSBmcm9tIGFjY291bnQgZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgcmVxdWVzdFJlY2VpdmVkID0gZmFsc2U7XG5cbiAgICBsZXQgcmVzcG9uc2UgPSB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiAnYWNjb3VudElkJ307XG4gICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAndW5zdWJzY3JpYmUnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJykge1xuICAgICAgICByZXF1ZXN0UmVjZWl2ZWQgPSB0cnVlO1xuICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCBPYmplY3QuYXNzaWduKHtyZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkfSwgcmVzcG9uc2UpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBhd2FpdCBjbGllbnQudW5zdWJzY3JpYmUoJ2FjY291bnRJZCcpO1xuICAgIHNpbm9uLmFzc2VydC5tYXRjaChyZXF1ZXN0UmVjZWl2ZWQsIHRydWUpO1xuICAgIGNsaWVudC5zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzLnNob3VsZC5ub3QuaGF2ZS5wcm9wZXJ0eSgnYWNjb3VudElkJyk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCN1bnN1YnNjcmliZX1cbiAgICovXG4gIGl0KCdzaG91bGQgaWdub3JlIG5vdCBmb3VuZCBleGNlcHRpb24gb24gdW5zdWJzY3JpYmUnLCBhc3luYyAoKSA9PiB7XG4gICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICBzZXJ2ZXIuZW1pdCgncHJvY2Vzc2luZ0Vycm9yJywge1xuICAgICAgICBpZDogMSwgZXJyb3I6ICdWYWxpZGF0aW9uRXJyb3InLCBtZXNzYWdlOiAnVmFsaWRhdGlvbiBmYWlsZWQnLFxuICAgICAgICBkZXRhaWxzOiBbe3BhcmFtZXRlcjogJ3ZvbHVtZScsIG1lc3NhZ2U6ICdSZXF1aXJlZCB2YWx1ZS4nfV0sIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjbGllbnQudW5zdWJzY3JpYmUoJ2FjY291bnRJZCcpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWxpZGF0aW9uRXJyb3IgZXh0ZWN0ZWQnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVyci5uYW1lLnNob3VsZC5lcXVhbCgnVmFsaWRhdGlvbkVycm9yJyk7XG4gICAgICBlcnIuZGV0YWlscy5zaG91bGQubWF0Y2goW3tcbiAgICAgICAgcGFyYW1ldGVyOiAndm9sdW1lJyxcbiAgICAgICAgbWVzc2FnZTogJ1JlcXVpcmVkIHZhbHVlLidcbiAgICAgIH1dKTtcbiAgICB9XG4gICAgc2VydmVyLnJlbW92ZUFsbExpc3RlbmVycygncmVxdWVzdCcpO1xuICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgc2VydmVyLmVtaXQoJ3Byb2Nlc3NpbmdFcnJvcicsIHtcbiAgICAgICAgaWQ6IDEsIGVycm9yOiAnTm90Rm91bmRFcnJvcicsIG1lc3NhZ2U6ICdBY2NvdW50IG5vdCBmb3VuZCcsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGF3YWl0IGNsaWVudC51bnN1YnNjcmliZSgnYWNjb3VudElkJyk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdlcnJvciBoYW5kbGluZycsICgpID0+IHtcblxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I3RyYWRlfVxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIFZhbGlkYXRpb25FcnJvcicsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCB0cmFkZSA9IHtcbiAgICAgICAgYWN0aW9uVHlwZTogJ09SREVSX1RZUEVfU0VMTCcsXG4gICAgICAgIHN5bWJvbDogJ0FVRE5aRCdcbiAgICAgIH07XG4gICAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgICAgc2VydmVyLmVtaXQoJ3Byb2Nlc3NpbmdFcnJvcicsIHtcbiAgICAgICAgICBpZDogMSwgZXJyb3I6ICdWYWxpZGF0aW9uRXJyb3InLCBtZXNzYWdlOiAnVmFsaWRhdGlvbiBmYWlsZWQnLFxuICAgICAgICAgIGRldGFpbHM6IFt7cGFyYW1ldGVyOiAndm9sdW1lJywgbWVzc2FnZTogJ1JlcXVpcmVkIHZhbHVlLid9XSwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgY2xpZW50LnRyYWRlKCdhY2NvdW50SWQnLCB0cmFkZSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsaWRhdGlvbkVycm9yIGV4dGVjdGVkJyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyLm5hbWUuc2hvdWxkLmVxdWFsKCdWYWxpZGF0aW9uRXJyb3InKTtcbiAgICAgICAgZXJyLmRldGFpbHMuc2hvdWxkLm1hdGNoKFt7XG4gICAgICAgICAgcGFyYW1ldGVyOiAndm9sdW1lJyxcbiAgICAgICAgICBtZXNzYWdlOiAnUmVxdWlyZWQgdmFsdWUuJ1xuICAgICAgICB9XSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNnZXRQb3NpdGlvbn1cbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBOb3RGb3VuZEVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICAgIHNlcnZlci5lbWl0KCdwcm9jZXNzaW5nRXJyb3InLCB7XG4gICAgICAgICAgaWQ6IDEsIGVycm9yOiAnTm90Rm91bmRFcnJvcicsIG1lc3NhZ2U6ICdQb3NpdGlvbiBpZCAxMjM0IG5vdCBmb3VuZCcsXG4gICAgICAgICAgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgY2xpZW50LmdldFBvc2l0aW9uKCdhY2NvdW50SWQnLCAnMTIzNCcpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdEZvdW5kRXJyb3IgZXh0ZWN0ZWQnKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBlcnIubmFtZS5zaG91bGQuZXF1YWwoJ05vdEZvdW5kRXJyb3InKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I2dldFBvc2l0aW9ufVxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIE5vdFN5bmNocm9uaXplZEVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICAgIHNlcnZlci5lbWl0KCdwcm9jZXNzaW5nRXJyb3InLCB7XG4gICAgICAgICAgaWQ6IDEsIGVycm9yOiAnTm90U3luY2hyb25pemVkRXJyb3InLCBtZXNzYWdlOiAnRXJyb3IgbWVzc2FnZScsXG4gICAgICAgICAgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgY2xpZW50LmdldFBvc2l0aW9uKCdhY2NvdW50SWQnLCAnMTIzNCcpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdFN5bmNocm9uaXplZEVycm9yIGV4dGVjdGVkJyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyLm5hbWUuc2hvdWxkLmVxdWFsKCdOb3RTeW5jaHJvbml6ZWRFcnJvcicpO1xuICAgICAgfVxuICAgIH0pLnRpbWVvdXQoODAwMCk7XG5cbiAgICAvKipcbiAgICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNnZXRQb3NpdGlvbn1cbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBOb3RDb25uZWN0ZWRFcnJvcicsIGFzeW5jICgpID0+IHtcbiAgICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgICBzZXJ2ZXIuZW1pdCgncHJvY2Vzc2luZ0Vycm9yJywge1xuICAgICAgICAgIGlkOiAxLCBlcnJvcjogJ05vdEF1dGhlbnRpY2F0ZWRFcnJvcicsIG1lc3NhZ2U6ICdFcnJvciBtZXNzYWdlJyxcbiAgICAgICAgICByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBjbGllbnQuZ2V0UG9zaXRpb24oJ2FjY291bnRJZCcsICcxMjM0Jyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90Q29ubmVjdGVkRXJyb3IgZXh0ZWN0ZWQnKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBlcnIubmFtZS5zaG91bGQuZXF1YWwoJ05vdENvbm5lY3RlZEVycm9yJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNnZXRQb3NpdGlvbn1cbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBvdGhlciBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgICAgc2VydmVyLmVtaXQoJ3Byb2Nlc3NpbmdFcnJvcicsIHtcbiAgICAgICAgICBpZDogMSwgZXJyb3I6ICdFcnJvcicsIG1lc3NhZ2U6ICdFcnJvciBtZXNzYWdlJyxcbiAgICAgICAgICByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBjbGllbnQuZ2V0UG9zaXRpb24oJ2FjY291bnRJZCcsICcxMjM0Jyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZXJuYWxFcnJvciBleHRlY3RlZCcpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVyci5uYW1lLnNob3VsZC5lcXVhbCgnSW50ZXJuYWxFcnJvcicpO1xuICAgICAgfVxuICAgIH0pLnRpbWVvdXQoODAwMCk7XG5cbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2Nvbm5lY3Rpb24gc3RhdHVzIHN5bmNocm9uaXphdGlvbicsICgpID0+IHtcblxuICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICBjbGllbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHByb2Nlc3MgYXV0aGVudGljYXRlZCBzeW5jaHJvbml6YXRpb24gZXZlbnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgbGlzdGVuZXIgPSB7XG4gICAgICAgIG9uQ29ubmVjdGVkOiAoKSA9PiB7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvbkNvbm5lY3RlZCcpLnJlc29sdmVzKCk7XG4gICAgICBjbGllbnQuYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIoJ2FjY291bnRJZCcsIGxpc3RlbmVyKTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ2F1dGhlbnRpY2F0ZWQnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBob3N0OiAncHMtbXBhLTEnLFxuICAgICAgICBpbnN0YW5jZUluZGV4OiAxLCByZXBsaWNhczogMn0pO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25Db25uZWN0ZWQsICcxOnBzLW1wYS0xJywgMik7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHByb2Nlc3MgYXV0aGVudGljYXRlZCBzeW5jaHJvbml6YXRpb24gZXZlbnQgd2l0aCBzZXNzaW9uIGlkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IGxpc3RlbmVyID0ge1xuICAgICAgICBvbkNvbm5lY3RlZDogKCkgPT4ge1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2FuZGJveC5zdHViKGxpc3RlbmVyLCAnb25Db25uZWN0ZWQnKS5yZXNvbHZlcygpO1xuICAgICAgY2xpZW50LmFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKCdhY2NvdW50SWQnLCBsaXN0ZW5lcik7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdhdXRoZW50aWNhdGVkJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgaG9zdDogJ3BzLW1wYS0xJyxcbiAgICAgICAgaW5zdGFuY2VJbmRleDogMiwgcmVwbGljYXM6IDQsIHNlc3Npb25JZDogJ3dyb25nJ30pO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnYXV0aGVudGljYXRlZCcsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMScsXG4gICAgICAgIGluc3RhbmNlSW5kZXg6IDEsIHJlcGxpY2FzOiAyLCBzZXNzaW9uSWQ6IGNsaWVudC5fc2Vzc2lvbklkfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbENvdW50KGxpc3RlbmVyLm9uQ29ubmVjdGVkLCAxKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKGxpc3RlbmVyLm9uQ29ubmVjdGVkLCAnMTpwcy1tcGEtMScsIDIpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBwcm9jZXNzIGJyb2tlciBjb25uZWN0aW9uIHN0YXR1cyBldmVudCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBsaXN0ZW5lciA9IHtcbiAgICAgICAgb25Db25uZWN0ZWQ6ICgpID0+IHt9LFxuICAgICAgICBvbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkOiAoKSA9PiB7fVxuICAgICAgfTtcbiAgICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uQnJva2VyQ29ubmVjdGlvblN0YXR1c0NoYW5nZWQnKS5yZXNvbHZlcygpO1xuICAgICAgY2xpZW50LmFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKCdhY2NvdW50SWQnLCBsaXN0ZW5lcik7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdhdXRoZW50aWNhdGVkJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgaG9zdDogJ3BzLW1wYS0xJyxcbiAgICAgICAgaW5zdGFuY2VJbmRleDogMX0pO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnc3RhdHVzJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgaG9zdDogJ3BzLW1wYS0xJywgY29ubmVjdGVkOiB0cnVlLFxuICAgICAgICBpbnN0YW5jZUluZGV4OiAxfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChsaXN0ZW5lci5vbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkLCAnMTpwcy1tcGEtMScsIHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjYWxsIGFuIG9uRGlzY29ubmVjdCBpZiB0aGVyZSB3YXMgbm8gc2lnbmFsIGZvciBhIGxvbmcgdGltZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNsb2NrID0gc2lub24udXNlRmFrZVRpbWVycyh7c2hvdWxkQWR2YW5jZVRpbWU6IHRydWV9KTtcbiAgICAgIGxldCBsaXN0ZW5lciA9IHtcbiAgICAgICAgb25Db25uZWN0ZWQ6ICgpID0+IHt9LFxuICAgICAgICBvbkRpc2Nvbm5lY3RlZDogKCkgPT4ge30sXG4gICAgICAgIG9uQnJva2VyQ29ubmVjdGlvblN0YXR1c0NoYW5nZWQ6ICgpID0+IHt9XG4gICAgICB9O1xuICAgICAgc2FuZGJveC5zdHViKGxpc3RlbmVyLCAnb25EaXNjb25uZWN0ZWQnKS5yZXNvbHZlcygpO1xuICAgICAgY2xpZW50LmFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKCdhY2NvdW50SWQnLCBsaXN0ZW5lcik7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdhdXRoZW50aWNhdGVkJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgaG9zdDogJ3BzLW1wYS0xJyxcbiAgICAgICAgaW5zdGFuY2VJbmRleDogMSwgcmVwbGljYXM6IDJ9KTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ3N0YXR1cycsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMScsIGNvbm5lY3RlZDogdHJ1ZSxcbiAgICAgICAgaW5zdGFuY2VJbmRleDogMX0pO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgICAgYXdhaXQgY2xvY2sudGlja0FzeW5jKDEwMDAwKTtcbiAgICAgIGF3YWl0IHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ3N0YXR1cycsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMScsIGNvbm5lY3RlZDogdHJ1ZSxcbiAgICAgICAgaW5zdGFuY2VJbmRleDogMX0pO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgICAgYXdhaXQgY2xvY2sudGlja0FzeW5jKDU1MDAwKTtcbiAgICAgIHNpbm9uLmFzc2VydC5ub3RDYWxsZWQobGlzdGVuZXIub25EaXNjb25uZWN0ZWQpO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnYXV0aGVudGljYXRlZCcsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMScsXG4gICAgICAgIGluc3RhbmNlSW5kZXg6IDEsIHJlcGxpY2FzOiAyfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgICBhd2FpdCBjbG9jay50aWNrQXN5bmMoMTAwMDApO1xuICAgICAgc2lub24uYXNzZXJ0Lm5vdENhbGxlZChsaXN0ZW5lci5vbkRpc2Nvbm5lY3RlZCk7XG4gICAgICBhd2FpdCBjbG9jay50aWNrQXN5bmMoNTUwMDApO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25EaXNjb25uZWN0ZWQsICcxOnBzLW1wYS0xJyk7XG4gICAgICBjbG9jay5yZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNsb3NlIHN0cmVhbSBvbiB0aW1lb3V0IGlmIGFub3RoZXIgc3RyZWFtIGV4aXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNsb2NrID0gc2lub24udXNlRmFrZVRpbWVycyh7c2hvdWxkQWR2YW5jZVRpbWU6IHRydWV9KTtcbiAgICAgIGxldCBsaXN0ZW5lciA9IHtcbiAgICAgICAgb25Db25uZWN0ZWQ6ICgpID0+IHt9LFxuICAgICAgICBvbkRpc2Nvbm5lY3RlZDogKCkgPT4ge30sXG4gICAgICAgIG9uU3RyZWFtQ2xvc2VkOiAoKSA9PiB7fSxcbiAgICAgICAgb25Ccm9rZXJDb25uZWN0aW9uU3RhdHVzQ2hhbmdlZDogKCkgPT4ge31cbiAgICAgIH07XG4gICAgICBjb25zdCBvblRpbWVvdXRTdHViID0gc2FuZGJveC5zdHViKGNsaWVudC5fc3Vic2NyaXB0aW9uTWFuYWdlciwgJ29uVGltZW91dCcpLnJlc29sdmVzKCk7XG4gICAgICBjb25zdCBvblN0cmVhbUNsb3NlZFN0dWIgPSBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvblN0cmVhbUNsb3NlZCcpLnJlc29sdmVzKCk7XG4gICAgICBjb25zdCBvbkRpc2Nvbm5lY3RlZFN0dWIgPSBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvbkRpc2Nvbm5lY3RlZCcpLnJlc29sdmVzKCk7XG4gICAgICBzYW5kYm94LnN0dWIoY2xpZW50Ll9zdWJzY3JpcHRpb25NYW5hZ2VyLCAnb25EaXNjb25uZWN0ZWQnKS5yZXNvbHZlcygpO1xuICAgICAgY2xpZW50LmFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKCdhY2NvdW50SWQnLCBsaXN0ZW5lcik7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdhdXRoZW50aWNhdGVkJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgaG9zdDogJ3BzLW1wYS0xJyxcbiAgICAgICAgaW5zdGFuY2VJbmRleDogMSwgcmVwbGljYXM6IDJ9KTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICAgIGF3YWl0IGNsb2NrLnRpY2tBc3luYygxNTAwMCk7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdhdXRoZW50aWNhdGVkJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgaG9zdDogJ3BzLW1wYS0yJyxcbiAgICAgICAgaW5zdGFuY2VJbmRleDogMSwgcmVwbGljYXM6IDJ9KTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ3N0YXR1cycsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMScsIGNvbm5lY3RlZDogdHJ1ZSxcbiAgICAgICAgaW5zdGFuY2VJbmRleDogMX0pO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnc3RhdHVzJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgaG9zdDogJ3BzLW1wYS0yJywgY29ubmVjdGVkOiB0cnVlLFxuICAgICAgICBpbnN0YW5jZUluZGV4OiAxfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgICBhd2FpdCBjbG9jay50aWNrQXN5bmMoMTUwMDApO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnc3RhdHVzJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgaG9zdDogJ3BzLW1wYS0xJywgY29ubmVjdGVkOiB0cnVlLFxuICAgICAgICBpbnN0YW5jZUluZGV4OiAxfSk7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdzdGF0dXMnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBob3N0OiAncHMtbXBhLTInLCBjb25uZWN0ZWQ6IHRydWUsXG4gICAgICAgIGluc3RhbmNlSW5kZXg6IDF9KTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICAgIGF3YWl0IGNsb2NrLnRpY2tBc3luYyg1NTAwMCk7XG4gICAgICBzaW5vbi5hc3NlcnQubm90Q2FsbGVkKG9uRGlzY29ubmVjdGVkU3R1Yik7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdzdGF0dXMnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBob3N0OiAncHMtbXBhLTEnLCBjb25uZWN0ZWQ6IHRydWUsXG4gICAgICAgIGluc3RhbmNlSW5kZXg6IDF9KTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ3N0YXR1cycsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMicsIGNvbm5lY3RlZDogdHJ1ZSxcbiAgICAgICAgaW5zdGFuY2VJbmRleDogMX0pO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgICAgYXdhaXQgY2xvY2sudGlja0FzeW5jKDE1MDAwKTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ3N0YXR1cycsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMicsIGNvbm5lY3RlZDogdHJ1ZSxcbiAgICAgICAgaW5zdGFuY2VJbmRleDogMX0pO1xuICAgICAgc2lub24uYXNzZXJ0Lm5vdENhbGxlZChvbkRpc2Nvbm5lY3RlZFN0dWIpO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgICAgYXdhaXQgY2xvY2sudGlja0FzeW5jKDU1MDAwKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKG9uU3RyZWFtQ2xvc2VkU3R1YiwgJzE6cHMtbXBhLTEnKTtcbiAgICAgIHNpbm9uLmFzc2VydC5ub3RDYWxsZWQob25EaXNjb25uZWN0ZWRTdHViKTtcbiAgICAgIHNpbm9uLmFzc2VydC5ub3RDYWxsZWQob25UaW1lb3V0U3R1Yik7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgICBhd2FpdCBjbG9jay50aWNrQXN5bmMoMTUwMDApO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgob25EaXNjb25uZWN0ZWRTdHViLCAnMTpwcy1tcGEtMicpO1xuICAgICAgc2lub24uYXNzZXJ0Lm5vdENhbGxlZChjbGllbnQuX3N1YnNjcmlwdGlvbk1hbmFnZXIub25EaXNjb25uZWN0ZWQpO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgob25UaW1lb3V0U3R1YiwgJ2FjY291bnRJZCcsIDEpO1xuICAgICAgY2xvY2sucmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBwcm9jZXNzIHNlcnZlci1zaWRlIGhlYWx0aCBzdGF0dXMgZXZlbnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgbGlzdGVuZXIgPSB7XG4gICAgICAgIG9uQ29ubmVjdGVkOiAoKSA9PiB7fSxcbiAgICAgICAgb25Ccm9rZXJDb25uZWN0aW9uU3RhdHVzQ2hhbmdlZDogKCkgPT4ge30sXG4gICAgICAgIG9uSGVhbHRoU3RhdHVzOiAoKSA9PiB7fVxuICAgICAgfTtcbiAgICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uSGVhbHRoU3RhdHVzJykucmVzb2x2ZXMoKTtcbiAgICAgIGNsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcignYWNjb3VudElkJywgbGlzdGVuZXIpO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnYXV0aGVudGljYXRlZCcsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMScsXG4gICAgICAgIGluc3RhbmNlSW5kZXg6IDF9KTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ3N0YXR1cycsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMScsIGNvbm5lY3RlZDogdHJ1ZSxcbiAgICAgICAgaGVhbHRoU3RhdHVzOiB7cmVzdEFwaUhlYWx0aHk6IHRydWV9LCBpbnN0YW5jZUluZGV4OiAxfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChsaXN0ZW5lci5vbkhlYWx0aFN0YXR1cywgJzE6cHMtbXBhLTEnLCB7cmVzdEFwaUhlYWx0aHk6IHRydWV9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcHJvY2VzcyBkaXNjb25uZWN0ZWQgc3luY2hyb25pemF0aW9uIGV2ZW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IGxpc3RlbmVyID0ge1xuICAgICAgICBvbkNvbm5lY3RlZDogKCkgPT4ge30sXG4gICAgICAgIG9uRGlzY29ubmVjdGVkOiAoKSA9PiB7fVxuICAgICAgfTtcbiAgICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uRGlzY29ubmVjdGVkJykucmVzb2x2ZXMoKTtcbiAgICAgIGNsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcignYWNjb3VudElkJywgbGlzdGVuZXIpO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnYXV0aGVudGljYXRlZCcsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMScsXG4gICAgICAgIGluc3RhbmNlSW5kZXg6IDF9KTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ2Rpc2Nvbm5lY3RlZCcsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMScsXG4gICAgICAgIGluc3RhbmNlSW5kZXg6IDF9KTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKGxpc3RlbmVyLm9uRGlzY29ubmVjdGVkLCAnMTpwcy1tcGEtMScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjbG9zZSB0aGUgc3RyZWFtIGlmIGhvc3QgbmFtZSBkaXNjb25uZWN0ZWQgYW5kIGFub3RoZXIgc3RyZWFtIGV4aXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBsaXN0ZW5lciA9IHtcbiAgICAgICAgb25Db25uZWN0ZWQ6ICgpID0+IHt9LFxuICAgICAgICBvbkRpc2Nvbm5lY3RlZDogKCkgPT4ge30sXG4gICAgICAgIG9uU3RyZWFtQ2xvc2VkOiAoKSA9PiB7fSxcbiAgICAgIH07XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvbkRpc2Nvbm5lY3RlZCcpLnJlc29sdmVzKCk7XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvblN0cmVhbUNsb3NlZCcpLnJlc29sdmVzKCk7XG4gICAgICBjb25zdCBvbkRpc2Nvbm5lY3RlZFN0dWIgPSBzYW5kYm94LnN0dWIoY2xpZW50Ll9zdWJzY3JpcHRpb25NYW5hZ2VyLCAnb25EaXNjb25uZWN0ZWQnKS5yZXNvbHZlcygpO1xuICAgICAgY2xpZW50LmFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKCdhY2NvdW50SWQnLCBsaXN0ZW5lcik7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdhdXRoZW50aWNhdGVkJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgaG9zdDogJ3BzLW1wYS0xJyxcbiAgICAgICAgaW5zdGFuY2VJbmRleDogMSwgcmVwbGljYXM6IDJ9KTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ2F1dGhlbnRpY2F0ZWQnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBob3N0OiAncHMtbXBhLTInLFxuICAgICAgICBpbnN0YW5jZUluZGV4OiAxLCByZXBsaWNhczogMn0pO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnZGlzY29ubmVjdGVkJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgaG9zdDogJ3BzLW1wYS0xJyxcbiAgICAgICAgaW5zdGFuY2VJbmRleDogMX0pO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25TdHJlYW1DbG9zZWQsICcxOnBzLW1wYS0xJyk7XG4gICAgICBzaW5vbi5hc3NlcnQubm90Q2FsbGVkKGxpc3RlbmVyLm9uRGlzY29ubmVjdGVkKTtcbiAgICAgIHNpbm9uLmFzc2VydC5ub3RDYWxsZWQob25EaXNjb25uZWN0ZWRTdHViKTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ2Rpc2Nvbm5lY3RlZCcsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMicsXG4gICAgICAgIGluc3RhbmNlSW5kZXg6IDF9KTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRPbmNlKGxpc3RlbmVyLm9uRGlzY29ubmVjdGVkKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKG9uRGlzY29ubmVjdGVkU3R1YiwgJ2FjY291bnRJZCcsIDEpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgndGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uJywgKCkgPT4ge1xuXG4gICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgIGNsaWVudC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgb25seSBhY2NlcHQgcGFja2V0cyB3aXRoIG93biBzeW5jaHJvbml6YXRpb24gaWRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IGxpc3RlbmVyID0ge1xuICAgICAgICBvbkFjY291bnRJbmZvcm1hdGlvblVwZGF0ZWQ6ICgpID0+IHt9LFxuICAgICAgfTtcbiAgICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uQWNjb3VudEluZm9ybWF0aW9uVXBkYXRlZCcpLnJlc29sdmVzKCk7XG4gICAgICBjbGllbnQuYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIoJ2FjY291bnRJZCcsIGxpc3RlbmVyKTtcbiAgICAgIHNhbmRib3guc3R1YihjbGllbnQuX3NvY2tldEluc3RhbmNlc1swXS5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIsIFxuICAgICAgICAnYWN0aXZlU3luY2hyb25pemF0aW9uSWRzJykuZ2V0KCgpID0+IFsnc3luY2hyb25pemF0aW9uSWQnXSk7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdhY2NvdW50SW5mb3JtYXRpb24nLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBcbiAgICAgICAgYWNjb3VudEluZm9ybWF0aW9uOiB7fSwgaW5zdGFuY2VJbmRleDogMX0pO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxDb3VudChsaXN0ZW5lci5vbkFjY291bnRJbmZvcm1hdGlvblVwZGF0ZWQsIDEpO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnYWNjb3VudEluZm9ybWF0aW9uJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgXG4gICAgICAgIGFjY291bnRJbmZvcm1hdGlvbjoge30sIGluc3RhbmNlSW5kZXg6IDEsIHN5bmNocm9uaXphdGlvbklkOiAnd3JvbmcnfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbENvdW50KGxpc3RlbmVyLm9uQWNjb3VudEluZm9ybWF0aW9uVXBkYXRlZCwgMSk7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdhY2NvdW50SW5mb3JtYXRpb24nLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBcbiAgICAgICAgYWNjb3VudEluZm9ybWF0aW9uOiB7fSwgaW5zdGFuY2VJbmRleDogMSwgc3luY2hyb25pemF0aW9uSWQ6ICdzeW5jaHJvbml6YXRpb25JZCd9KTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsQ291bnQobGlzdGVuZXIub25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkLCAyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I3N5bmNocm9uaXplfVxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgc3luY2hyb25pemUgd2l0aCBNZXRhVHJhZGVyIHRlcm1pbmFsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHJlcXVlc3RSZWNlaXZlZCA9IGZhbHNlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgICBpZiAoZGF0YS50eXBlID09PSAnc3luY2hyb25pemUnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJlxuICAgICAgICAgIGRhdGEuaG9zdCA9PT0gJ3BzLW1wYS0xJyAmJlxuICAgICAgICAgIGRhdGEuc3RhcnRpbmdIaXN0b3J5T3JkZXJUaW1lID09PSAnMjAyMC0wMS0wMVQwMDowMDowMC4wMDBaJyAmJlxuICAgICAgICAgIGRhdGEuc3RhcnRpbmdEZWFsVGltZSA9PT0gJzIwMjAtMDEtMDJUMDA6MDA6MDAuMDAwWicgJiYgZGF0YS5yZXF1ZXN0SWQgPT09ICdzeW5jaHJvbml6YXRpb25JZCcgJiZcbiAgICAgICAgICBkYXRhLmFwcGxpY2F0aW9uID09PSAnYXBwbGljYXRpb24nICYmIGRhdGEuaW5zdGFuY2VJbmRleCA9PT0gMSkge1xuICAgICAgICAgIHJlcXVlc3RSZWNlaXZlZCA9IHRydWU7XG4gICAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge3R5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWR9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhd2FpdCBjbGllbnQuc3luY2hyb25pemUoJ2FjY291bnRJZCcsIDEsICdwcy1tcGEtMScsICdzeW5jaHJvbml6YXRpb25JZCcsIG5ldyBEYXRlKCcyMDIwLTAxLTAxVDAwOjAwOjAwLjAwMFonKSxcbiAgICAgICAgbmV3IERhdGUoJzIwMjAtMDEtMDJUMDA6MDA6MDAuMDAwWicpKTtcbiAgICAgIHJlcXVlc3RSZWNlaXZlZC5zaG91bGQuYmUudHJ1ZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBwcm9jZXNzIHN5bmNocm9uaXphdGlvbiBzdGFydGVkIGV2ZW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IGxpc3RlbmVyID0ge1xuICAgICAgICBvblN5bmNocm9uaXphdGlvblN0YXJ0ZWQ6ICgpID0+IHtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uU3luY2hyb25pemF0aW9uU3RhcnRlZCcpLnJlc29sdmVzKCk7XG4gICAgICBjbGllbnQuYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIoJ2FjY291bnRJZCcsIGxpc3RlbmVyKTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ3N5bmNocm9uaXphdGlvblN0YXJ0ZWQnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBpbnN0YW5jZUluZGV4OiAxLFxuICAgICAgICBob3N0OiAncHMtbXBhLTEnfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChsaXN0ZW5lci5vblN5bmNocm9uaXphdGlvblN0YXJ0ZWQsICcxOnBzLW1wYS0xJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHN5bmNocm9uaXplIGFjY291bnQgaW5mb3JtYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgYWNjb3VudEluZm9ybWF0aW9uID0ge1xuICAgICAgICBicm9rZXI6ICdUcnVlIEVDTiBUcmFkaW5nIEx0ZCcsXG4gICAgICAgIGN1cnJlbmN5OiAnVVNEJyxcbiAgICAgICAgc2VydmVyOiAnSUNNYXJrZXRzU0MtRGVtbycsXG4gICAgICAgIGJhbGFuY2U6IDczMTkuOSxcbiAgICAgICAgZXF1aXR5OiA3MzA2LjY0OTkxMzIwMDAwMSxcbiAgICAgICAgbWFyZ2luOiAxODQuMSxcbiAgICAgICAgZnJlZU1hcmdpbjogNzEyMC4yMixcbiAgICAgICAgbGV2ZXJhZ2U6IDEwMCxcbiAgICAgICAgbWFyZ2luTGV2ZWw6IDM5NjcuNTgyODM1NDJcbiAgICAgIH07XG4gICAgICBsZXQgbGlzdGVuZXIgPSB7XG4gICAgICAgIG9uQWNjb3VudEluZm9ybWF0aW9uVXBkYXRlZDogKCkgPT4ge1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2FuZGJveC5zdHViKGxpc3RlbmVyLCAnb25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkJykucmVzb2x2ZXMoKTtcbiAgICAgIGNsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcignYWNjb3VudElkJywgbGlzdGVuZXIpO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnYWNjb3VudEluZm9ybWF0aW9uJywgYWNjb3VudElkOiAnYWNjb3VudElkJyxcbiAgICAgICAgaG9zdDogJ3BzLW1wYS0xJywgYWNjb3VudEluZm9ybWF0aW9uLCBpbnN0YW5jZUluZGV4OiAxfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChsaXN0ZW5lci5vbkFjY291bnRJbmZvcm1hdGlvblVwZGF0ZWQsICcxOnBzLW1wYS0xJywgYWNjb3VudEluZm9ybWF0aW9uKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc3luY2hyb25pemUgcG9zaXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHBvc2l0aW9ucyA9IFt7XG4gICAgICAgIGlkOiAnNDYyMTQ2OTInLFxuICAgICAgICB0eXBlOiAnUE9TSVRJT05fVFlQRV9CVVknLFxuICAgICAgICBzeW1ib2w6ICdHQlBVU0QnLFxuICAgICAgICBtYWdpYzogMTAwMCxcbiAgICAgICAgdGltZTogbmV3IERhdGUoJzIwMjAtMDQtMTVUMDI6NDU6MDYuNTIxWicpLFxuICAgICAgICB1cGRhdGVUaW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0xNVQwMjo0NTowNi41MjFaJyksXG4gICAgICAgIG9wZW5QcmljZTogMS4yNjEwMSxcbiAgICAgICAgY3VycmVudFByaWNlOiAxLjI0ODgzLFxuICAgICAgICBjdXJyZW50VGlja1ZhbHVlOiAxLFxuICAgICAgICB2b2x1bWU6IDAuMDcsXG4gICAgICAgIHN3YXA6IDAsXG4gICAgICAgIHByb2ZpdDogLTg1LjI1OTk5OTk5OTk5OTY2LFxuICAgICAgICBjb21taXNzaW9uOiAtMC4yNSxcbiAgICAgICAgY2xpZW50SWQ6ICdURV9HQlBVU0RfN2h5SU5XcUFsRScsXG4gICAgICAgIHN0b3BMb3NzOiAxLjE3NzIxLFxuICAgICAgICB1bnJlYWxpemVkUHJvZml0OiAtODUuMjU5OTk5OTk5OTk5MDEsXG4gICAgICAgIHJlYWxpemVkUHJvZml0OiAtNi41MzY5OTMxNjg5OTI5MjJlLTEzXG4gICAgICB9XTtcbiAgICAgIGxldCBsaXN0ZW5lciA9IHtcbiAgICAgICAgb25Qb3NpdGlvbnNSZXBsYWNlZDogKCkgPT4ge1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2FuZGJveC5zdHViKGxpc3RlbmVyLCAnb25Qb3NpdGlvbnNSZXBsYWNlZCcpLnJlc29sdmVzKCk7XG4gICAgICBjbGllbnQuYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIoJ2FjY291bnRJZCcsIGxpc3RlbmVyKTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ3Bvc2l0aW9ucycsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIHBvc2l0aW9ucywgaW5zdGFuY2VJbmRleDogMSxcbiAgICAgICAgaG9zdDogJ3BzLW1wYS0xJ30pO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25Qb3NpdGlvbnNSZXBsYWNlZCwgJzE6cHMtbXBhLTEnLCBwb3NpdGlvbnMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzeW5jaHJvbml6ZSBvcmRlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgb3JkZXJzID0gW3tcbiAgICAgICAgaWQ6ICc0Njg3MTI4NCcsXG4gICAgICAgIHR5cGU6ICdPUkRFUl9UWVBFX0JVWV9MSU1JVCcsXG4gICAgICAgIHN0YXRlOiAnT1JERVJfU1RBVEVfUExBQ0VEJyxcbiAgICAgICAgc3ltYm9sOiAnQVVETlpEJyxcbiAgICAgICAgbWFnaWM6IDEyMzQ1NixcbiAgICAgICAgcGxhdGZvcm06ICdtdDUnLFxuICAgICAgICB0aW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0yMFQwODozODo1OC4yNzBaJyksXG4gICAgICAgIG9wZW5QcmljZTogMS4wMyxcbiAgICAgICAgY3VycmVudFByaWNlOiAxLjA1MjA2LFxuICAgICAgICB2b2x1bWU6IDAuMDEsXG4gICAgICAgIGN1cnJlbnRWb2x1bWU6IDAuMDEsXG4gICAgICAgIGNvbW1lbnQ6ICdDT01NRU5UMidcbiAgICAgIH1dO1xuICAgICAgbGV0IGxpc3RlbmVyID0ge1xuICAgICAgICBvbk9yZGVyc1JlcGxhY2VkOiAoKSA9PiB7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvbk9yZGVyc1JlcGxhY2VkJykucmVzb2x2ZXMoKTtcbiAgICAgIGNsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcignYWNjb3VudElkJywgbGlzdGVuZXIpO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnb3JkZXJzJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgb3JkZXJzLCBpbnN0YW5jZUluZGV4OiAxLFxuICAgICAgICBob3N0OiAncHMtbXBhLTEnfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChsaXN0ZW5lci5vbk9yZGVyc1JlcGxhY2VkLCAnMTpwcy1tcGEtMScsIG9yZGVycyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHN5bmNocm9uaXplIGhpc3Rvcnkgb3JkZXJzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IGhpc3RvcnlPcmRlcnMgPSBbe1xuICAgICAgICBjbGllbnRJZDogJ1RFX0dCUFVTRF83aHlJTldxQWxFJyxcbiAgICAgICAgY3VycmVudFByaWNlOiAxLjI2MSxcbiAgICAgICAgY3VycmVudFZvbHVtZTogMCxcbiAgICAgICAgZG9uZVRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTE1VDAyOjQ1OjA2LjUyMVonKSxcbiAgICAgICAgaWQ6ICc0NjIxNDY5MicsXG4gICAgICAgIG1hZ2ljOiAxMDAwLFxuICAgICAgICBwbGF0Zm9ybTogJ210NScsXG4gICAgICAgIHBvc2l0aW9uSWQ6ICc0NjIxNDY5MicsXG4gICAgICAgIHN0YXRlOiAnT1JERVJfU1RBVEVfRklMTEVEJyxcbiAgICAgICAgc3ltYm9sOiAnR0JQVVNEJyxcbiAgICAgICAgdGltZTogbmV3IERhdGUoJzIwMjAtMDQtMTVUMDI6NDU6MDYuMjYwWicpLFxuICAgICAgICB0eXBlOiAnT1JERVJfVFlQRV9CVVknLFxuICAgICAgICB2b2x1bWU6IDAuMDdcbiAgICAgIH1dO1xuICAgICAgbGV0IGxpc3RlbmVyID0ge1xuICAgICAgICBvbkhpc3RvcnlPcmRlckFkZGVkOiAoKSA9PiB7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvbkhpc3RvcnlPcmRlckFkZGVkJykucmVzb2x2ZXMoKTtcbiAgICAgIGNsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcignYWNjb3VudElkJywgbGlzdGVuZXIpO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnaGlzdG9yeU9yZGVycycsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhpc3RvcnlPcmRlcnMsXG4gICAgICAgIGluc3RhbmNlSW5kZXg6IDEsIGhvc3Q6ICdwcy1tcGEtMSd9KTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKGxpc3RlbmVyLm9uSGlzdG9yeU9yZGVyQWRkZWQsICcxOnBzLW1wYS0xJywgaGlzdG9yeU9yZGVyc1swXSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHN5bmNocm9uaXplIGRlYWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IGRlYWxzID0gW3tcbiAgICAgICAgY2xpZW50SWQ6ICdURV9HQlBVU0RfN2h5SU5XcUFsRScsXG4gICAgICAgIGNvbW1pc3Npb246IC0wLjI1LFxuICAgICAgICBlbnRyeVR5cGU6ICdERUFMX0VOVFJZX0lOJyxcbiAgICAgICAgaWQ6ICczMzIzMDA5OScsXG4gICAgICAgIG1hZ2ljOiAxMDAwLFxuICAgICAgICBwbGF0Zm9ybTogJ210NScsXG4gICAgICAgIG9yZGVySWQ6ICc0NjIxNDY5MicsXG4gICAgICAgIHBvc2l0aW9uSWQ6ICc0NjIxNDY5MicsXG4gICAgICAgIHByaWNlOiAxLjI2MTAxLFxuICAgICAgICBwcm9maXQ6IDAsXG4gICAgICAgIHN3YXA6IDAsXG4gICAgICAgIHN5bWJvbDogJ0dCUFVTRCcsXG4gICAgICAgIHRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTE1VDAyOjQ1OjA2LjUyMVonKSxcbiAgICAgICAgdHlwZTogJ0RFQUxfVFlQRV9CVVknLFxuICAgICAgICB2b2x1bWU6IDAuMDdcbiAgICAgIH1dO1xuICAgICAgbGV0IGxpc3RlbmVyID0ge1xuICAgICAgICBvbkRlYWxBZGRlZDogKCkgPT4ge1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2FuZGJveC5zdHViKGxpc3RlbmVyLCAnb25EZWFsQWRkZWQnKS5yZXNvbHZlcygpO1xuICAgICAgY2xpZW50LmFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKCdhY2NvdW50SWQnLCBsaXN0ZW5lcik7XG4gICAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdkZWFscycsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGRlYWxzLCBpbnN0YW5jZUluZGV4OiAxLFxuICAgICAgICBob3N0OiAncHMtbXBhLTEnfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChsaXN0ZW5lci5vbkRlYWxBZGRlZCwgJzE6cHMtbXBhLTEnLCBkZWFsc1swXSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHByb2Nlc3Mgc3luY2hyb25pemF0aW9uIHVwZGF0ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgdXBkYXRlID0ge1xuICAgICAgICBhY2NvdW50SW5mb3JtYXRpb246IHtcbiAgICAgICAgICBicm9rZXI6ICdUcnVlIEVDTiBUcmFkaW5nIEx0ZCcsXG4gICAgICAgICAgY3VycmVuY3k6ICdVU0QnLFxuICAgICAgICAgIHNlcnZlcjogJ0lDTWFya2V0c1NDLURlbW8nLFxuICAgICAgICAgIGJhbGFuY2U6IDczMTkuOSxcbiAgICAgICAgICBlcXVpdHk6IDczMDYuNjQ5OTEzMjAwMDAxLFxuICAgICAgICAgIG1hcmdpbjogMTg0LjEsXG4gICAgICAgICAgZnJlZU1hcmdpbjogNzEyMC4yMixcbiAgICAgICAgICBsZXZlcmFnZTogMTAwLFxuICAgICAgICAgIG1hcmdpbkxldmVsOiAzOTY3LjU4MjgzNTQyXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZWRQb3NpdGlvbnM6IFt7XG4gICAgICAgICAgaWQ6ICc0NjIxNDY5MicsXG4gICAgICAgICAgdHlwZTogJ1BPU0lUSU9OX1RZUEVfQlVZJyxcbiAgICAgICAgICBzeW1ib2w6ICdHQlBVU0QnLFxuICAgICAgICAgIG1hZ2ljOiAxMDAwLFxuICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTE1VDAyOjQ1OjA2LjUyMVonKSxcbiAgICAgICAgICB1cGRhdGVUaW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0xNVQwMjo0NTowNi41MjFaJyksXG4gICAgICAgICAgb3BlblByaWNlOiAxLjI2MTAxLFxuICAgICAgICAgIGN1cnJlbnRQcmljZTogMS4yNDg4MyxcbiAgICAgICAgICBjdXJyZW50VGlja1ZhbHVlOiAxLFxuICAgICAgICAgIHZvbHVtZTogMC4wNyxcbiAgICAgICAgICBzd2FwOiAwLFxuICAgICAgICAgIHByb2ZpdDogLTg1LjI1OTk5OTk5OTk5OTY2LFxuICAgICAgICAgIGNvbW1pc3Npb246IC0wLjI1LFxuICAgICAgICAgIGNsaWVudElkOiAnVEVfR0JQVVNEXzdoeUlOV3FBbEUnLFxuICAgICAgICAgIHN0b3BMb3NzOiAxLjE3NzIxLFxuICAgICAgICAgIHVucmVhbGl6ZWRQcm9maXQ6IC04NS4yNTk5OTk5OTk5OTkwMSxcbiAgICAgICAgICByZWFsaXplZFByb2ZpdDogLTYuNTM2OTkzMTY4OTkyOTIyZS0xM1xuICAgICAgICB9XSxcbiAgICAgICAgcmVtb3ZlZFBvc2l0aW9uSWRzOiBbJzEyMzQnXSxcbiAgICAgICAgdXBkYXRlZE9yZGVyczogW3tcbiAgICAgICAgICBpZDogJzQ2ODcxMjg0JyxcbiAgICAgICAgICB0eXBlOiAnT1JERVJfVFlQRV9CVVlfTElNSVQnLFxuICAgICAgICAgIHN0YXRlOiAnT1JERVJfU1RBVEVfUExBQ0VEJyxcbiAgICAgICAgICBzeW1ib2w6ICdBVUROWkQnLFxuICAgICAgICAgIG1hZ2ljOiAxMjM0NTYsXG4gICAgICAgICAgcGxhdGZvcm06ICdtdDUnLFxuICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTIwVDA4OjM4OjU4LjI3MFonKSxcbiAgICAgICAgICBvcGVuUHJpY2U6IDEuMDMsXG4gICAgICAgICAgY3VycmVudFByaWNlOiAxLjA1MjA2LFxuICAgICAgICAgIHZvbHVtZTogMC4wMSxcbiAgICAgICAgICBjdXJyZW50Vm9sdW1lOiAwLjAxLFxuICAgICAgICAgIGNvbW1lbnQ6ICdDT01NRU5UMidcbiAgICAgICAgfV0sXG4gICAgICAgIGNvbXBsZXRlZE9yZGVySWRzOiBbJzIzNDUnXSxcbiAgICAgICAgaGlzdG9yeU9yZGVyczogW3tcbiAgICAgICAgICBjbGllbnRJZDogJ1RFX0dCUFVTRF83aHlJTldxQWxFJyxcbiAgICAgICAgICBjdXJyZW50UHJpY2U6IDEuMjYxLFxuICAgICAgICAgIGN1cnJlbnRWb2x1bWU6IDAsXG4gICAgICAgICAgZG9uZVRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTE1VDAyOjQ1OjA2LjUyMVonKSxcbiAgICAgICAgICBpZDogJzQ2MjE0NjkyJyxcbiAgICAgICAgICBtYWdpYzogMTAwMCxcbiAgICAgICAgICBwbGF0Zm9ybTogJ210NScsXG4gICAgICAgICAgcG9zaXRpb25JZDogJzQ2MjE0NjkyJyxcbiAgICAgICAgICBzdGF0ZTogJ09SREVSX1NUQVRFX0ZJTExFRCcsXG4gICAgICAgICAgc3ltYm9sOiAnR0JQVVNEJyxcbiAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0xNVQwMjo0NTowNi4yNjBaJyksXG4gICAgICAgICAgdHlwZTogJ09SREVSX1RZUEVfQlVZJyxcbiAgICAgICAgICB2b2x1bWU6IDAuMDdcbiAgICAgICAgfV0sXG4gICAgICAgIGRlYWxzOiBbe1xuICAgICAgICAgIGNsaWVudElkOiAnVEVfR0JQVVNEXzdoeUlOV3FBbEUnLFxuICAgICAgICAgIGNvbW1pc3Npb246IC0wLjI1LFxuICAgICAgICAgIGVudHJ5VHlwZTogJ0RFQUxfRU5UUllfSU4nLFxuICAgICAgICAgIGlkOiAnMzMyMzAwOTknLFxuICAgICAgICAgIG1hZ2ljOiAxMDAwLFxuICAgICAgICAgIHBsYXRmb3JtOiAnbXQ1JyxcbiAgICAgICAgICBvcmRlcklkOiAnNDYyMTQ2OTInLFxuICAgICAgICAgIHBvc2l0aW9uSWQ6ICc0NjIxNDY5MicsXG4gICAgICAgICAgcHJpY2U6IDEuMjYxMDEsXG4gICAgICAgICAgcHJvZml0OiAwLFxuICAgICAgICAgIHN3YXA6IDAsXG4gICAgICAgICAgc3ltYm9sOiAnR0JQVVNEJyxcbiAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0xNVQwMjo0NTowNi41MjFaJyksXG4gICAgICAgICAgdHlwZTogJ0RFQUxfVFlQRV9CVVknLFxuICAgICAgICAgIHZvbHVtZTogMC4wN1xuICAgICAgICB9XVxuICAgICAgfTtcbiAgICAgIGxldCBsaXN0ZW5lciA9IHtcbiAgICAgICAgb25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkOiAoKSA9PiB7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUG9zaXRpb25VcGRhdGVkOiAoKSA9PiB7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUG9zaXRpb25SZW1vdmVkOiAoKSA9PiB7XG4gICAgICAgIH0sXG4gICAgICAgIG9uT3JkZXJVcGRhdGVkOiAoKSA9PiB7XG4gICAgICAgIH0sXG4gICAgICAgIG9uT3JkZXJDb21wbGV0ZWQ6ICgpID0+IHtcbiAgICAgICAgfSxcbiAgICAgICAgb25IaXN0b3J5T3JkZXJBZGRlZDogKCkgPT4ge1xuICAgICAgICB9LFxuICAgICAgICBvbkRlYWxBZGRlZDogKCkgPT4ge1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2FuZGJveC5zdHViKGxpc3RlbmVyLCAnb25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkJykucmVzb2x2ZXMoKTtcbiAgICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uUG9zaXRpb25VcGRhdGVkJykucmVzb2x2ZXMoKTtcbiAgICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uUG9zaXRpb25SZW1vdmVkJykucmVzb2x2ZXMoKTtcbiAgICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uT3JkZXJVcGRhdGVkJykucmVzb2x2ZXMoKTtcbiAgICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uT3JkZXJDb21wbGV0ZWQnKS5yZXNvbHZlcygpO1xuICAgICAgc2FuZGJveC5zdHViKGxpc3RlbmVyLCAnb25IaXN0b3J5T3JkZXJBZGRlZCcpLnJlc29sdmVzKCk7XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvbkRlYWxBZGRlZCcpLnJlc29sdmVzKCk7XG4gICAgICBjbGllbnQuYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIoJ2FjY291bnRJZCcsIGxpc3RlbmVyKTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCBPYmplY3QuYXNzaWduKHt0eXBlOiAndXBkYXRlJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgaW5zdGFuY2VJbmRleDogMSxcbiAgICAgICAgaG9zdDogJ3BzLW1wYS0xJ30sIHVwZGF0ZSkpO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCAxMDApKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKGxpc3RlbmVyLm9uQWNjb3VudEluZm9ybWF0aW9uVXBkYXRlZCwgJzE6cHMtbXBhLTEnLCB1cGRhdGUuYWNjb3VudEluZm9ybWF0aW9uKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKGxpc3RlbmVyLm9uUG9zaXRpb25VcGRhdGVkLCAnMTpwcy1tcGEtMScsIHVwZGF0ZS51cGRhdGVkUG9zaXRpb25zWzBdKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKGxpc3RlbmVyLm9uUG9zaXRpb25SZW1vdmVkLCAnMTpwcy1tcGEtMScsIHVwZGF0ZS5yZW1vdmVkUG9zaXRpb25JZHNbMF0pO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25PcmRlclVwZGF0ZWQsICcxOnBzLW1wYS0xJywgdXBkYXRlLnVwZGF0ZWRPcmRlcnNbMF0pO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25PcmRlckNvbXBsZXRlZCwgJzE6cHMtbXBhLTEnLCB1cGRhdGUuY29tcGxldGVkT3JkZXJJZHNbMF0pO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25IaXN0b3J5T3JkZXJBZGRlZCwgJzE6cHMtbXBhLTEnLCB1cGRhdGUuaGlzdG9yeU9yZGVyc1swXSk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChsaXN0ZW5lci5vbkRlYWxBZGRlZCwgJzE6cHMtbXBhLTEnLCB1cGRhdGUuZGVhbHNbMF0pO1xuICAgIH0pO1xuXG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdtYXJrZXQgZGF0YSBzeW5jaHJvbml6YXRpb24nLCAoKSA9PiB7XG5cbiAgICBhZnRlckVhY2goKCkgPT4ge1xuICAgICAgY2xpZW50LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjX3JwY1JlcXVlc3R9XG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCByZXRyeSByZXF1ZXN0IG9uIGZhaWx1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgcmVxdWVzdENvdW50ZXIgPSAwO1xuICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICBpZDogJzQ2ODcxMjg0JyxcbiAgICAgICAgdHlwZTogJ09SREVSX1RZUEVfQlVZX0xJTUlUJyxcbiAgICAgICAgc3RhdGU6ICdPUkRFUl9TVEFURV9QTEFDRUQnLFxuICAgICAgICBzeW1ib2w6ICdBVUROWkQnLFxuICAgICAgICBtYWdpYzogMTIzNDU2LFxuICAgICAgICBwbGF0Zm9ybTogJ210NScsXG4gICAgICAgIHRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTIwVDA4OjM4OjU4LjI3MFonKSxcbiAgICAgICAgb3BlblByaWNlOiAxLjAzLFxuICAgICAgICBjdXJyZW50UHJpY2U6IDEuMDUyMDYsXG4gICAgICAgIHZvbHVtZTogMC4wMSxcbiAgICAgICAgY3VycmVudFZvbHVtZTogMC4wMSxcbiAgICAgICAgY29tbWVudDogJ0NPTU1FTlQyJ1xuICAgICAgfTtcbiAgICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgICBpZiAocmVxdWVzdENvdW50ZXIgPiAxICYmIGRhdGEudHlwZSA9PT0gJ2dldE9yZGVyJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiZcbiAgICAgICAgICBkYXRhLm9yZGVySWQgPT09ICc0Njg3MTI4NCcgJiYgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ1JQQycpIHtcbiAgICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCwgb3JkZXJ9KTtcbiAgICAgICAgfSBcbiAgICAgICAgcmVxdWVzdENvdW50ZXIrKztcbiAgICAgIH0pO1xuICAgICAgbGV0IGFjdHVhbCA9IGF3YWl0IGNsaWVudC5nZXRPcmRlcignYWNjb3VudElkJywgJzQ2ODcxMjg0Jyk7XG4gICAgICBhY3R1YWwuc2hvdWxkLm1hdGNoKG9yZGVyKTtcbiAgICB9KS50aW1lb3V0KDIwMDAwKTtcblxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I19ycGNSZXF1ZXN0fVxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgd2FpdCBzcGVjaWZpZWQgYW1vdW50IG9mIHRpbWUgb24gdG9vIG1hbnkgcmVxdWVzdHMgZXJyb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgcmVxdWVzdENvdW50ZXIgPSAwO1xuICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICBpZDogJzQ2ODcxMjg0JyxcbiAgICAgICAgdHlwZTogJ09SREVSX1RZUEVfQlVZX0xJTUlUJyxcbiAgICAgICAgc3RhdGU6ICdPUkRFUl9TVEFURV9QTEFDRUQnLFxuICAgICAgICBzeW1ib2w6ICdBVUROWkQnLFxuICAgICAgICBtYWdpYzogMTIzNDU2LFxuICAgICAgICBwbGF0Zm9ybTogJ210NScsXG4gICAgICAgIHRpbWU6IG5ldyBEYXRlKCcyMDIwLTA0LTIwVDA4OjM4OjU4LjI3MFonKSxcbiAgICAgICAgb3BlblByaWNlOiAxLjAzLFxuICAgICAgICBjdXJyZW50UHJpY2U6IDEuMDUyMDYsXG4gICAgICAgIHZvbHVtZTogMC4wMSxcbiAgICAgICAgY3VycmVudFZvbHVtZTogMC4wMSxcbiAgICAgICAgY29tbWVudDogJ0NPTU1FTlQyJ1xuICAgICAgfTtcbiAgICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgICBpZiAocmVxdWVzdENvdW50ZXIgPiAwICYmIGRhdGEudHlwZSA9PT0gJ2dldE9yZGVyJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiZcbiAgICAgICAgICBkYXRhLm9yZGVySWQgPT09ICc0Njg3MTI4NCcgJiYgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ1JQQycpIHtcbiAgICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCwgb3JkZXJ9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXJ2ZXIuZW1pdCgncHJvY2Vzc2luZ0Vycm9yJywge1xuICAgICAgICAgICAgaWQ6IDEsIGVycm9yOiAnVG9vTWFueVJlcXVlc3RzRXJyb3InLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLFxuICAgICAgICAgICAgbWVzc2FnZTogJ1RoZSBBUEkgYWxsb3dzIDEwMDAwIHJlcXVlc3RzIHBlciA2MCBtaW51dGVzIHRvIGF2b2lkIG92ZXJsb2FkaW5nIG91ciBzZXJ2ZXJzLicsXG4gICAgICAgICAgICBzdGF0dXNfY29kZTogNDI5LCBtZXRhZGF0YToge1xuICAgICAgICAgICAgICBwZXJpb2RJbk1pbnV0ZXM6IDYwLCBtYXhSZXF1ZXN0c0ZvclBlcmlvZDogMTAwMDAsIFxuICAgICAgICAgICAgICByZWNvbW1lbmRlZFJldHJ5VGltZTogbmV3IERhdGUoRGF0ZS5ub3coKSArIDEwMDApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdENvdW50ZXIrKztcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGxldCBhY3R1YWwgPSBhd2FpdCBjbGllbnQuZ2V0T3JkZXIoJ2FjY291bnRJZCcsICc0Njg3MTI4NCcpO1xuICAgICAgYWN0dWFsLnNob3VsZC5tYXRjaChvcmRlcik7XG4gICAgICAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSkuc2hvdWxkLmJlLmFwcHJveGltYXRlbHkoMTAwMCwgMTAwKTtcbiAgICB9KS50aW1lb3V0KDEwMDAwKTtcblxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I19ycGNSZXF1ZXN0fVxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIHRvbyBtYW55IHJlcXVlc3RzIGV4Y2VwdGlvbiBpZiByZWNvbW1lbmRlZCB0aW1lIGlzIGJleW9uZCBtYXggcmVxdWVzdCB0aW1lJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHJlcXVlc3RDb3VudGVyID0gMDtcbiAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgaWQ6ICc0Njg3MTI4NCcsXG4gICAgICAgIHR5cGU6ICdPUkRFUl9UWVBFX0JVWV9MSU1JVCcsXG4gICAgICAgIHN0YXRlOiAnT1JERVJfU1RBVEVfUExBQ0VEJyxcbiAgICAgICAgc3ltYm9sOiAnQVVETlpEJyxcbiAgICAgICAgbWFnaWM6IDEyMzQ1NixcbiAgICAgICAgcGxhdGZvcm06ICdtdDUnLFxuICAgICAgICB0aW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0yMFQwODozODo1OC4yNzBaJyksXG4gICAgICAgIG9wZW5QcmljZTogMS4wMyxcbiAgICAgICAgY3VycmVudFByaWNlOiAxLjA1MjA2LFxuICAgICAgICB2b2x1bWU6IDAuMDEsXG4gICAgICAgIGN1cnJlbnRWb2x1bWU6IDAuMDEsXG4gICAgICAgIGNvbW1lbnQ6ICdDT01NRU5UMidcbiAgICAgIH07XG4gICAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgICAgaWYgKHJlcXVlc3RDb3VudGVyID4gMCAmJiBkYXRhLnR5cGUgPT09ICdnZXRPcmRlcicgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnICYmXG4gICAgICAgICAgICAgIGRhdGEub3JkZXJJZCA9PT0gJzQ2ODcxMjg0JyAmJiBkYXRhLmFwcGxpY2F0aW9uID09PSAnUlBDJykge1xuICAgICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLCBvcmRlcn0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlcnZlci5lbWl0KCdwcm9jZXNzaW5nRXJyb3InLCB7XG4gICAgICAgICAgICBpZDogMSwgZXJyb3I6ICdUb29NYW55UmVxdWVzdHNFcnJvcicsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWQsXG4gICAgICAgICAgICBtZXNzYWdlOiAnVGhlIEFQSSBhbGxvd3MgMTAwMDAgcmVxdWVzdHMgcGVyIDYwIG1pbnV0ZXMgdG8gYXZvaWQgb3ZlcmxvYWRpbmcgb3VyIHNlcnZlcnMuJyxcbiAgICAgICAgICAgIHN0YXR1c19jb2RlOiA0MjksIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgIHBlcmlvZEluTWludXRlczogNjAsIG1heFJlcXVlc3RzRm9yUGVyaW9kOiAxMDAwMCwgXG4gICAgICAgICAgICAgIHJlY29tbWVuZGVkUmV0cnlUaW1lOiBuZXcgRGF0ZShEYXRlLm5vdygpICsgNjAwMDApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdENvdW50ZXIrKztcbiAgICAgIH0pO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBjbGllbnQuZ2V0T3JkZXIoJ2FjY291bnRJZCcsICc0Njg3MTI4NCcpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rvb01hbnlSZXF1ZXN0c0Vycm9yIGV4cGVjdGVkJyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyLm5hbWUuc2hvdWxkLmVxdWFsKCdUb29NYW55UmVxdWVzdHNFcnJvcicpO1xuICAgICAgfVxuICAgIH0pLnRpbWVvdXQoMTAwMDApOyAgICBcblxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I19ycGNSZXF1ZXN0fVxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgbm90IHJldHJ5IHJlcXVlc3Qgb24gdmFsaWRhdGlvbiBlcnJvcicsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCByZXF1ZXN0Q291bnRlciA9IDA7XG4gICAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgICAgaWYgKHJlcXVlc3RDb3VudGVyID4gMCAmJiBkYXRhLnR5cGUgPT09ICdzdWJzY3JpYmVUb01hcmtldERhdGEnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJlxuICAgICAgICAgIGRhdGEuc3ltYm9sID09PSAnRVVSVVNEJyAmJiBkYXRhLmFwcGxpY2F0aW9uID09PSAnYXBwbGljYXRpb24nICYmIGRhdGEuaW5zdGFuY2VJbmRleCA9PT0gMSkge1xuICAgICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VydmVyLmVtaXQoJ3Byb2Nlc3NpbmdFcnJvcicsIHtcbiAgICAgICAgICAgIGlkOiAxLCBlcnJvcjogJ1ZhbGlkYXRpb25FcnJvcicsIG1lc3NhZ2U6ICdFcnJvciBtZXNzYWdlJywgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RDb3VudGVyICsrO1xuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBjbGllbnQuc3Vic2NyaWJlVG9NYXJrZXREYXRhKCdhY2NvdW50SWQnLCAxLCAnRVVSVVNEJyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsaWRhdGlvbkVycm9yIGV4cGVjdGVkJyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyLm5hbWUuc2hvdWxkLmVxdWFsKCdWYWxpZGF0aW9uRXJyb3InKTtcbiAgICAgIH1cbiAgICAgIHNpbm9uLmFzc2VydC5tYXRjaChyZXF1ZXN0Q291bnRlciwgMSk7XG4gICAgfSkudGltZW91dCg2MDAwKTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNfcnBjUmVxdWVzdH1cbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIG5vdCByZXRyeSB0cmFkZSByZXF1ZXN0cyBvbiBmYWlsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHJlcXVlc3RDb3VudGVyID0gMDtcbiAgICAgIGxldCB0cmFkZSA9IHtcbiAgICAgICAgYWN0aW9uVHlwZTogJ09SREVSX1RZUEVfU0VMTCcsXG4gICAgICAgIHN5bWJvbDogJ0FVRE5aRCcsXG4gICAgICAgIHZvbHVtZTogMC4wN1xuICAgICAgfTtcbiAgICAgIHNlcnZlci5vbigncmVxdWVzdCcsIGRhdGEgPT4ge1xuICAgICAgICBpZiAoZGF0YS50eXBlID09PSAndHJhZGUnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLmFwcGxpY2F0aW9uID09PSAnYXBwbGljYXRpb24nKSB7XG4gICAgICAgICAgaWYocmVxdWVzdENvdW50ZXIgPiAwKSB7XG4gICAgICAgICAgICBzaW5vbi5hc3NlcnQuZmFpbCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXF1ZXN0Q291bnRlcisrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGNsaWVudC50cmFkZSh0cmFkZSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGltZW91dEVycm9yIGV4cGVjdGVkJyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyLm5hbWUuc2hvdWxkLmVxdWFsKCdUaW1lb3V0RXJyb3InKTtcbiAgICAgIH1cbiAgICB9KS50aW1lb3V0KDYwMDApO1xuXG4gICAgLyoqXG4gICAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjX3JwY1JlcXVlc3R9XG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBub3QgcmV0cnkgcmVxdWVzdCBpZiBjb25uZWN0aW9uIGNsb3NlZCBiZXR3ZWVuIHJldHJpZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgcmVxdWVzdENvdW50ZXIgPSAwO1xuICAgICAgbGV0IHJlc3BvbnNlID0ge3R5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogJ2FjY291bnRJZCd9O1xuICAgICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgYXN5bmMgZGF0YSA9PiB7XG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICd1bnN1YnNjcmliZScgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnKSB7XG4gICAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywgT2JqZWN0LmFzc2lnbih7cmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZH0sIHJlc3BvbnNlKSk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdnZXRPcmRlcnMnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLmFwcGxpY2F0aW9uID09PSAnUlBDJykge1xuICAgICAgICAgIHJlcXVlc3RDb3VudGVyKys7XG4gICAgICAgICAgc2VydmVyLmVtaXQoJ3Byb2Nlc3NpbmdFcnJvcicsIHtcbiAgICAgICAgICAgIGlkOiAxLCBlcnJvcjogJ05vdFN5bmNocm9uaXplZEVycm9yJywgbWVzc2FnZTogJ0Vycm9yIG1lc3NhZ2UnLFxuICAgICAgICAgICAgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNsaWVudC51bnN1YnNjcmliZSgnYWNjb3VudElkJyk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBjbGllbnQuZ2V0T3JkZXJzKCdhY2NvdW50SWQnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3RTeW5jaHJvbml6ZWRFcnJvciBleHBlY3RlZCcpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVyci5uYW1lLnNob3VsZC5lcXVhbCgnTm90U3luY2hyb25pemVkRXJyb3InKTtcbiAgICAgIH1cbiAgICAgIHJlcXVlc3RDb3VudGVyLnNob3VsZC5lcXVhbCgxKTtcbiAgICAgIGNsaWVudC5zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzLnNob3VsZC5ub3QuaGF2ZS5wcm9wZXJ0eSgnYWNjb3VudElkJyk7XG4gICAgfSk7XG4gIFxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I19ycGNSZXF1ZXN0fVxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIHRpbWVvdXQgZXJyb3IgaWYgbm8gc2VydmVyIHJlc3BvbnNlIHJlY2VpdmVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHRyYWRlID0ge1xuICAgICAgICBhY3Rpb25UeXBlOiAnT1JERVJfVFlQRV9TRUxMJyxcbiAgICAgICAgc3ltYm9sOiAnQVVETlpEJyxcbiAgICAgICAgdm9sdW1lOiAwLjA3XG4gICAgICB9O1xuICAgICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGNsaWVudC50cmFkZSh0cmFkZSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGltZW91dEVycm9yIGV4dGVjdGVkJyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyLm5hbWUuc2hvdWxkLmVxdWFsKCdUaW1lb3V0RXJyb3InKTtcbiAgICAgIH1cbiAgICB9KS50aW1lb3V0KDIwMDAwKTtcblxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I3N1YnNjcmliZVRvTWFya2V0RGF0YX1cbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIHN1YnNjcmliZSB0byBtYXJrZXQgZGF0YSB3aXRoIE1ldGFUcmFkZXIgdGVybWluYWwnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgcmVxdWVzdFJlY2VpdmVkID0gZmFsc2U7XG4gICAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ3N1YnNjcmliZVRvTWFya2V0RGF0YScgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnICYmIGRhdGEuc3ltYm9sID09PSAnRVVSVVNEJyAmJlxuICAgICAgICAgIGRhdGEuYXBwbGljYXRpb24gPT09ICdhcHBsaWNhdGlvbicgJiYgZGF0YS5pbnN0YW5jZUluZGV4ID09PSAxICYmXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkoZGF0YS5zdWJzY3JpcHRpb25zKSA9PT0gSlNPTi5zdHJpbmdpZnkoW3t0eXBlOiAncXVvdGVzJ31dKSkge1xuICAgICAgICAgIHJlcXVlc3RSZWNlaXZlZCA9IHRydWU7XG4gICAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge3R5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWR9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhd2FpdCBjbGllbnQuc3Vic2NyaWJlVG9NYXJrZXREYXRhKCdhY2NvdW50SWQnLCAxLCAnRVVSVVNEJywgW3t0eXBlOiAncXVvdGVzJ31dKTtcbiAgICAgIHJlcXVlc3RSZWNlaXZlZC5zaG91bGQuYmUudHJ1ZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHRlc3Qge01ldGFBcGlXZWJzb2NrZXRDbGllbnQjdW5zdWJzY3JpYmVGcm9tTWFya2V0RGF0YX1cbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIHVuc3Vic2NyaWJlIGZyb20gbWFya2V0IGRhdGEgd2l0aCBNZXRhVHJhZGVyIHRlcm1pbmFsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHJlcXVlc3RSZWNlaXZlZCA9IGZhbHNlO1xuICAgICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICd1bnN1YnNjcmliZUZyb21NYXJrZXREYXRhJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgZGF0YS5zeW1ib2wgPT09ICdFVVJVU0QnICYmXG4gICAgICAgICAgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ2FwcGxpY2F0aW9uJyAmJiBkYXRhLmluc3RhbmNlSW5kZXggPT09IDEgJiZcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShkYXRhLnN1YnNjcmlwdGlvbnMpID09PSBKU09OLnN0cmluZ2lmeShbe3R5cGU6ICdxdW90ZXMnfV0pKSB7XG4gICAgICAgICAgcmVxdWVzdFJlY2VpdmVkID0gdHJ1ZTtcbiAgICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGF3YWl0IGNsaWVudC51bnN1YnNjcmliZUZyb21NYXJrZXREYXRhKCdhY2NvdW50SWQnLCAxLCAnRVVSVVNEJywgW3t0eXBlOiAncXVvdGVzJ31dKTtcbiAgICAgIHJlcXVlc3RSZWNlaXZlZC5zaG91bGQuYmUudHJ1ZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzeW5jaHJvbml6ZSBzeW1ib2wgc3BlY2lmaWNhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgc3BlY2lmaWNhdGlvbnMgPSBbe1xuICAgICAgICBzeW1ib2w6ICdFVVJVU0QnLFxuICAgICAgICB0aWNrU2l6ZTogMC4wMDAwMSxcbiAgICAgICAgbWluVm9sdW1lOiAwLjAxLFxuICAgICAgICBtYXhWb2x1bWU6IDIwMCxcbiAgICAgICAgdm9sdW1lU3RlcDogMC4wMVxuICAgICAgfV07XG4gICAgICBsZXQgbGlzdGVuZXIgPSB7XG4gICAgICAgIG9uU3ltYm9sU3BlY2lmaWNhdGlvbnNVcGRhdGVkOiAoKSA9PiB7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3ltYm9sU3BlY2lmaWNhdGlvblVwZGF0ZWQ6ICgpID0+IHtcbiAgICAgICAgfSxcbiAgICAgICAgb25TeW1ib2xTcGVjaWZpY2F0aW9uUmVtb3ZlZDogKCkgPT4ge1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2FuZGJveC5zdHViKGxpc3RlbmVyLCAnb25TeW1ib2xTcGVjaWZpY2F0aW9uc1VwZGF0ZWQnKS5yZXNvbHZlcygpO1xuICAgICAgc2FuZGJveC5zdHViKGxpc3RlbmVyLCAnb25TeW1ib2xTcGVjaWZpY2F0aW9uVXBkYXRlZCcpLnJlc29sdmVzKCk7XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvblN5bWJvbFNwZWNpZmljYXRpb25SZW1vdmVkJykucmVzb2x2ZXMoKTtcbiAgICAgIGNsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcignYWNjb3VudElkJywgbGlzdGVuZXIpO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsXG4gICAgICAgIHt0eXBlOiAnc3BlY2lmaWNhdGlvbnMnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBzcGVjaWZpY2F0aW9ucywgaW5zdGFuY2VJbmRleDogMSwgaG9zdDogJ3BzLW1wYS0xJyxcbiAgICAgICAgICByZW1vdmVkU3ltYm9sczogWydBVUROWkQnXX0pO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25TeW1ib2xTcGVjaWZpY2F0aW9uc1VwZGF0ZWQsICcxOnBzLW1wYS0xJywgc3BlY2lmaWNhdGlvbnMsIFsnQVVETlpEJ10pO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25TeW1ib2xTcGVjaWZpY2F0aW9uVXBkYXRlZCwgJzE6cHMtbXBhLTEnLCBzcGVjaWZpY2F0aW9uc1swXSk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChsaXN0ZW5lci5vblN5bWJvbFNwZWNpZmljYXRpb25SZW1vdmVkLCAnMTpwcy1tcGEtMScsICdBVUROWkQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc3luY2hyb25pemUgc3ltYm9sIHByaWNlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBwcmljZXMgPSBbe1xuICAgICAgICBzeW1ib2w6ICdBVUROWkQnLFxuICAgICAgICBiaWQ6IDEuMDU5MTYsXG4gICAgICAgIGFzazogMS4wNTkyNyxcbiAgICAgICAgcHJvZml0VGlja1ZhbHVlOiAwLjYwMixcbiAgICAgICAgbG9zc1RpY2tWYWx1ZTogMC42MDIwM1xuICAgICAgfV07XG4gICAgICBsZXQgdGlja3MgPSBbe1xuICAgICAgICBzeW1ib2w6ICdBVUROWkQnLFxuICAgICAgICB0aW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0wN1QwMzo0NTowMC4wMDBaJyksXG4gICAgICAgIGJyb2tlclRpbWU6ICcyMDIwLTA0LTA3IDA2OjQ1OjAwLjAwMCcsXG4gICAgICAgIGJpZDogMS4wNTI5NyxcbiAgICAgICAgYXNrOiAxLjA1MzA5LFxuICAgICAgICBsYXN0OiAwLjUyOTgsXG4gICAgICAgIHZvbHVtZTogMC4xMyxcbiAgICAgICAgc2lkZTogJ2J1eSdcbiAgICAgIH1dO1xuICAgICAgbGV0IGNhbmRsZXMgPSBbe1xuICAgICAgICBzeW1ib2w6ICdBVUROWkQnLFxuICAgICAgICB0aW1lZnJhbWU6ICcxNW0nLFxuICAgICAgICB0aW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0wN1QwMzo0NTowMC4wMDBaJyksXG4gICAgICAgIGJyb2tlclRpbWU6ICcyMDIwLTA0LTA3IDA2OjQ1OjAwLjAwMCcsXG4gICAgICAgIG9wZW46IDEuMDMyOTcsXG4gICAgICAgIGhpZ2g6IDEuMDYzMDksXG4gICAgICAgIGxvdzogMS4wMjcwNSxcbiAgICAgICAgY2xvc2U6IDEuMDQzLFxuICAgICAgICB0aWNrVm9sdW1lOiAxNDM1LFxuICAgICAgICBzcHJlYWQ6IDE3LFxuICAgICAgICB2b2x1bWU6IDM0NVxuICAgICAgfV07XG4gICAgICBsZXQgYm9va3MgPSBbe1xuICAgICAgICBzeW1ib2w6ICdBVUROWkQnLFxuICAgICAgICB0aW1lOiBuZXcgRGF0ZSgnMjAyMC0wNC0wN1QwMzo0NTowMC4wMDBaJyksXG4gICAgICAgIGJyb2tlclRpbWU6ICcyMDIwLTA0LTA3IDA2OjQ1OjAwLjAwMCcsXG4gICAgICAgIGJvb2s6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAnQk9PS19UWVBFX1NFTEwnLFxuICAgICAgICAgICAgcHJpY2U6IDEuMDUzMDksXG4gICAgICAgICAgICB2b2x1bWU6IDUuNjdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICdCT09LX1RZUEVfQlVZJyxcbiAgICAgICAgICAgIHByaWNlOiAxLjA1Mjk3LFxuICAgICAgICAgICAgdm9sdW1lOiAzLjQ1XG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9XTtcbiAgICAgIGxldCBsaXN0ZW5lciA9IHtcbiAgICAgICAgb25TeW1ib2xQcmljZVVwZGF0ZWQ6ICgpID0+IHt9LFxuICAgICAgICBvblN5bWJvbFByaWNlc1VwZGF0ZWQ6ICgpID0+IHt9LFxuICAgICAgICBvbkNhbmRsZXNVcGRhdGVkOiAoKSA9PiB7fSxcbiAgICAgICAgb25UaWNrc1VwZGF0ZWQ6ICgpID0+IHt9LFxuICAgICAgICBvbkJvb2tzVXBkYXRlZDogKCkgPT4ge31cbiAgICAgIH07XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvblN5bWJvbFByaWNlVXBkYXRlZCcpLnJlc29sdmVzKCk7XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvblN5bWJvbFByaWNlc1VwZGF0ZWQnKS5yZXNvbHZlcygpO1xuICAgICAgc2FuZGJveC5zdHViKGxpc3RlbmVyLCAnb25DYW5kbGVzVXBkYXRlZCcpLnJlc29sdmVzKCk7XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvblRpY2tzVXBkYXRlZCcpLnJlc29sdmVzKCk7XG4gICAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvbkJvb2tzVXBkYXRlZCcpLnJlc29sdmVzKCk7XG4gICAgICBjbGllbnQuYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIoJ2FjY291bnRJZCcsIGxpc3RlbmVyKTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ3ByaWNlcycsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMScsIHByaWNlcyxcbiAgICAgICAgdGlja3MsIGNhbmRsZXMsIGJvb2tzLCBlcXVpdHk6IDEwMCwgbWFyZ2luOiAyMDAsIGZyZWVNYXJnaW46IDQwMCwgbWFyZ2luTGV2ZWw6IDQwMDAwLCBpbnN0YW5jZUluZGV4OiAxfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChsaXN0ZW5lci5vblN5bWJvbFByaWNlc1VwZGF0ZWQsICcxOnBzLW1wYS0xJywgcHJpY2VzLCAxMDAsIDIwMCwgNDAwLCA0MDAwMCk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChsaXN0ZW5lci5vbkNhbmRsZXNVcGRhdGVkLCAnMTpwcy1tcGEtMScsIGNhbmRsZXMsIDEwMCwgMjAwLCA0MDAsIDQwMDAwKTtcbiAgICAgIHNpbm9uLmFzc2VydC5jYWxsZWRXaXRoKGxpc3RlbmVyLm9uVGlja3NVcGRhdGVkLCAnMTpwcy1tcGEtMScsIHRpY2tzLCAxMDAsIDIwMCwgNDAwLCA0MDAwMCk7XG4gICAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChsaXN0ZW5lci5vbkJvb2tzVXBkYXRlZCwgJzE6cHMtbXBhLTEnLCBib29rcywgMTAwLCAyMDAsIDQwMCwgNDAwMDApO1xuICAgICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgobGlzdGVuZXIub25TeW1ib2xQcmljZVVwZGF0ZWQsICcxOnBzLW1wYS0xJywgcHJpY2VzWzBdKTtcbiAgICB9KTtcblxuICB9KTtcblxuICBkZXNjcmliZSgnd2FpdCBmb3Igc2VydmVyLXNpZGUgdGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uJywgKCkgPT4ge1xuXG4gICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgIGNsaWVudC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I3dhaXRTeW5jaHJvbml6ZWR9XG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCB3YWl0IGZvciBzZXJ2ZXItc2lkZSB0ZXJtaW5hbCBzdGF0ZSBzeW5jaHJvbml6YXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgcmVxdWVzdFJlY2VpdmVkID0gZmFsc2U7XG4gICAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBkYXRhID0+IHtcbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ3dhaXRTeW5jaHJvbml6ZWQnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJlxuICAgICAgICAgIGRhdGEuYXBwbGljYXRpb25QYXR0ZXJuID09PSAnYXBwLionICYmIGRhdGEudGltZW91dEluU2Vjb25kcyA9PT0gMTAgJiZcbiAgICAgICAgICBkYXRhLmFwcGxpY2F0aW9uID09PSAnYXBwbGljYXRpb24nICYmIGRhdGEuaW5zdGFuY2VJbmRleCA9PT0gMSkge1xuICAgICAgICAgIHJlcXVlc3RSZWNlaXZlZCA9IHRydWU7XG4gICAgICAgICAgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge3R5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWR9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhd2FpdCBjbGllbnQud2FpdFN5bmNocm9uaXplZCgnYWNjb3VudElkJywgMSwgJ2FwcC4qJywgMTApO1xuICAgICAgcmVxdWVzdFJlY2VpdmVkLnNob3VsZC5iZS50cnVlKCk7XG4gICAgfSk7XG5cbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2xhdGVuY3kgbW9uaXRvcmluZycsICgpID0+IHtcblxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtMYXRlbmN5TGlzdGVuZXIjb25SZXNwb25zZX1cbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIGludm9rZSBsYXRlbmN5IGxpc3RlbmVyIG9uIHJlc3BvbnNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IGFjY291bnRJZDtcbiAgICAgIGxldCByZXF1ZXN0VHlwZTtcbiAgICAgIGxldCBhY3R1YWxUaW1lc3RhbXBzO1xuICAgICAgbGV0IGxpc3RlbmVyID0ge1xuICAgICAgICBvblJlc3BvbnNlOiAoYWlkLCB0eXBlLCB0cykgPT4ge1xuICAgICAgICAgIGFjY291bnRJZCA9IGFpZDtcbiAgICAgICAgICByZXF1ZXN0VHlwZSA9IHR5cGU7XG4gICAgICAgICAgYWN0dWFsVGltZXN0YW1wcyA9IHRzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2xpZW50LmFkZExhdGVuY3lMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICBsZXQgcHJpY2UgPSB7fTtcbiAgICAgIGxldCB0aW1lc3RhbXBzO1xuICAgICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdnZXRTeW1ib2xQcmljZScgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnICYmIGRhdGEuc3ltYm9sID09PSAnQVVETlpEJyAmJlxuICAgICAgICAgIGRhdGEuYXBwbGljYXRpb24gPT09ICdSUEMnICYmIGRhdGEudGltZXN0YW1wcy5jbGllbnRQcm9jZXNzaW5nU3RhcnRlZCkge1xuICAgICAgICAgIHRpbWVzdGFtcHMgPSBPYmplY3QuYXNzaWduKGRhdGEudGltZXN0YW1wcywge3NlcnZlclByb2Nlc3NpbmdTdGFydGVkOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgc2VydmVyUHJvY2Vzc2luZ0ZpbmlzaGVkOiBuZXcgRGF0ZSgpfSk7XG4gICAgICAgICAgdGltZXN0YW1wcy5jbGllbnRQcm9jZXNzaW5nU3RhcnRlZCA9IG5ldyBEYXRlKHRpbWVzdGFtcHMuY2xpZW50UHJvY2Vzc2luZ1N0YXJ0ZWQpO1xuICAgICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLCBwcmljZSxcbiAgICAgICAgICAgIHRpbWVzdGFtcHN9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhd2FpdCBjbGllbnQuZ2V0U3ltYm9sUHJpY2UoJ2FjY291bnRJZCcsICdBVUROWkQnKTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgMTAwKSk7XG4gICAgICBhY2NvdW50SWQuc2hvdWxkLmVxdWFsKCdhY2NvdW50SWQnKTtcbiAgICAgIHJlcXVlc3RUeXBlLnNob3VsZC5lcXVhbCgnZ2V0U3ltYm9sUHJpY2UnKTtcbiAgICAgIGFjdHVhbFRpbWVzdGFtcHMuc2hvdWxkLm1hdGNoKHRpbWVzdGFtcHMpO1xuICAgICAgc2hvdWxkLmV4aXN0KGFjdHVhbFRpbWVzdGFtcHMuY2xpZW50UHJvY2Vzc2luZ1N0YXJ0ZWQpO1xuICAgICAgc2hvdWxkLmV4aXN0KGFjdHVhbFRpbWVzdGFtcHMuY2xpZW50UHJvY2Vzc2luZ0ZpbmlzaGVkKTtcbiAgICAgIHNob3VsZC5leGlzdChhY3R1YWxUaW1lc3RhbXBzLnNlcnZlclByb2Nlc3NpbmdTdGFydGVkKTtcbiAgICAgIHNob3VsZC5leGlzdChhY3R1YWxUaW1lc3RhbXBzLnNlcnZlclByb2Nlc3NpbmdGaW5pc2hlZCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAdGVzdCB7TGF0ZW5jeUxpc3RlbmVyI29uU3ltYm9sUHJpY2V9XG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBtZWFzdXJlIHByaWNlIHN0cmVhbWluZyBsYXRlbmNpZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgcHJpY2VzID0gW3tcbiAgICAgICAgc3ltYm9sOiAnQVVETlpEJyxcbiAgICAgICAgdGltZXN0YW1wczoge1xuICAgICAgICAgIGV2ZW50R2VuZXJhdGVkOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgIHNlcnZlclByb2Nlc3NpbmdTdGFydGVkOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgIHNlcnZlclByb2Nlc3NpbmdGaW5pc2hlZDogbmV3IERhdGUoKVxuICAgICAgICB9XG4gICAgICB9XTtcbiAgICAgIGxldCBhY2NvdW50SWQ7XG4gICAgICBsZXQgc3ltYm9sO1xuICAgICAgbGV0IGFjdHVhbFRpbWVzdGFtcHM7XG4gICAgICBsZXQgbGlzdGVuZXIgPSB7XG4gICAgICAgIG9uU3ltYm9sUHJpY2U6IChhaWQsIHN5bSwgdHMpID0+IHtcbiAgICAgICAgICBhY2NvdW50SWQgPSBhaWQ7XG4gICAgICAgICAgc3ltYm9sID0gc3ltO1xuICAgICAgICAgIGFjdHVhbFRpbWVzdGFtcHMgPSB0cztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNsaWVudC5hZGRMYXRlbmN5TGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAncHJpY2VzJywgYWNjb3VudElkOiAnYWNjb3VudElkJywgcHJpY2VzLCBlcXVpdHk6IDEwMCwgbWFyZ2luOiAyMDAsXG4gICAgICAgIGZyZWVNYXJnaW46IDQwMCwgbWFyZ2luTGV2ZWw6IDQwMDAwfSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgICBhY2NvdW50SWQuc2hvdWxkLmVxdWFsKCdhY2NvdW50SWQnKTtcbiAgICAgIHN5bWJvbC5zaG91bGQuZXF1YWwoJ0FVRE5aRCcpO1xuICAgICAgYWN0dWFsVGltZXN0YW1wcy5zaG91bGQubWF0Y2gocHJpY2VzWzBdLnRpbWVzdGFtcHMpO1xuICAgICAgc2hvdWxkLmV4aXN0KGFjdHVhbFRpbWVzdGFtcHMuY2xpZW50UHJvY2Vzc2luZ0ZpbmlzaGVkKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEB0ZXN0IHtMYXRlbmN5TGlzdGVuZXIjb25VcGRhdGV9XG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBtZWFzdXJlIHVwZGF0ZSBsYXRlbmNpZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgdXBkYXRlID0ge1xuICAgICAgICB0aW1lc3RhbXBzOiB7XG4gICAgICAgICAgZXZlbnRHZW5lcmF0ZWQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgc2VydmVyUHJvY2Vzc2luZ1N0YXJ0ZWQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgc2VydmVyUHJvY2Vzc2luZ0ZpbmlzaGVkOiBuZXcgRGF0ZSgpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBsZXQgYWNjb3VudElkO1xuICAgICAgbGV0IGFjdHVhbFRpbWVzdGFtcHM7XG4gICAgICBsZXQgbGlzdGVuZXIgPSB7XG4gICAgICAgIG9uVXBkYXRlOiAoYWlkLCB0cykgPT4ge1xuICAgICAgICAgIGFjY291bnRJZCA9IGFpZDtcbiAgICAgICAgICBhY3R1YWxUaW1lc3RhbXBzID0gdHM7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjbGllbnQuYWRkTGF0ZW5jeUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCBPYmplY3QuYXNzaWduKHt0eXBlOiAndXBkYXRlJywgYWNjb3VudElkOiAnYWNjb3VudElkJ30sIHVwZGF0ZSkpO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgICAgYWNjb3VudElkLnNob3VsZC5lcXVhbCgnYWNjb3VudElkJyk7XG4gICAgICBhY3R1YWxUaW1lc3RhbXBzLnNob3VsZC5tYXRjaCh1cGRhdGUudGltZXN0YW1wcyk7XG4gICAgICBzaG91bGQuZXhpc3QoYWN0dWFsVGltZXN0YW1wcy5jbGllbnRQcm9jZXNzaW5nRmluaXNoZWQpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHRlc3Qge0xhdGVuY3lMaXN0ZW5lciNvblRyYWRlfVxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgcHJvY2VzcyB0cmFkZSBsYXRlbmN5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHRyYWRlID0ge307XG4gICAgICBsZXQgcmVzcG9uc2UgPSB7XG4gICAgICAgIG51bWVyaWNDb2RlOiAxMDAwOSxcbiAgICAgICAgc3RyaW5nQ29kZTogJ1RSQURFX1JFVENPREVfRE9ORScsXG4gICAgICAgIG1lc3NhZ2U6ICdSZXF1ZXN0IGNvbXBsZXRlZCcsXG4gICAgICAgIG9yZGVySWQ6ICc0Njg3MDQ3MidcbiAgICAgIH07XG4gICAgICBsZXQgdGltZXN0YW1wcyA9IHtcbiAgICAgICAgY2xpZW50RXhlY3V0aW9uU3RhcnRlZDogbmV3IERhdGUoKSxcbiAgICAgICAgc2VydmVyRXhlY3V0aW9uU3RhcnRlZDogbmV3IERhdGUoKSxcbiAgICAgICAgc2VydmVyRXhlY3V0aW9uRmluaXNoZWQ6IG5ldyBEYXRlKCksXG4gICAgICAgIHRyYWRlRXhlY3V0ZWQ6IG5ldyBEYXRlKClcbiAgICAgIH07XG4gICAgICBsZXQgYWNjb3VudElkO1xuICAgICAgbGV0IGFjdHVhbFRpbWVzdGFtcHM7XG4gICAgICBsZXQgbGlzdGVuZXIgPSB7XG4gICAgICAgIG9uVHJhZGU6IChhaWQsIHRzKSA9PiB7XG4gICAgICAgICAgYWNjb3VudElkID0gYWlkO1xuICAgICAgICAgIGFjdHVhbFRpbWVzdGFtcHMgPSB0cztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNsaWVudC5hZGRMYXRlbmN5TGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICAgIGRhdGEudHJhZGUuc2hvdWxkLm1hdGNoKHRyYWRlKTtcbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ3RyYWRlJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ2FwcGxpY2F0aW9uJykge1xuICAgICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLCByZXNwb25zZSxcbiAgICAgICAgICAgIHRpbWVzdGFtcHN9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhd2FpdCBjbGllbnQudHJhZGUoJ2FjY291bnRJZCcsIHRyYWRlKTtcbiAgICAgIGFjY291bnRJZC5zaG91bGQuZXF1YWwoJ2FjY291bnRJZCcpO1xuICAgICAgYWN0dWFsVGltZXN0YW1wcy5zaG91bGQubWF0Y2godGltZXN0YW1wcyk7XG4gICAgICBzaG91bGQuZXhpc3QoYWN0dWFsVGltZXN0YW1wcy5jbGllbnRQcm9jZXNzaW5nRmluaXNoZWQpO1xuICAgIH0pO1xuXG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgcmVjb25uZWN0IHRvIHNlcnZlciBvbiBkaXNjb25uZWN0JywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGNsb2NrID0gc2lub24udXNlRmFrZVRpbWVycyh7c2hvdWxkQWR2YW5jZVRpbWU6IHRydWV9KTtcbiAgICBjb25zdCB0cmFkZSA9IHtcbiAgICAgIGFjdGlvblR5cGU6ICdPUkRFUl9UWVBFX1NFTEwnLFxuICAgICAgc3ltYm9sOiAnQVVETlpEJyxcbiAgICAgIHZvbHVtZTogMC4wN1xuICAgIH07XG4gICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICBudW1lcmljQ29kZTogMTAwMDksXG4gICAgICBzdHJpbmdDb2RlOiAnVFJBREVfUkVUQ09ERV9ET05FJyxcbiAgICAgIG1lc3NhZ2U6ICdSZXF1ZXN0IGNvbXBsZXRlZCcsXG4gICAgICBvcmRlcklkOiAnNDY4NzA0NzInXG4gICAgfTtcbiAgICBsZXQgbGlzdGVuZXIgPSB7XG4gICAgICBvblJlY29ubmVjdGVkOiAoKSA9PiB7fSxcbiAgICB9O1xuICAgIHNhbmRib3guc3R1YihsaXN0ZW5lciwgJ29uUmVjb25uZWN0ZWQnKS5yZXNvbHZlcygpO1xuICAgIHNhbmRib3guc3R1YihjbGllbnQuX3BhY2tldE9yZGVyZXIsICdvblJlY29ubmVjdGVkJykucmVzb2x2ZXMoKTtcbiAgICBzYW5kYm94LnN0dWIoY2xpZW50Ll9zdWJzY3JpcHRpb25NYW5hZ2VyLCAnb25SZWNvbm5lY3RlZCcpLnJlc29sdmVzKCk7XG4gICAgY2xpZW50LmFkZFJlY29ubmVjdExpc3RlbmVyKGxpc3RlbmVyLCAnYWNjb3VudElkJyk7XG4gICAgbGV0IHJlcXVlc3RDb3VudGVyID0gMDtcbiAgICBzZXJ2ZXIub24oJ3JlcXVlc3QnLCBhc3luYyBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICd0cmFkZScgJiYgZGF0YS5hY2NvdW50SWQgPT09ICdhY2NvdW50SWQnICYmIGRhdGEuYXBwbGljYXRpb24gPT09ICdhcHBsaWNhdGlvbicpIHtcbiAgICAgICAgcmVxdWVzdENvdW50ZXIrKztcbiAgICAgICAgYXdhaXQgc2VydmVyLmVtaXQoJ3Jlc3BvbnNlJywge3R5cGU6ICdyZXNwb25zZScsIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIFxuICAgICAgICAgIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWQsIHJlc3BvbnNlfSk7XG4gICAgICB9XG4gICAgICBhd2FpdCBzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH0pO1xuICBcbiAgICBjbGllbnQudHJhZGUoJ2FjY291bnRJZCcsIHRyYWRlKTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgYXdhaXQgY2xvY2sudGlja0FzeW5jKDE1MDApO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICBzaW5vbi5hc3NlcnQuY2FsbGVkT25jZShsaXN0ZW5lci5vblJlY29ubmVjdGVkKTtcbiAgICBzaW5vbi5hc3NlcnQuY2FsbGVkV2l0aChjbGllbnQuX3N1YnNjcmlwdGlvbk1hbmFnZXIub25SZWNvbm5lY3RlZCwgMCwgWydhY2NvdW50SWQnXSk7XG4gICAgc2lub24uYXNzZXJ0LmNhbGxlZFdpdGgoY2xpZW50Ll9wYWNrZXRPcmRlcmVyLm9uUmVjb25uZWN0ZWQsIFsnYWNjb3VudElkJ10pO1xuXG4gICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgYXN5bmMgZGF0YSA9PiB7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAndHJhZGUnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLmFwcGxpY2F0aW9uID09PSAnYXBwbGljYXRpb24nKSB7XG4gICAgICAgIHJlcXVlc3RDb3VudGVyKys7XG4gICAgICAgIGF3YWl0IHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCBcbiAgICAgICAgICByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLCByZXNwb25zZX0pO1xuICAgICAgfVxuICAgICAgYXdhaXQgc2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9KTtcbiAgXG4gICAgY2xpZW50LnRyYWRlKCdhY2NvdW50SWQnLCB0cmFkZSk7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MCkpO1xuICAgIGF3YWl0IGNsb2NrLnRpY2tBc3luYygxNTAwKTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgc2lub24uYXNzZXJ0Lm1hdGNoKHJlcXVlc3RDb3VudGVyLCAyKTtcbiAgICBjbG9jay5yZXN0b3JlKCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNfcnBjUmVxdWVzdH1cbiAgICovXG4gIGl0KCdzaG91bGQgcmVtb3ZlIHJlY29ubmVjdCBsaXN0ZW5lcicsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBjbG9jayA9IHNpbm9uLnVzZUZha2VUaW1lcnMoe3Nob3VsZEFkdmFuY2VUaW1lOiB0cnVlfSk7XG5cbiAgICBsZXQgdHJhZGUgPSB7XG4gICAgICBhY3Rpb25UeXBlOiAnT1JERVJfVFlQRV9TRUxMJyxcbiAgICAgIHN5bWJvbDogJ0FVRE5aRCcsXG4gICAgICB2b2x1bWU6IDAuMDdcbiAgICB9O1xuICAgIGxldCByZXNwb25zZSA9IHtcbiAgICAgIG51bWVyaWNDb2RlOiAxMDAwOSxcbiAgICAgIHN0cmluZ0NvZGU6ICdUUkFERV9SRVRDT0RFX0RPTkUnLFxuICAgICAgbWVzc2FnZTogJ1JlcXVlc3QgY29tcGxldGVkJyxcbiAgICAgIG9yZGVySWQ6ICc0Njg3MDQ3MidcbiAgICB9O1xuICAgIGNvbnN0IGxpc3RlbmVyID0ge29uUmVjb25uZWN0ZWQ6IGFzeW5jICgpID0+IHt9fTtcbiAgICBzYW5kYm94LnN0dWIobGlzdGVuZXIsICdvblJlY29ubmVjdGVkJykucmVzb2x2ZXMoKTtcbiAgICBjbGllbnQuYWRkUmVjb25uZWN0TGlzdGVuZXIobGlzdGVuZXIsICdhY2NvdW50SWQnKTtcbiAgICBzYW5kYm94LnN0dWIoY2xpZW50Ll9zdWJzY3JpcHRpb25NYW5hZ2VyLCAnb25SZWNvbm5lY3RlZCcpO1xuICAgIGxldCByZXF1ZXN0Q291bnRlciA9IDA7XG4gICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICBkYXRhLnRyYWRlLnNob3VsZC5tYXRjaCh0cmFkZSk7XG4gICAgICByZXF1ZXN0Q291bnRlcisrO1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ3RyYWRlJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ2FwcGxpY2F0aW9uJykge1xuICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCwgcmVzcG9uc2V9KTtcbiAgICAgIH1cbiAgICAgIHNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfSk7XG5cbiAgICBhd2FpdCBjbGllbnQudHJhZGUoJ2FjY291bnRJZCcsIHRyYWRlKTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgYXdhaXQgY2xvY2sudGlja0FzeW5jKDExMDApO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICBzaW5vbi5hc3NlcnQuY2FsbGVkT25jZShsaXN0ZW5lci5vblJlY29ubmVjdGVkKTtcbiAgICBjbGllbnQucmVtb3ZlUmVjb25uZWN0TGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICBkYXRhLnRyYWRlLnNob3VsZC5tYXRjaCh0cmFkZSk7XG4gICAgICByZXF1ZXN0Q291bnRlcisrO1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ3RyYWRlJyAmJiBkYXRhLmFjY291bnRJZCA9PT0gJ2FjY291bnRJZCcgJiYgZGF0YS5hcHBsaWNhdGlvbiA9PT0gJ2FwcGxpY2F0aW9uJykge1xuICAgICAgICBzZXJ2ZXIuZW1pdCgncmVzcG9uc2UnLCB7dHlwZTogJ3Jlc3BvbnNlJywgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCwgcmVzcG9uc2V9KTtcbiAgICAgIH1cbiAgICAgIHNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfSk7XG5cbiAgICBhd2FpdCBjbGllbnQudHJhZGUoJ2FjY291bnRJZCcsIHRyYWRlKTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgYXdhaXQgY2xvY2sudGlja0FzeW5jKDExMDApO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICBzaW5vbi5hc3NlcnQuY2FsbGVkT25jZShsaXN0ZW5lci5vblJlY29ubmVjdGVkKTtcbiAgICBzaW5vbi5hc3NlcnQubWF0Y2gocmVxdWVzdENvdW50ZXIsIDIpO1xuICAgIGNsb2NrLnJlc3RvcmUoKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEB0ZXN0IHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50I3F1ZXVlUGFja2V0fVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBwcm9jZXNzIHBhY2tldHMgaW4gb3JkZXInLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgY2xvY2sgPSBzaW5vbi51c2VGYWtlVGltZXJzKHtzaG91bGRBZHZhbmNlVGltZTogdHJ1ZX0pO1xuICAgIGxldCBvcmRlcnNDYWxsVGltZSA9IDA7XG4gICAgbGV0IHBvc2l0aW9uc0NhbGxUaW1lID0gMDtcbiAgICBsZXQgZGlzY29ubmVjdGVkQ2FsbFRpbWUgPSAwO1xuICAgIGxldCBwcmljZXNDYWxsVGltZSA9IDA7XG4gICAgbGV0IGxpc3RlbmVyID0ge1xuICAgICAgb25Db25uZWN0ZWQ6ICgpID0+IHt9LFxuICAgICAgb25EaXNjb25uZWN0ZWQ6IGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MDAwKSk7XG4gICAgICAgIGRpc2Nvbm5lY3RlZENhbGxUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIH0sXG4gICAgICBvbk9yZGVyc1JlcGxhY2VkOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgMTAwMDApKTtcbiAgICAgICAgb3JkZXJzQ2FsbFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgfSxcbiAgICAgIG9uUG9zaXRpb25zUmVwbGFjZWQ6IGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCAxMDAwKSk7XG4gICAgICAgIHBvc2l0aW9uc0NhbGxUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIH0sXG4gICAgICBvblN5bWJvbFByaWNlc1VwZGF0ZWQ6IGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCAxMDAwKSk7XG4gICAgICAgIHByaWNlc0NhbGxUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIH0sXG4gICAgfTtcbiAgICBsZXQgcmVzb2x2ZTtcbiAgICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlcyA9PiByZXNvbHZlID0gcmVzKTtcbiAgICBjbGllbnQuY2xvc2UoKTtcbiAgICBpby5jbG9zZSgoKSA9PiByZXNvbHZlKCkpO1xuICAgIGF3YWl0IHByb21pc2U7XG4gICAgaW8gPSBuZXcgU2VydmVyKDY3ODUsIHtwYXRoOiAnL3dzJywgcGluZ1RpbWVvdXQ6IDEwMDAwMDB9KTtcbiAgICBzYW5kYm94LnN0dWIoaHR0cENsaWVudCwgJ3JlcXVlc3QnKS5yZXNvbHZlcyh7dXJsOiAnaHR0cDovL2xvY2FsaG9zdDo2Nzg1J30pO1xuICAgIGNsaWVudCA9IG5ldyBNZXRhQXBpV2Vic29ja2V0Q2xpZW50KGh0dHBDbGllbnQsICd0b2tlbicsIHthcHBsaWNhdGlvbjogJ2FwcGxpY2F0aW9uJywgXG4gICAgICBkb21haW46ICdwcm9qZWN0LXN0b2NrLmFnaWxpdW1sYWJzLmNsb3VkJywgcmVxdWVzdFRpbWVvdXQ6IDEuNSwgdXNlU2hhcmVkQ2xpZW50QXBpOiBmYWxzZSxcbiAgICAgIHJldHJ5T3B0czogeyByZXRyaWVzOiAzLCBtaW5EZWxheUluU2Vjb25kczogMC4xLCBtYXhEZWxheUluU2Vjb25kczogMC41fSxcbiAgICAgIGV2ZW50UHJvY2Vzc2luZzoge3NlcXVlbnRpYWxQcm9jZXNzaW5nOiB0cnVlfX0pO1xuICAgIGlvLm9uKCdjb25uZWN0Jywgc29ja2V0ID0+IHtcbiAgICAgIHNlcnZlciA9IHNvY2tldDtcbiAgICAgIGlmIChzb2NrZXQucmVxdWVzdC5fcXVlcnlbJ2F1dGgtdG9rZW4nXSAhPT0gJ3Rva2VuJykge1xuICAgICAgICBzb2NrZXQuZW1pdCh7ZXJyb3I6ICdVbmF1dGhvcml6ZWRFcnJvcicsIG1lc3NhZ2U6ICdBdXRob3JpemF0aW9uIHRva2VuIGludmFsaWQnfSk7XG4gICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgfVxuICAgICAgc2VydmVyLm9uKCdyZXF1ZXN0JywgZGF0YSA9PiB7XG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdnZXRQb3NpdGlvbnMnICYmIGRhdGEuYWNjb3VudElkID09PSAnYWNjb3VudElkJyAmJiBkYXRhLmFwcGxpY2F0aW9uID09PSAnUlBDJykge1xuICAgICAgICAgIHNlcnZlci5lbWl0KCdyZXNwb25zZScsIHt0eXBlOiAncmVzcG9uc2UnLCBhY2NvdW50SWQ6IGRhdGEuYWNjb3VudElkLCBcbiAgICAgICAgICAgIHJlcXVlc3RJZDogZGF0YS5yZXF1ZXN0SWQsIHBvc2l0aW9uczogW119KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgYXdhaXQgY2xpZW50LmdldFBvc2l0aW9ucygnYWNjb3VudElkJyk7XG4gICAgY2xpZW50LmFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKCdhY2NvdW50SWQnLCBsaXN0ZW5lcik7XG4gICAgc2FuZGJveC5zdHViKGNsaWVudC5fcGFja2V0T3JkZXJlciwgJ3Jlc3RvcmVPcmRlcicpLmNhbGxzRmFrZSgoYXJnKSA9PiB7XG4gICAgICByZXR1cm4gW2FyZ107XG4gICAgfSk7XG4gICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnYXV0aGVudGljYXRlZCcsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIGhvc3Q6ICdwcy1tcGEtMScsXG4gICAgICBpbnN0YW5jZUluZGV4OiAxLCByZXBsaWNhczogMiwgc2VxdWVuY2VOdW1iZXI6IDF9KTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgYXdhaXQgY2xvY2sudGlja0FzeW5jKDU5MDAwKTtcbiAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdvcmRlcnMnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBvcmRlcnM6IFtdLCBpbnN0YW5jZUluZGV4OiAxLFxuICAgICAgaG9zdDogJ3BzLW1wYS0xJywgc2VxdWVuY2VOdW1iZXI6IDJ9KTtcbiAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdwcmljZXMnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBwcmljZXM6IFt7c3ltYm9sOiAnRVVSVVNEJ31dLCBcbiAgICAgIGluc3RhbmNlSW5kZXg6IDEsIGhvc3Q6ICdwcy1tcGEtMScsIGVxdWl0eTogMTAwLCBtYXJnaW46IDIwMCwgZnJlZU1hcmdpbjogNDAwLCBtYXJnaW5MZXZlbDogNDAwMDB9KTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgYXdhaXQgY2xvY2sudGlja0FzeW5jKDMwMDApO1xuICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ3Bvc2l0aW9ucycsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIHBvc2l0aW9uczogW10sIGluc3RhbmNlSW5kZXg6IDEsXG4gICAgICBob3N0OiAncHMtbXBhLTEnLCBzZXF1ZW5jZU51bWJlcjogM30pO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICBhd2FpdCBjbG9jay50aWNrQXN5bmMoMjAwMDApO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICBwcmljZXNDYWxsVGltZS5zaG91bGQubm90LmVxbCgwKTtcbiAgICAob3JkZXJzQ2FsbFRpbWUpLnNob3VsZC5iZS5hYm92ZShwcmljZXNDYWxsVGltZSk7XG4gICAgKGRpc2Nvbm5lY3RlZENhbGxUaW1lKS5zaG91bGQuYmUuYWJvdmUob3JkZXJzQ2FsbFRpbWUpO1xuICAgIChwb3NpdGlvbnNDYWxsVGltZSkuc2hvdWxkLmJlLmFib3ZlKGRpc2Nvbm5lY3RlZENhbGxUaW1lKTtcbiAgICBjbG9jay5yZXN0b3JlKCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdGVzdCB7TWV0YUFwaVdlYnNvY2tldENsaWVudCNxdWV1ZVBhY2tldH1cbiAgICovXG4gIGl0KCdzaG91bGQgbm90IHByb2Nlc3Mgb2xkIHN5bmNocm9uaXphdGlvbiBwYWNrZXQgd2l0aG91dCBnYXBzIGluIHNlcXVlbmNlIG51bWJlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IGxpc3RlbmVyID0ge1xuICAgICAgb25TeW5jaHJvbml6YXRpb25TdGFydGVkOiBzaW5vbi5mYWtlKCksXG4gICAgICBvbk9yZGVyc1JlcGxhY2VkOiBzaW5vbi5mYWtlKCksXG4gICAgfTtcbiAgICBjbGllbnQuYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIoJ2FjY291bnRJZCcsIGxpc3RlbmVyKTtcbiAgICBzYW5kYm94LnN0dWIoY2xpZW50Ll9wYWNrZXRPcmRlcmVyLCAncmVzdG9yZU9yZGVyJykuY2FsbHNGYWtlKGFyZyA9PiBbYXJnXSk7XG5cbiAgICBzYW5kYm94LnN0dWIoY2xpZW50Ll9zb2NrZXRJbnN0YW5jZXNbMF0uc3luY2hyb25pemF0aW9uVGhyb3R0bGVyLCAnYWN0aXZlU3luY2hyb25pemF0aW9uSWRzJykuZ2V0KCgpID0+IFsnQUJDJ10pO1xuICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ3N5bmNocm9uaXphdGlvblN0YXJ0ZWQnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IDEsIHNlcXVlbmNlVGltZXN0YW1wOiAxNjAzMTI0MjY3MTc4LCBzeW5jaHJvbml6YXRpb25JZDogJ0FCQyd9KTtcbiAgICBzZXJ2ZXIuZW1pdCgnc3luY2hyb25pemF0aW9uJywge3R5cGU6ICdvcmRlcnMnLCBhY2NvdW50SWQ6ICdhY2NvdW50SWQnLCBvcmRlcnM6IFtdLFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IDIsIHNlcXVlbmNlVGltZXN0YW1wOiAxNjAzMTI0MjY3MTgxLCBzeW5jaHJvbml6YXRpb25JZDogJ0FCQyd9KTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwKSk7XG4gICAgc2lub24uYXNzZXJ0LmNhbGxlZE9uY2UobGlzdGVuZXIub25TeW5jaHJvbml6YXRpb25TdGFydGVkKTtcbiAgICBzaW5vbi5hc3NlcnQuY2FsbGVkT25jZShsaXN0ZW5lci5vbk9yZGVyc1JlcGxhY2VkKTtcblxuICAgIHNhbmRib3guc3R1YihjbGllbnQuX3NvY2tldEluc3RhbmNlc1swXS5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIsICdhY3RpdmVTeW5jaHJvbml6YXRpb25JZHMnKS5nZXQoKCkgPT4gWydERUYnXSk7XG4gICAgc2VydmVyLmVtaXQoJ3N5bmNocm9uaXphdGlvbicsIHt0eXBlOiAnc3luY2hyb25pemF0aW9uU3RhcnRlZCcsIGFjY291bnRJZDogJ2FjY291bnRJZCcsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMywgc2VxdWVuY2VUaW1lc3RhbXA6IDE2MDMxMjQyNjcxOTAsIHN5bmNocm9uaXphdGlvbklkOiAnREVGJ30pO1xuICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ29yZGVycycsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIG9yZGVyczogW10sXG4gICAgICBzZXF1ZW5jZU51bWJlcjogNCwgc2VxdWVuY2VUaW1lc3RhbXA6IDE2MDMxMjQyNjcxOTIsIHN5bmNocm9uaXphdGlvbklkOiAnQUJDJ30pO1xuICAgIHNlcnZlci5lbWl0KCdzeW5jaHJvbml6YXRpb24nLCB7dHlwZTogJ29yZGVycycsIGFjY291bnRJZDogJ2FjY291bnRJZCcsIG9yZGVyczogW10sXG4gICAgICBzZXF1ZW5jZU51bWJlcjogNSwgc2VxdWVuY2VUaW1lc3RhbXA6IDE2MDMxMjQyNjcxOTUsIHN5bmNocm9uaXphdGlvbklkOiAnREVGJ30pO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTApKTtcbiAgICBzaW5vbi5hc3NlcnQuY2FsbGVkVHdpY2UobGlzdGVuZXIub25TeW5jaHJvbml6YXRpb25TdGFydGVkKTtcbiAgICBzaW5vbi5hc3NlcnQuY2FsbGVkVHdpY2UobGlzdGVuZXIub25PcmRlcnNSZXBsYWNlZCk7XG4gIH0pO1xuXG59KTtcbiJdfQ==
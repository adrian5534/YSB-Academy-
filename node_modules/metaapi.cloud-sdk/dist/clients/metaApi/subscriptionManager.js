'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Subscription manager to handle account subscription logic
 */
class SubscriptionManager {

  /**
   * Constructs the subscription manager
   * @param {MetaApiWebsocketClient} websocketClient websocket client to use for sending requests
   */
  constructor(websocketClient) {
    this._websocketClient = websocketClient;
    this._subscriptions = {};
    this._awaitingResubscribe = {};
  }

  /**
   * Returns whether an account is currently subscribing
   * @param {String} accountId account id
   * @param {Number} instanceNumber instance index number
   * @returns {Boolean} whether an account is currently subscribing
   */
  isAccountSubscribing(accountId, instanceNumber) {
    if (instanceNumber !== undefined) {
      return (0, _keys2.default)(this._subscriptions).includes(accountId + ':' + instanceNumber);
    } else {
      for (let key of (0, _keys2.default)(this._subscriptions)) {
        if (key.startsWith(accountId)) {
          return true;
        }
      }
      return false;
    }
  }

  /**
   * Returns whether an instance is in disconnected retry mode
   * @param {String} accountId account id
   * @param {Number} instanceNumber instance index number
   * @returns {Boolean} whether an account is currently subscribing
   */
  isDisconnectedRetryMode(accountId, instanceNumber) {
    let instanceId = accountId + ':' + (instanceNumber || 0);
    return this._subscriptions[instanceId] ? this._subscriptions[instanceId].isDisconnectedRetryMode : false;
  }

  /**
   * Schedules to send subscribe requests to an account until cancelled
   * @param {String} accountId id of the MetaTrader account
   * @param {Number} instanceNumber instance index number
   * @param {Boolean} isDisconnectedRetryMode whether to start subscription in disconnected retry
   * mode. Subscription task in disconnected mode will be immediately replaced when the status packet is received
   */
  async subscribe(accountId, instanceNumber, isDisconnectedRetryMode = false) {
    const client = this._websocketClient;
    let instanceId = accountId + ':' + (instanceNumber || 0);
    if (!this._subscriptions[instanceId]) {
      this._subscriptions[instanceId] = {
        shouldRetry: true,
        task: null,
        waitTask: null,
        future: null,
        isDisconnectedRetryMode
      };
      let subscribeRetryIntervalInSeconds = 3;
      while (this._subscriptions[instanceId].shouldRetry) {
        let resolveSubscribe;
        this._subscriptions[instanceId].task = { promise: new _promise2.default(res => {
            resolveSubscribe = res;
          }) };
        this._subscriptions[instanceId].task.resolve = resolveSubscribe;
        // eslint-disable-next-line no-inner-declarations
        async function subscribeTask() {
          try {
            await client.subscribe(accountId, instanceNumber);
          } catch (err) {
            if (err.name === 'TooManyRequestsError') {
              const socketInstanceIndex = client.socketInstancesByAccounts[accountId];
              if (err.metadata.type === 'LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_USER') {
                console.log(err);
              }
              if (['LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_USER', 'LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_SERVER', 'LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_USER_PER_SERVER'].includes(err.metadata.type)) {
                delete client.socketInstancesByAccounts[accountId];
                client.lockSocketInstance(socketInstanceIndex, err.metadata);
              } else {
                const retryTime = new Date(err.metadata.recommendedRetryTime).getTime();
                if (Date.now() + subscribeRetryIntervalInSeconds * 1000 < retryTime) {
                  await new _promise2.default(res => setTimeout(res, retryTime - Date.now() - subscribeRetryIntervalInSeconds * 1000));
                }
              }
            }
          }
          resolveSubscribe();
        }
        subscribeTask();
        await this._subscriptions[instanceId].task.promise;
        if (!this._subscriptions[instanceId].shouldRetry) {
          break;
        }
        const retryInterval = subscribeRetryIntervalInSeconds;
        subscribeRetryIntervalInSeconds = Math.min(subscribeRetryIntervalInSeconds * 2, 300);
        let resolve;
        let subscribePromise = new _promise2.default(res => {
          resolve = res;
        });
        this._subscriptions[instanceId].waitTask = setTimeout(() => {
          resolve(true);
        }, retryInterval * 1000);
        this._subscriptions[instanceId].future = { resolve, promise: subscribePromise };
        const result = await this._subscriptions[instanceId].future.promise;
        this._subscriptions[instanceId].future = null;
        if (!result) {
          break;
        }
      }
      delete this._subscriptions[instanceId];
    }
  }

  /**
   * Cancels active subscription tasks for an instance id
   * @param {String} instanceId instance id to cancel subscription task for
   */
  cancelSubscribe(instanceId) {
    if (this._subscriptions[instanceId]) {
      const subscription = this._subscriptions[instanceId];
      if (subscription.future) {
        subscription.future.resolve(false);
        clearTimeout(subscription.waitTask);
      }
      if (subscription.task) {
        subscription.task.resolve(false);
      }
      subscription.shouldRetry = false;
    }
  }

  /**
   * Cancels active subscription tasks for an account
   * @param {String} accountId account id to cancel subscription tasks for
   */
  cancelAccount(accountId) {
    for (let instanceId of (0, _keys2.default)(this._subscriptions).filter(key => key.startsWith(accountId))) {
      this.cancelSubscribe(instanceId);
    }
  }

  /**
   * Invoked on account timeout.
   * @param {String} accountId id of the MetaTrader account
   * @param {Number} instanceNumber instance index number
   */
  onTimeout(accountId, instanceNumber) {
    if (this._websocketClient.socketInstancesByAccounts[accountId] !== undefined && this._websocketClient.connected(this._websocketClient.socketInstancesByAccounts[accountId])) {
      this.subscribe(accountId, instanceNumber, true);
    }
  }

  /**
   * Invoked when connection to MetaTrader terminal terminated
   * @param {String} accountId id of the MetaTrader account
   * @param {Number} instanceNumber instance index number
   */
  async onDisconnected(accountId, instanceNumber) {
    await new _promise2.default(res => setTimeout(res, Math.max(Math.random() * 5, 1) * 1000));
    if (this._websocketClient.socketInstancesByAccounts[accountId] !== undefined) {
      this.subscribe(accountId, instanceNumber, true);
    }
  }

  /**
   * Invoked when connection to MetaApi websocket API restored after a disconnect.
   * @param {Number} socketInstanceIndex socket instance index
   * @param {String[]} reconnectAccountIds account ids to reconnect
   */
  onReconnected(socketInstanceIndex, reconnectAccountIds) {
    try {
      const socketInstancesByAccounts = this._websocketClient.socketInstancesByAccounts;
      for (let instanceId of (0, _keys2.default)(this._subscriptions)) {
        const accountId = instanceId.split(':')[0];
        if (socketInstancesByAccounts[accountId] === socketInstanceIndex) {
          this.cancelSubscribe(instanceId);
        }
      }
      reconnectAccountIds.forEach(async accountId => {
        try {
          if (!this._awaitingResubscribe[accountId]) {
            this._awaitingResubscribe[accountId] = true;
            while (this.isAccountSubscribing(accountId)) {
              await new _promise2.default(res => setTimeout(res, 1000));
            }
            delete this._awaitingResubscribe[accountId];
            await new _promise2.default(res => setTimeout(res, Math.random() * 5000));
            this.subscribe(accountId);
          }
        } catch (err) {
          console.error('[' + new Date().toISOString() + '] Account ' + accountId + ' resubscribe task failed', err);
        }
      });
    } catch (err) {
      console.error('[' + new Date().toISOString() + '] Failed to process subscribe manager reconnected event', err);
    }
  }
}
exports.default = SubscriptionManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9jbGllbnRzL21ldGFBcGkvc3Vic2NyaXB0aW9uTWFuYWdlci5lczYiXSwibmFtZXMiOlsiU3Vic2NyaXB0aW9uTWFuYWdlciIsImNvbnN0cnVjdG9yIiwid2Vic29ja2V0Q2xpZW50IiwiX3dlYnNvY2tldENsaWVudCIsIl9zdWJzY3JpcHRpb25zIiwiX2F3YWl0aW5nUmVzdWJzY3JpYmUiLCJpc0FjY291bnRTdWJzY3JpYmluZyIsImFjY291bnRJZCIsImluc3RhbmNlTnVtYmVyIiwidW5kZWZpbmVkIiwiaW5jbHVkZXMiLCJrZXkiLCJzdGFydHNXaXRoIiwiaXNEaXNjb25uZWN0ZWRSZXRyeU1vZGUiLCJpbnN0YW5jZUlkIiwic3Vic2NyaWJlIiwiY2xpZW50Iiwic2hvdWxkUmV0cnkiLCJ0YXNrIiwid2FpdFRhc2siLCJmdXR1cmUiLCJzdWJzY3JpYmVSZXRyeUludGVydmFsSW5TZWNvbmRzIiwicmVzb2x2ZVN1YnNjcmliZSIsInByb21pc2UiLCJyZXMiLCJyZXNvbHZlIiwic3Vic2NyaWJlVGFzayIsImVyciIsIm5hbWUiLCJzb2NrZXRJbnN0YW5jZUluZGV4Iiwic29ja2V0SW5zdGFuY2VzQnlBY2NvdW50cyIsIm1ldGFkYXRhIiwidHlwZSIsImNvbnNvbGUiLCJsb2ciLCJsb2NrU29ja2V0SW5zdGFuY2UiLCJyZXRyeVRpbWUiLCJEYXRlIiwicmVjb21tZW5kZWRSZXRyeVRpbWUiLCJnZXRUaW1lIiwibm93Iiwic2V0VGltZW91dCIsInJldHJ5SW50ZXJ2YWwiLCJNYXRoIiwibWluIiwic3Vic2NyaWJlUHJvbWlzZSIsInJlc3VsdCIsImNhbmNlbFN1YnNjcmliZSIsInN1YnNjcmlwdGlvbiIsImNsZWFyVGltZW91dCIsImNhbmNlbEFjY291bnQiLCJmaWx0ZXIiLCJvblRpbWVvdXQiLCJjb25uZWN0ZWQiLCJvbkRpc2Nvbm5lY3RlZCIsIm1heCIsInJhbmRvbSIsIm9uUmVjb25uZWN0ZWQiLCJyZWNvbm5lY3RBY2NvdW50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QkFBTCxDQUEwQkUsU0FBMUIsSUFBdUMsSUFBdkM7QUFDQSxtQkFBTSxLQUFLRCxvQkFBTCxDQUEwQkMsU0FBMUIsQ0FBTixFQUE0QztBQUMxQyxvQkFBTSxzQkFBWWlCLE9BQU9pQixXQUFXakIsR0FBWCxFQUFnQixJQUFoQixDQUFuQixDQUFOO0FBQ0Q7QUFDRCxtQkFBTyxLQUFLbkIsb0JBQUwsQ0FBMEJFLFNBQTFCLENBQVA7QUFDQSxrQkFBTSxzQkFBWWlCLE9BQU9pQixXQUFXakIsR0FBWCxFQUFnQm1CLEtBQUthLE1BQUwsS0FBZ0IsSUFBaEMsQ0FBbkIsQ0FBTjtBQUNBLGlCQUFLekMsU0FBTCxDQUFlUixTQUFmO0FBQ0Q7QUFDRixTQVZELENBVUUsT0FBT29CLEdBQVAsRUFBWTtBQUNaTSxrQkFBUTRCLEtBQVIsQ0FBYyxNQUFPLElBQUl4QixJQUFKLEVBQUQsQ0FBYXlCLFdBQWIsRUFBTixHQUFtQyxZQUFuQyxHQUFrRHZELFNBQWxELEdBQ2QsMEJBREEsRUFDNEJvQixHQUQ1QjtBQUVEO0FBQ0YsT0FmRDtBQWdCRCxLQXhCRCxDQXdCRSxPQUFPQSxHQUFQLEVBQVk7QUFDWk0sY0FBUTRCLEtBQVIsQ0FBYyxNQUFPLElBQUl4QixJQUFKLEVBQUQsQ0FBYXlCLFdBQWIsRUFBTixHQUFtQyx5REFBakQsRUFBNEduQyxHQUE1RztBQUNEO0FBQ0Y7QUExTXNDO2tCQUFwQjNCLG1CIiwiZmlsZSI6InN1YnNjcmlwdGlvbk1hbmFnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFN1YnNjcmlwdGlvbiBtYW5hZ2VyIHRvIGhhbmRsZSBhY2NvdW50IHN1YnNjcmlwdGlvbiBsb2dpY1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdWJzY3JpcHRpb25NYW5hZ2VyIHtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyB0aGUgc3Vic2NyaXB0aW9uIG1hbmFnZXJcbiAgICogQHBhcmFtIHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50fSB3ZWJzb2NrZXRDbGllbnQgd2Vic29ja2V0IGNsaWVudCB0byB1c2UgZm9yIHNlbmRpbmcgcmVxdWVzdHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdlYnNvY2tldENsaWVudCkge1xuICAgIHRoaXMuX3dlYnNvY2tldENsaWVudCA9IHdlYnNvY2tldENsaWVudDtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0ge307XG4gICAgdGhpcy5fYXdhaXRpbmdSZXN1YnNjcmliZSA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhbiBhY2NvdW50IGlzIGN1cnJlbnRseSBzdWJzY3JpYmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gd2hldGhlciBhbiBhY2NvdW50IGlzIGN1cnJlbnRseSBzdWJzY3JpYmluZ1xuICAgKi9cbiAgaXNBY2NvdW50U3Vic2NyaWJpbmcoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcikge1xuICAgIGlmKGluc3RhbmNlTnVtYmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zKS5pbmNsdWRlcyhhY2NvdW50SWQgKyAnOicgKyBpbnN0YW5jZU51bWJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zKSkge1xuICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoYWNjb3VudElkKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhbiBpbnN0YW5jZSBpcyBpbiBkaXNjb25uZWN0ZWQgcmV0cnkgbW9kZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gd2hldGhlciBhbiBhY2NvdW50IGlzIGN1cnJlbnRseSBzdWJzY3JpYmluZ1xuICAgKi9cbiAgaXNEaXNjb25uZWN0ZWRSZXRyeU1vZGUoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcikge1xuICAgIGxldCBpbnN0YW5jZUlkID0gYWNjb3VudElkICsgJzonICsgKGluc3RhbmNlTnVtYmVyIHx8IDApO1xuICAgIHJldHVybiB0aGlzLl9zdWJzY3JpcHRpb25zW2luc3RhbmNlSWRdID8gdGhpcy5fc3Vic2NyaXB0aW9uc1tpbnN0YW5jZUlkXS5pc0Rpc2Nvbm5lY3RlZFJldHJ5TW9kZSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlcyB0byBzZW5kIHN1YnNjcmliZSByZXF1ZXN0cyB0byBhbiBhY2NvdW50IHVudGlsIGNhbmNlbGxlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRGlzY29ubmVjdGVkUmV0cnlNb2RlIHdoZXRoZXIgdG8gc3RhcnQgc3Vic2NyaXB0aW9uIGluIGRpc2Nvbm5lY3RlZCByZXRyeVxuICAgKiBtb2RlLiBTdWJzY3JpcHRpb24gdGFzayBpbiBkaXNjb25uZWN0ZWQgbW9kZSB3aWxsIGJlIGltbWVkaWF0ZWx5IHJlcGxhY2VkIHdoZW4gdGhlIHN0YXR1cyBwYWNrZXQgaXMgcmVjZWl2ZWRcbiAgICovXG4gIGFzeW5jIHN1YnNjcmliZShhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyLCBpc0Rpc2Nvbm5lY3RlZFJldHJ5TW9kZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5fd2Vic29ja2V0Q2xpZW50O1xuICAgIGxldCBpbnN0YW5jZUlkID0gYWNjb3VudElkICsgJzonICsgKGluc3RhbmNlTnVtYmVyIHx8IDApO1xuICAgIGlmKCF0aGlzLl9zdWJzY3JpcHRpb25zW2luc3RhbmNlSWRdKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zW2luc3RhbmNlSWRdID0ge1xuICAgICAgICBzaG91bGRSZXRyeTogdHJ1ZSxcbiAgICAgICAgdGFzazogbnVsbCxcbiAgICAgICAgd2FpdFRhc2s6IG51bGwsXG4gICAgICAgIGZ1dHVyZTogbnVsbCxcbiAgICAgICAgaXNEaXNjb25uZWN0ZWRSZXRyeU1vZGVcbiAgICAgIH07XG4gICAgICBsZXQgc3Vic2NyaWJlUmV0cnlJbnRlcnZhbEluU2Vjb25kcyA9IDM7XG4gICAgICB3aGlsZSh0aGlzLl9zdWJzY3JpcHRpb25zW2luc3RhbmNlSWRdLnNob3VsZFJldHJ5KSB7XG4gICAgICAgIGxldCByZXNvbHZlU3Vic2NyaWJlO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zW2luc3RhbmNlSWRdLnRhc2sgPSB7cHJvbWlzZTogbmV3IFByb21pc2UoKHJlcykgPT4ge1xuICAgICAgICAgIHJlc29sdmVTdWJzY3JpYmUgPSByZXM7XG4gICAgICAgIH0pfTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uc1tpbnN0YW5jZUlkXS50YXNrLnJlc29sdmUgPSByZXNvbHZlU3Vic2NyaWJlO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5uZXItZGVjbGFyYXRpb25zXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHN1YnNjcmliZVRhc2soKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5zdWJzY3JpYmUoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcik7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZihlcnIubmFtZSA9PT0gJ1Rvb01hbnlSZXF1ZXN0c0Vycm9yJykge1xuICAgICAgICAgICAgICBjb25zdCBzb2NrZXRJbnN0YW5jZUluZGV4ID0gY2xpZW50LnNvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbYWNjb3VudElkXTtcbiAgICAgICAgICAgICAgaWYgKGVyci5tZXRhZGF0YS50eXBlID09PSAnTElNSVRfQUNDT1VOVF9TVUJTQ1JJUFRJT05TX1BFUl9VU0VSJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKFsnTElNSVRfQUNDT1VOVF9TVUJTQ1JJUFRJT05TX1BFUl9VU0VSJywgJ0xJTUlUX0FDQ09VTlRfU1VCU0NSSVBUSU9OU19QRVJfU0VSVkVSJywgXG4gICAgICAgICAgICAgICAgJ0xJTUlUX0FDQ09VTlRfU1VCU0NSSVBUSU9OU19QRVJfVVNFUl9QRVJfU0VSVkVSJ10uaW5jbHVkZXMoZXJyLm1ldGFkYXRhLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNsaWVudC5zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2FjY291bnRJZF07XG4gICAgICAgICAgICAgICAgY2xpZW50LmxvY2tTb2NrZXRJbnN0YW5jZShzb2NrZXRJbnN0YW5jZUluZGV4LCBlcnIubWV0YWRhdGEpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5VGltZSA9IG5ldyBEYXRlKGVyci5tZXRhZGF0YS5yZWNvbW1lbmRlZFJldHJ5VGltZSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIGlmIChEYXRlLm5vdygpICsgc3Vic2NyaWJlUmV0cnlJbnRlcnZhbEluU2Vjb25kcyAqIDEwMDAgPCByZXRyeVRpbWUpIHtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgcmV0cnlUaW1lIC0gRGF0ZS5ub3coKSAtXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZVJldHJ5SW50ZXJ2YWxJblNlY29uZHMgKiAxMDAwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmVTdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmVUYXNrKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX3N1YnNjcmlwdGlvbnNbaW5zdGFuY2VJZF0udGFzay5wcm9taXNlO1xuICAgICAgICBpZighdGhpcy5fc3Vic2NyaXB0aW9uc1tpbnN0YW5jZUlkXS5zaG91bGRSZXRyeSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldHJ5SW50ZXJ2YWwgPSBzdWJzY3JpYmVSZXRyeUludGVydmFsSW5TZWNvbmRzO1xuICAgICAgICBzdWJzY3JpYmVSZXRyeUludGVydmFsSW5TZWNvbmRzID0gTWF0aC5taW4oc3Vic2NyaWJlUmV0cnlJbnRlcnZhbEluU2Vjb25kcyAqIDIsIDMwMCk7XG4gICAgICAgIGxldCByZXNvbHZlO1xuICAgICAgICBsZXQgc3Vic2NyaWJlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICAgICAgICByZXNvbHZlID0gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uc1tpbnN0YW5jZUlkXS53YWl0VGFzayA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH0sIHJldHJ5SW50ZXJ2YWwgKiAxMDAwKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uc1tpbnN0YW5jZUlkXS5mdXR1cmUgPSB7cmVzb2x2ZSwgcHJvbWlzZTogc3Vic2NyaWJlUHJvbWlzZX07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX3N1YnNjcmlwdGlvbnNbaW5zdGFuY2VJZF0uZnV0dXJlLnByb21pc2U7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNbaW5zdGFuY2VJZF0uZnV0dXJlID0gbnVsbDtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbnNbaW5zdGFuY2VJZF07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgYWN0aXZlIHN1YnNjcmlwdGlvbiB0YXNrcyBmb3IgYW4gaW5zdGFuY2UgaWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSWQgaW5zdGFuY2UgaWQgdG8gY2FuY2VsIHN1YnNjcmlwdGlvbiB0YXNrIGZvclxuICAgKi9cbiAgY2FuY2VsU3Vic2NyaWJlKGluc3RhbmNlSWQpIHtcbiAgICBpZih0aGlzLl9zdWJzY3JpcHRpb25zW2luc3RhbmNlSWRdKSB7XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb25zW2luc3RhbmNlSWRdO1xuICAgICAgaWYoc3Vic2NyaXB0aW9uLmZ1dHVyZSkge1xuICAgICAgICBzdWJzY3JpcHRpb24uZnV0dXJlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICBjbGVhclRpbWVvdXQoc3Vic2NyaXB0aW9uLndhaXRUYXNrKTtcbiAgICAgIH1cbiAgICAgIGlmKHN1YnNjcmlwdGlvbi50YXNrKSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi50YXNrLnJlc29sdmUoZmFsc2UpO1xuICAgICAgfVxuICAgICAgc3Vic2NyaXB0aW9uLnNob3VsZFJldHJ5ID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgYWN0aXZlIHN1YnNjcmlwdGlvbiB0YXNrcyBmb3IgYW4gYWNjb3VudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWQgdG8gY2FuY2VsIHN1YnNjcmlwdGlvbiB0YXNrcyBmb3JcbiAgICovXG4gIGNhbmNlbEFjY291bnQoYWNjb3VudElkKSB7XG4gICAgZm9yKGxldCBpbnN0YW5jZUlkIG9mIE9iamVjdC5rZXlzKHRoaXMuX3N1YnNjcmlwdGlvbnMpLmZpbHRlcihrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoYWNjb3VudElkKSkpIHtcbiAgICAgIHRoaXMuY2FuY2VsU3Vic2NyaWJlKGluc3RhbmNlSWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIGFjY291bnQgdGltZW91dC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnN0YW5jZU51bWJlciBpbnN0YW5jZSBpbmRleCBudW1iZXJcbiAgICovXG4gIG9uVGltZW91dChhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyKSB7XG4gICAgaWYodGhpcy5fd2Vic29ja2V0Q2xpZW50LnNvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbYWNjb3VudElkXSAhPT0gdW5kZWZpbmVkICYmIFxuICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmNvbm5lY3RlZCh0aGlzLl93ZWJzb2NrZXRDbGllbnQuc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1thY2NvdW50SWRdKSkge1xuICAgICAgdGhpcy5zdWJzY3JpYmUoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlciwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBjb25uZWN0aW9uIHRvIE1ldGFUcmFkZXIgdGVybWluYWwgdGVybWluYXRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKi9cbiAgYXN5bmMgb25EaXNjb25uZWN0ZWQoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcikge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgTWF0aC5tYXgoTWF0aC5yYW5kb20oKSAqIDUsIDEpICogMTAwMCkpO1xuICAgIGlmKHRoaXMuX3dlYnNvY2tldENsaWVudC5zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2FjY291bnRJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zdWJzY3JpYmUoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlciwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBjb25uZWN0aW9uIHRvIE1ldGFBcGkgd2Vic29ja2V0IEFQSSByZXN0b3JlZCBhZnRlciBhIGRpc2Nvbm5lY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzb2NrZXRJbnN0YW5jZUluZGV4IHNvY2tldCBpbnN0YW5jZSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfSByZWNvbm5lY3RBY2NvdW50SWRzIGFjY291bnQgaWRzIHRvIHJlY29ubmVjdFxuICAgKi9cbiAgb25SZWNvbm5lY3RlZChzb2NrZXRJbnN0YW5jZUluZGV4LCByZWNvbm5lY3RBY2NvdW50SWRzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNvY2tldEluc3RhbmNlc0J5QWNjb3VudHMgPSB0aGlzLl93ZWJzb2NrZXRDbGllbnQuc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50cztcbiAgICAgIGZvcihsZXQgaW5zdGFuY2VJZCBvZiBPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zKSl7XG4gICAgICAgIGNvbnN0IGFjY291bnRJZCA9IGluc3RhbmNlSWQuc3BsaXQoJzonKVswXTtcbiAgICAgICAgaWYgKHNvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbYWNjb3VudElkXSA9PT0gc29ja2V0SW5zdGFuY2VJbmRleCkge1xuICAgICAgICAgIHRoaXMuY2FuY2VsU3Vic2NyaWJlKGluc3RhbmNlSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWNvbm5lY3RBY2NvdW50SWRzLmZvckVhY2goYXN5bmMgYWNjb3VudElkID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZighdGhpcy5fYXdhaXRpbmdSZXN1YnNjcmliZVthY2NvdW50SWRdKSB7XG4gICAgICAgICAgICB0aGlzLl9hd2FpdGluZ1Jlc3Vic2NyaWJlW2FjY291bnRJZF0gPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUodGhpcy5pc0FjY291bnRTdWJzY3JpYmluZyhhY2NvdW50SWQpKSB7XG4gICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgMTAwMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2F3YWl0aW5nUmVzdWJzY3JpYmVbYWNjb3VudElkXTtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgTWF0aC5yYW5kb20oKSAqIDUwMDApKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlKGFjY291bnRJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdbJyArIChuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpICsgJ10gQWNjb3VudCAnICsgYWNjb3VudElkICsgXG4gICAgICAgICAgJyByZXN1YnNjcmliZSB0YXNrIGZhaWxlZCcsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignWycgKyAobmV3IERhdGUoKSkudG9JU09TdHJpbmcoKSArICddIEZhaWxlZCB0byBwcm9jZXNzIHN1YnNjcmliZSBtYW5hZ2VyIHJlY29ubmVjdGVkIGV2ZW50JywgZXJyKTtcbiAgICB9XG4gIH1cbn0iXX0=
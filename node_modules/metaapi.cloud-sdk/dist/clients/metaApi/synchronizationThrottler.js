'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _timeoutError = require('../timeoutError');

var _timeoutError2 = _interopRequireDefault(_timeoutError);

var _optionsValidator = require('../optionsValidator');

var _optionsValidator2 = _interopRequireDefault(_optionsValidator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Options for synchronization throttler
 * @typedef {Object} SynchronizationThrottlerOpts
 * @property {Number} [maxConcurrentSynchronizations] amount of maximum allowed concurrent synchronizations
 * @property {Number} [queueTimeoutInSeconds] allowed time for a synchronization in queue
 * @property {Number} [synchronizationTimeoutInSeconds] time after which a synchronization slot
 * is freed to be used by another synchronization
 */

/**
 * Synchronization throttler used to limit the amount of concurrent synchronizations to prevent application
 * from being overloaded due to excessive number of synchronisation responses being sent.
 */
class SynchronizationThrottler {

  /**
   * Constructs the synchronization throttler
   * @param {MetaApiWebsocketClient} client MetaApi websocket client
   * @param {Number} socketInstanceIndex index of socket instance that uses the throttler
   * @param {SynchronizationThrottlerOpts} opts synchronization throttler options
   */
  constructor(client, socketInstanceIndex, opts) {
    const validator = new _optionsValidator2.default();
    opts = opts || {};
    this._maxConcurrentSynchronizations = validator.validateNonZero(opts.maxConcurrentSynchronizations, 15, 'synchronizationThrottler.maxConcurrentSynchronizations');
    this._queueTimeoutInSeconds = validator.validateNonZero(opts.queueTimeoutInSeconds, 300, 'synchronizationThrottler.queueTimeoutInSeconds');
    this._synchronizationTimeoutInSeconds = validator.validateNonZero(opts.synchronizationTimeoutInSeconds, 10, 'synchronizationThrottler.synchronizationTimeoutInSeconds');
    this._client = client;
    this._socketInstanceIndex = socketInstanceIndex;
    this._synchronizationIds = {};
    this._accountsBySynchronizationIds = {};
    this._synchronizationQueue = [];
    this._removeOldSyncIdsInterval = null;
    this._processQueueInterval = null;
  }

  /**
   * Initializes the synchronization throttler
   */
  start() {
    if (!this._removeOldSyncIdsInterval) {
      this._removeOldSyncIdsInterval = setInterval(() => this._removeOldSyncIdsJob(), 1000);
      this._processQueueInterval = setInterval(() => this._processQueueJob(), 1000);
    }
  }

  /**
   * Deinitializes the throttler
   */
  stop() {
    clearInterval(this._removeOldSyncIdsInterval);
    this._removeOldSyncIdsInterval = null;
    clearInterval(this._processQueueInterval);
    this._processQueueInterval = null;
  }

  async _removeOldSyncIdsJob() {
    const now = Date.now();
    for (let key of (0, _keys2.default)(this._synchronizationIds)) {
      if (now - this._synchronizationIds[key] > this._synchronizationTimeoutInSeconds * 1000) {
        delete this._synchronizationIds[key];
      }
    }
    while (this._synchronizationQueue.length && Date.now() - this._synchronizationQueue[0].queueTime > this._queueTimeoutInSeconds * 1000) {
      this._removeFromQueue(this._synchronizationQueue[0].synchronizationId, 'timeout');
    }
    this._advanceQueue();
  }

  /**
   * Fills a synchronization slot with synchronization id
   * @param {String} synchronizationId synchronization id
   */
  updateSynchronizationId(synchronizationId) {
    if (this._accountsBySynchronizationIds[synchronizationId]) {
      this._synchronizationIds[synchronizationId] = Date.now();
    }
  }

  /**
   * Returns the list of currently synchronizing account ids
   */
  get synchronizingAccounts() {
    const synchronizingAccounts = [];
    (0, _keys2.default)(this._synchronizationIds).forEach(key => {
      const accountData = this._accountsBySynchronizationIds[key];
      if (accountData && !synchronizingAccounts.includes(accountData.accountId)) {
        synchronizingAccounts.push(accountData.accountId);
      }
    });
    return synchronizingAccounts;
  }

  /**
   * Returns the list of currenly active synchronization ids
   * @return {String[]} synchronization ids
   */
  get activeSynchronizationIds() {
    return (0, _keys2.default)(this._accountsBySynchronizationIds);
  }

  /**
   * Returns the amount of maximum allowed concurrent synchronizations
   * @return {number} maximum allowed concurrent synchronizations
   */
  get maxConcurrentSynchronizations() {
    const calculatedMax = Math.max(Math.ceil(this._client.subscribedAccountIds(this._socketInstanceIndex).length / 10), 1);
    return Math.min(calculatedMax, this._maxConcurrentSynchronizations);
  }

  /**
   * Returns flag whether there are free slots for synchronization requests
   * @return {Boolean} flag whether there are free slots for synchronization requests
   */
  get isSynchronizationAvailable() {
    if (this._client.socketInstances.reduce((acc, socketInstance) => acc + socketInstance.synchronizationThrottler.synchronizingAccounts.length, 0) >= this._maxConcurrentSynchronizations) {
      return false;
    }
    return this.synchronizingAccounts.length < this.maxConcurrentSynchronizations;
  }

  /**
   * Removes synchronizations from queue and from the list by parameters
   * @param {String} accountId account id
   * @param {Number} instanceIndex account instance index
   * @param {String} host account host name
   */
  removeIdByParameters(accountId, instanceIndex, host) {
    for (let key of (0, _keys2.default)(this._accountsBySynchronizationIds)) {
      if (this._accountsBySynchronizationIds[key].accountId === accountId && this._accountsBySynchronizationIds[key].instanceIndex === instanceIndex && this._accountsBySynchronizationIds[key].host === host) {
        this.removeSynchronizationId(key);
      }
    }
  }

  /**
   * Removes synchronization id from slots and removes ids for the same account from the queue
   * @param {String} synchronizationId synchronization id
   */
  removeSynchronizationId(synchronizationId) {
    if (this._accountsBySynchronizationIds[synchronizationId]) {
      const accountId = this._accountsBySynchronizationIds[synchronizationId].accountId;
      const instanceIndex = this._accountsBySynchronizationIds[synchronizationId].instanceIndex;
      const host = this._accountsBySynchronizationIds[synchronizationId].host;
      for (let key of (0, _keys2.default)(this._accountsBySynchronizationIds)) {
        if (this._accountsBySynchronizationIds[key].accountId === accountId && this._accountsBySynchronizationIds[key].instanceIndex === instanceIndex && this._accountsBySynchronizationIds[key].host === host) {
          this._removeFromQueue(key, 'cancel');
          delete this._accountsBySynchronizationIds[key];
        }
      }
    }
    if (this._synchronizationIds[synchronizationId]) {
      delete this._synchronizationIds[synchronizationId];
    }
    this._advanceQueue();
  }

  /**
   * Clears synchronization ids on disconnect
   */
  onDisconnect() {
    this._synchronizationQueue.forEach(synchronization => {
      synchronization.resolve('cancel');
    });
    this._synchronizationIds = {};
    this._accountsBySynchronizationIds = {};
    this._synchronizationQueue = [];
    this.stop();
    this.start();
  }

  _advanceQueue() {
    let index = 0;
    while (this.isSynchronizationAvailable && this._synchronizationQueue.length && index < this._synchronizationQueue.length) {
      const queueItem = this._synchronizationQueue[index];
      queueItem.resolve('synchronize');
      this.updateSynchronizationId(queueItem.synchronizationId);
      index++;
    }
  }

  _removeFromQueue(synchronizationId, result) {
    this._synchronizationQueue.forEach((syncItem, i) => {
      if (syncItem.synchronizationId === synchronizationId) {
        syncItem.resolve(result);
      }
    });
    this._synchronizationQueue = this._synchronizationQueue.filter(item => item.synchronizationId !== synchronizationId);
  }

  async _processQueueJob() {
    try {
      while (this._synchronizationQueue.length) {
        const queueItem = this._synchronizationQueue[0];
        await this._synchronizationQueue[0].promise;
        if (this._synchronizationQueue.length && this._synchronizationQueue[0].synchronizationId === queueItem.synchronizationId) {
          this._synchronizationQueue.shift();
        }
      }
    } catch (err) {
      console.log('[' + new Date().toISOString() + '] Error processing queue job', err);
    }
  }

  /**
   * Schedules to send a synchronization request for account
   * @param {String} accountId account id
   * @param {Object} request request to send
   */
  async scheduleSynchronize(accountId, request) {
    const synchronizationId = request.requestId;
    for (let key of (0, _keys2.default)(this._accountsBySynchronizationIds)) {
      if (this._accountsBySynchronizationIds[key].accountId === accountId && this._accountsBySynchronizationIds[key].instanceIndex === request.instanceIndex) {
        this.removeSynchronizationId(key);
      }
    }
    this._accountsBySynchronizationIds[synchronizationId] = { accountId, instanceIndex: request.instanceIndex,
      host: request.host };
    if (!this.isSynchronizationAvailable) {
      let resolve;
      let requestResolve = new _promise2.default(res => {
        resolve = res;
      });
      this._synchronizationQueue.push({
        synchronizationId: synchronizationId,
        promise: requestResolve,
        resolve,
        queueTime: Date.now()
      });
      const result = await requestResolve;
      if (result === 'cancel') {
        return false;
      } else if (result === 'timeout') {
        throw new _timeoutError2.default(`Account ${accountId} synchronization ${synchronizationId}` + ' timed out in synchronization queue');
      }
    }
    this.updateSynchronizationId(synchronizationId);
    await this._client._rpcRequest(accountId, request);
    return true;
  }

}
exports.default = SynchronizationThrottler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9jbGllbnRzL21ldGFBcGkvc3luY2hyb25pemF0aW9uVGhyb3R0bGVyLmVzNiJdLCJuYW1lcyI6WyJTeW5jaHJvbml6YXRpb25UaHJvdHRsZXIiLCJjb25zdHJ1Y3RvciIsImNsaWVudCIsInNvY2tldEluc3RhbmNlSW5kZXgiLCJvcHRzIiwidmFsaWRhdG9yIiwiT3B0aW9uc1ZhbGlkYXRvciIsIl9tYXhDb25jdXJyZW50U3luY2hyb25pemF0aW9ucyIsInZhbGlkYXRlTm9uWmVybyIsIm1heENvbmN1cnJlbnRTeW5jaHJvbml6YXRpb25zIiwiX3F1ZXVlVGltZW91dEluU2Vjb25kcyIsInF1ZXVlVGltZW91dEluU2Vjb25kcyIsIl9zeW5jaHJvbml6YXRpb25UaW1lb3V0SW5TZWNvbmRzIiwic3luY2hyb25pemF0aW9uVGltZW91dEluU2Vjb25kcyIsIl9jbGllbnQiLCJfc29ja2V0SW5zdGFuY2VJbmRleCIsIl9zeW5jaHJvbml6YXRpb25JZHMiLCJfYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkcyIsIl9zeW5jaHJvbml6YXRpb25RdWV1ZSIsIl9yZW1vdmVPbGRTeW5jSWRzSW50ZXJ2YWwiLCJfcHJvY2Vzc1F1ZXVlSW50ZXJ2YWwiLCJzdGFydCIsInNldEludGVydmFsIiwiX3JlbW92ZU9sZFN5bmNJZHNKb2IiLCJfcHJvY2Vzc1F1ZXVlSm9iIiwic3RvcCIsImNsZWFySW50ZXJ2YWwiLCJub3ciLCJEYXRlIiwia2V5IiwibGVuZ3RoIiwicXVldWVUaW1lIiwiX3JlbW92ZUZyb21RdWV1ZSIsInN5bmNocm9uaXphdGlvbklkIiwiX2FkdmFuY2VRdWV1ZSIsInVwZGF0ZVN5bmNocm9uaXphdGlvbklkIiwic3luY2hyb25pemluZ0FjY291bnRzIiwiZm9yRWFjaCIsImFjY291bnREYXRhIiwiaW5jbHVkZXMiLCJhY2NvdW50SWQiLCJwdXNoIiwiYWN0aXZlU3luY2hyb25pemF0aW9uSWRzIiwiY2FsY3VsYXRlZE1heCIsIk1hdGgiLCJtYXgiLCJjZWlsIiwic3Vic2NyaWJlZEFjY291bnRJZHMiLCJtaW4iLCJpc1N5bmNocm9uaXphdGlvbkF2YWlsYWJsZSIsInNvY2tldEluc3RhbmNlcyIsInJlZHVjZSIsImFjYyIsInNvY2tldEluc3RhbmNlIiwic3luY2hyb25pemF0aW9uVGhyb3R0bGVyIiwicmVtb3ZlSWRCeVBhcmFtZXRlcnMiLCJpbnN0YW5jZUluZGV4IiwiaG9zdCIsInJlbW92ZVN5bmNocm9uaXphdGlvbklkIiwib25EaXNjb25uZWN0Iiwic3luY2hyb25pemF0aW9uIiwicmVzb2x2ZSIsImluZGV4IiwicXVldWVJdGVtIiwicmVzdWx0Iiwic3luY0l0ZW0iLCJpIiwiZmlsdGVyIiwiaXRlbSIsInByb21pc2UiLCJzaGlmdCIsImVyciIsImNvbnNvbGUiLCJsb2ciLCJ0b0lTT1N0cmluZyIsInNjaGVkdWxlU3luY2hyb25pemUiLCJyZXF1ZXN0IiwicmVxdWVzdElkIiwicmVxdWVzdFJlc29sdmUiLCJyZXMiLCJUaW1lb3V0RXJyb3IiLCJfcnBjUmVxdWVzdCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7QUFDQTs7Ozs7O0FBRUE7Ozs7Ozs7OztBQVNBOzs7O0FBSWUsTUFBTUEsd0JBQU4sQ0FBK0I7O0FBRTVDOzs7Ozs7QUFNQUMsY0FBWUMsTUFBWixFQUFvQkMsbUJBQXBCLEVBQXlDQyxJQUF6QyxFQUErQztBQUM3QyxVQUFNQyxZQUFZLElBQUlDLDBCQUFKLEVBQWxCO0FBQ0FGLFdBQU9BLFFBQVEsRUFBZjtBQUNBLFNBQUtHLDhCQUFMLEdBQXNDRixVQUFVRyxlQUFWLENBQTBCSixLQUFLSyw2QkFBL0IsRUFBOEQsRUFBOUQsRUFDcEMsd0RBRG9DLENBQXRDO0FBRUEsU0FBS0Msc0JBQUwsR0FBOEJMLFVBQVVHLGVBQVYsQ0FBMEJKLEtBQUtPLHFCQUEvQixFQUFzRCxHQUF0RCxFQUM1QixnREFENEIsQ0FBOUI7QUFFQSxTQUFLQyxnQ0FBTCxHQUF3Q1AsVUFBVUcsZUFBVixDQUEwQkosS0FBS1MsK0JBQS9CLEVBQWdFLEVBQWhFLEVBQ3RDLDBEQURzQyxDQUF4QztBQUVBLFNBQUtDLE9BQUwsR0FBZVosTUFBZjtBQUNBLFNBQUthLG9CQUFMLEdBQTRCWixtQkFBNUI7QUFDQSxTQUFLYSxtQkFBTCxHQUEyQixFQUEzQjtBQUNBLFNBQUtDLDZCQUFMLEdBQXFDLEVBQXJDO0FBQ0EsU0FBS0MscUJBQUwsR0FBNkIsRUFBN0I7QUFDQSxTQUFLQyx5QkFBTCxHQUFpQyxJQUFqQztBQUNBLFNBQUtDLHFCQUFMLEdBQTZCLElBQTdCO0FBQ0Q7O0FBRUQ7OztBQUdBQyxVQUFRO0FBQ04sUUFBRyxDQUFDLEtBQUtGLHlCQUFULEVBQW9DO0FBQ2xDLFdBQUtBLHlCQUFMLEdBQWlDRyxZQUFZLE1BQU0sS0FBS0Msb0JBQUwsRUFBbEIsRUFBK0MsSUFBL0MsQ0FBakM7QUFDQSxXQUFLSCxxQkFBTCxHQUE2QkUsWUFBWSxNQUFNLEtBQUtFLGdCQUFMLEVBQWxCLEVBQTJDLElBQTNDLENBQTdCO0FBQ0Q7QUFDRjs7QUFFRDs7O0FBR0FDLFNBQU87QUFDTEMsa0JBQWMsS0FBS1AseUJBQW5CO0FBQ0EsU0FBS0EseUJBQUwsR0FBaUMsSUFBakM7QUFDQU8sa0JBQWMsS0FBS04scUJBQW5CO0FBQ0EsU0FBS0EscUJBQUwsR0FBNkIsSUFBN0I7QUFDRDs7QUFFRCxRQUFNRyxvQkFBTixHQUE2QjtBQUMzQixVQUFNSSxNQUFNQyxLQUFLRCxHQUFMLEVBQVo7QUFDQSxTQUFLLElBQUlFLEdBQVQsSUFBZ0Isb0JBQVksS0FBS2IsbUJBQWpCLENBQWhCLEVBQXVEO0FBQ3JELFVBQUtXLE1BQU0sS0FBS1gsbUJBQUwsQ0FBeUJhLEdBQXpCLENBQVAsR0FBd0MsS0FBS2pCLGdDQUFMLEdBQXdDLElBQXBGLEVBQTBGO0FBQ3hGLGVBQU8sS0FBS0ksbUJBQUwsQ0FBeUJhLEdBQXpCLENBQVA7QUFDRDtBQUNGO0FBQ0QsV0FBTyxLQUFLWCxxQkFBTCxDQUEyQlksTUFBM0IsSUFBc0NGLEtBQUtELEdBQUwsS0FBYSxLQUFLVCxxQkFBTCxDQUEyQixDQUEzQixFQUE4QmEsU0FBNUMsR0FDeEMsS0FBS3JCLHNCQUFMLEdBQThCLElBRGxDLEVBQ3dDO0FBQ3RDLFdBQUtzQixnQkFBTCxDQUFzQixLQUFLZCxxQkFBTCxDQUEyQixDQUEzQixFQUE4QmUsaUJBQXBELEVBQXVFLFNBQXZFO0FBQ0Q7QUFDRCxTQUFLQyxhQUFMO0FBQ0Q7O0FBRUQ7Ozs7QUFJQUMsMEJBQXdCRixpQkFBeEIsRUFBMkM7QUFDekMsUUFBRyxLQUFLaEIsNkJBQUwsQ0FBbUNnQixpQkFBbkMsQ0FBSCxFQUEwRDtBQUN4RCxXQUFLakIsbUJBQUwsQ0FBeUJpQixpQkFBekIsSUFBOENMLEtBQUtELEdBQUwsRUFBOUM7QUFDRDtBQUNGOztBQUVEOzs7QUFHQSxNQUFJUyxxQkFBSixHQUE0QjtBQUMxQixVQUFNQSx3QkFBd0IsRUFBOUI7QUFDQSx3QkFBWSxLQUFLcEIsbUJBQWpCLEVBQXNDcUIsT0FBdEMsQ0FBOENSLE9BQU87QUFDbkQsWUFBTVMsY0FBYyxLQUFLckIsNkJBQUwsQ0FBbUNZLEdBQW5DLENBQXBCO0FBQ0EsVUFBR1MsZUFBZSxDQUFDRixzQkFBc0JHLFFBQXRCLENBQStCRCxZQUFZRSxTQUEzQyxDQUFuQixFQUEwRTtBQUN4RUosOEJBQXNCSyxJQUF0QixDQUEyQkgsWUFBWUUsU0FBdkM7QUFDRDtBQUNGLEtBTEQ7QUFNQSxXQUFPSixxQkFBUDtBQUNEOztBQUVEOzs7O0FBSUEsTUFBSU0sd0JBQUosR0FBK0I7QUFDN0IsV0FBTyxvQkFBWSxLQUFLekIsNkJBQWpCLENBQVA7QUFDRDs7QUFFRDs7OztBQUlBLE1BQUlSLDZCQUFKLEdBQW9DO0FBQ2xDLFVBQU1rQyxnQkFBZ0JDLEtBQUtDLEdBQUwsQ0FBU0QsS0FBS0UsSUFBTCxDQUM3QixLQUFLaEMsT0FBTCxDQUFhaUMsb0JBQWIsQ0FBa0MsS0FBS2hDLG9CQUF2QyxFQUE2RGUsTUFBN0QsR0FBc0UsRUFEekMsQ0FBVCxFQUN1RCxDQUR2RCxDQUF0QjtBQUVBLFdBQU9jLEtBQUtJLEdBQUwsQ0FBU0wsYUFBVCxFQUF3QixLQUFLcEMsOEJBQTdCLENBQVA7QUFDRDs7QUFFRDs7OztBQUlBLE1BQUkwQywwQkFBSixHQUFpQztBQUMvQixRQUFJLEtBQUtuQyxPQUFMLENBQWFvQyxlQUFiLENBQTZCQyxNQUE3QixDQUFvQyxDQUFDQyxHQUFELEVBQU1DLGNBQU4sS0FDdENELE1BQU1DLGVBQWVDLHdCQUFmLENBQXdDbEIscUJBQXhDLENBQThETixNQURsRSxFQUMwRSxDQUQxRSxLQUVGLEtBQUt2Qiw4QkFGUCxFQUV1QztBQUNyQyxhQUFPLEtBQVA7QUFDRDtBQUNELFdBQU8sS0FBSzZCLHFCQUFMLENBQTJCTixNQUEzQixHQUFvQyxLQUFLckIsNkJBQWhEO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BOEMsdUJBQXFCZixTQUFyQixFQUFnQ2dCLGFBQWhDLEVBQStDQyxJQUEvQyxFQUFxRDtBQUNuRCxTQUFLLElBQUk1QixHQUFULElBQWdCLG9CQUFZLEtBQUtaLDZCQUFqQixDQUFoQixFQUFpRTtBQUMvRCxVQUFHLEtBQUtBLDZCQUFMLENBQW1DWSxHQUFuQyxFQUF3Q1csU0FBeEMsS0FBc0RBLFNBQXRELElBQ0MsS0FBS3ZCLDZCQUFMLENBQW1DWSxHQUFuQyxFQUF3QzJCLGFBQXhDLEtBQTBEQSxhQUQzRCxJQUVDLEtBQUt2Qyw2QkFBTCxDQUFtQ1ksR0FBbkMsRUFBd0M0QixJQUF4QyxLQUFpREEsSUFGckQsRUFFMkQ7QUFDekQsYUFBS0MsdUJBQUwsQ0FBNkI3QixHQUE3QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7OztBQUlBNkIsMEJBQXdCekIsaUJBQXhCLEVBQTJDO0FBQ3pDLFFBQUksS0FBS2hCLDZCQUFMLENBQW1DZ0IsaUJBQW5DLENBQUosRUFBMkQ7QUFDekQsWUFBTU8sWUFBWSxLQUFLdkIsNkJBQUwsQ0FBbUNnQixpQkFBbkMsRUFBc0RPLFNBQXhFO0FBQ0EsWUFBTWdCLGdCQUFnQixLQUFLdkMsNkJBQUwsQ0FBbUNnQixpQkFBbkMsRUFBc0R1QixhQUE1RTtBQUNBLFlBQU1DLE9BQU8sS0FBS3hDLDZCQUFMLENBQW1DZ0IsaUJBQW5DLEVBQXNEd0IsSUFBbkU7QUFDQSxXQUFLLElBQUk1QixHQUFULElBQWdCLG9CQUFZLEtBQUtaLDZCQUFqQixDQUFoQixFQUFpRTtBQUMvRCxZQUFHLEtBQUtBLDZCQUFMLENBQW1DWSxHQUFuQyxFQUF3Q1csU0FBeEMsS0FBc0RBLFNBQXRELElBQ0QsS0FBS3ZCLDZCQUFMLENBQW1DWSxHQUFuQyxFQUF3QzJCLGFBQXhDLEtBQTBEQSxhQUR6RCxJQUVELEtBQUt2Qyw2QkFBTCxDQUFtQ1ksR0FBbkMsRUFBd0M0QixJQUF4QyxLQUFpREEsSUFGbkQsRUFFeUQ7QUFDdkQsZUFBS3pCLGdCQUFMLENBQXNCSCxHQUF0QixFQUEyQixRQUEzQjtBQUNBLGlCQUFPLEtBQUtaLDZCQUFMLENBQW1DWSxHQUFuQyxDQUFQO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsUUFBRyxLQUFLYixtQkFBTCxDQUF5QmlCLGlCQUF6QixDQUFILEVBQWdEO0FBQzlDLGFBQU8sS0FBS2pCLG1CQUFMLENBQXlCaUIsaUJBQXpCLENBQVA7QUFDRDtBQUNELFNBQUtDLGFBQUw7QUFDRDs7QUFFRDs7O0FBR0F5QixpQkFBZTtBQUNiLFNBQUt6QyxxQkFBTCxDQUEyQm1CLE9BQTNCLENBQW1DdUIsbUJBQW1CO0FBQ3BEQSxzQkFBZ0JDLE9BQWhCLENBQXdCLFFBQXhCO0FBQ0QsS0FGRDtBQUdBLFNBQUs3QyxtQkFBTCxHQUEyQixFQUEzQjtBQUNBLFNBQUtDLDZCQUFMLEdBQXFDLEVBQXJDO0FBQ0EsU0FBS0MscUJBQUwsR0FBNkIsRUFBN0I7QUFDQSxTQUFLTyxJQUFMO0FBQ0EsU0FBS0osS0FBTDtBQUNEOztBQUVEYSxrQkFBZ0I7QUFDZCxRQUFJNEIsUUFBUSxDQUFaO0FBQ0EsV0FBTSxLQUFLYiwwQkFBTCxJQUFtQyxLQUFLL0IscUJBQUwsQ0FBMkJZLE1BQTlELElBQ0ZnQyxRQUFRLEtBQUs1QyxxQkFBTCxDQUEyQlksTUFEdkMsRUFDK0M7QUFDN0MsWUFBTWlDLFlBQVksS0FBSzdDLHFCQUFMLENBQTJCNEMsS0FBM0IsQ0FBbEI7QUFDQUMsZ0JBQVVGLE9BQVYsQ0FBa0IsYUFBbEI7QUFDQSxXQUFLMUIsdUJBQUwsQ0FBNkI0QixVQUFVOUIsaUJBQXZDO0FBQ0E2QjtBQUNEO0FBQ0Y7O0FBRUQ5QixtQkFBaUJDLGlCQUFqQixFQUFvQytCLE1BQXBDLEVBQTRDO0FBQzFDLFNBQUs5QyxxQkFBTCxDQUEyQm1CLE9BQTNCLENBQW1DLENBQUM0QixRQUFELEVBQVdDLENBQVgsS0FBaUI7QUFDbEQsVUFBR0QsU0FBU2hDLGlCQUFULEtBQStCQSxpQkFBbEMsRUFBcUQ7QUFDbkRnQyxpQkFBU0osT0FBVCxDQUFpQkcsTUFBakI7QUFDRDtBQUNGLEtBSkQ7QUFLQSxTQUFLOUMscUJBQUwsR0FBNkIsS0FBS0EscUJBQUwsQ0FBMkJpRCxNQUEzQixDQUFrQ0MsUUFDN0RBLEtBQUtuQyxpQkFBTCxLQUEyQkEsaUJBREEsQ0FBN0I7QUFFRDs7QUFFRCxRQUFNVCxnQkFBTixHQUF5QjtBQUN2QixRQUFJO0FBQ0YsYUFBTyxLQUFLTixxQkFBTCxDQUEyQlksTUFBbEMsRUFBMEM7QUFDeEMsY0FBTWlDLFlBQVksS0FBSzdDLHFCQUFMLENBQTJCLENBQTNCLENBQWxCO0FBQ0EsY0FBTSxLQUFLQSxxQkFBTCxDQUEyQixDQUEzQixFQUE4Qm1ELE9BQXBDO0FBQ0EsWUFBRyxLQUFLbkQscUJBQUwsQ0FBMkJZLE1BQTNCLElBQXFDLEtBQUtaLHFCQUFMLENBQTJCLENBQTNCLEVBQThCZSxpQkFBOUIsS0FDcEM4QixVQUFVOUIsaUJBRGQsRUFDaUM7QUFDL0IsZUFBS2YscUJBQUwsQ0FBMkJvRCxLQUEzQjtBQUNEO0FBQ0Y7QUFDRixLQVRELENBU0UsT0FBT0MsR0FBUCxFQUFZO0FBQ1pDLGNBQVFDLEdBQVIsQ0FBWSxNQUFPLElBQUk3QyxJQUFKLEVBQUQsQ0FBYThDLFdBQWIsRUFBTixHQUFtQyw4QkFBL0MsRUFBK0VILEdBQS9FO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7QUFLQSxRQUFNSSxtQkFBTixDQUEwQm5DLFNBQTFCLEVBQXFDb0MsT0FBckMsRUFBOEM7QUFDNUMsVUFBTTNDLG9CQUFvQjJDLFFBQVFDLFNBQWxDO0FBQ0EsU0FBSyxJQUFJaEQsR0FBVCxJQUFnQixvQkFBWSxLQUFLWiw2QkFBakIsQ0FBaEIsRUFBaUU7QUFDL0QsVUFBRyxLQUFLQSw2QkFBTCxDQUFtQ1ksR0FBbkMsRUFBd0NXLFNBQXhDLEtBQXNEQSxTQUF0RCxJQUNELEtBQUt2Qiw2QkFBTCxDQUFtQ1ksR0FBbkMsRUFBd0MyQixhQUF4QyxLQUEwRG9CLFFBQVFwQixhQURwRSxFQUNtRjtBQUNqRixhQUFLRSx1QkFBTCxDQUE2QjdCLEdBQTdCO0FBQ0Q7QUFDRjtBQUNELFNBQUtaLDZCQUFMLENBQW1DZ0IsaUJBQW5DLElBQXdELEVBQUNPLFNBQUQsRUFBWWdCLGVBQWVvQixRQUFRcEIsYUFBbkM7QUFDdERDLFlBQU1tQixRQUFRbkIsSUFEd0MsRUFBeEQ7QUFFQSxRQUFHLENBQUMsS0FBS1IsMEJBQVQsRUFBcUM7QUFDbkMsVUFBSVksT0FBSjtBQUNBLFVBQUlpQixpQkFBaUIsc0JBQWFDLEdBQUQsSUFBUztBQUN4Q2xCLGtCQUFVa0IsR0FBVjtBQUNELE9BRm9CLENBQXJCO0FBR0EsV0FBSzdELHFCQUFMLENBQTJCdUIsSUFBM0IsQ0FBZ0M7QUFDOUJSLDJCQUFtQkEsaUJBRFc7QUFFOUJvQyxpQkFBU1MsY0FGcUI7QUFHOUJqQixlQUg4QjtBQUk5QjlCLG1CQUFXSCxLQUFLRCxHQUFMO0FBSm1CLE9BQWhDO0FBTUEsWUFBTXFDLFNBQVMsTUFBTWMsY0FBckI7QUFDQSxVQUFHZCxXQUFXLFFBQWQsRUFBd0I7QUFDdEIsZUFBTyxLQUFQO0FBQ0QsT0FGRCxNQUVPLElBQUdBLFdBQVcsU0FBZCxFQUF5QjtBQUM5QixjQUFNLElBQUlnQixzQkFBSixDQUFrQixXQUFVeEMsU0FBVSxvQkFBbUJQLGlCQUFrQixFQUExRCxHQUN2QixxQ0FETSxDQUFOO0FBRUQ7QUFDRjtBQUNELFNBQUtFLHVCQUFMLENBQTZCRixpQkFBN0I7QUFDQSxVQUFNLEtBQUtuQixPQUFMLENBQWFtRSxXQUFiLENBQXlCekMsU0FBekIsRUFBb0NvQyxPQUFwQyxDQUFOO0FBQ0EsV0FBTyxJQUFQO0FBQ0Q7O0FBbFAyQztrQkFBekI1RSx3QiIsImZpbGUiOiJzeW5jaHJvbml6YXRpb25UaHJvdHRsZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBUaW1lb3V0RXJyb3IgZnJvbSAnLi4vdGltZW91dEVycm9yJztcbmltcG9ydCBPcHRpb25zVmFsaWRhdG9yIGZyb20gJy4uL29wdGlvbnNWYWxpZGF0b3InO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHN5bmNocm9uaXphdGlvbiB0aHJvdHRsZXJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN5bmNocm9uaXphdGlvblRocm90dGxlck9wdHNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbWF4Q29uY3VycmVudFN5bmNocm9uaXphdGlvbnNdIGFtb3VudCBvZiBtYXhpbXVtIGFsbG93ZWQgY29uY3VycmVudCBzeW5jaHJvbml6YXRpb25zXG4gKiBAcHJvcGVydHkge051bWJlcn0gW3F1ZXVlVGltZW91dEluU2Vjb25kc10gYWxsb3dlZCB0aW1lIGZvciBhIHN5bmNocm9uaXphdGlvbiBpbiBxdWV1ZVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzeW5jaHJvbml6YXRpb25UaW1lb3V0SW5TZWNvbmRzXSB0aW1lIGFmdGVyIHdoaWNoIGEgc3luY2hyb25pemF0aW9uIHNsb3RcbiAqIGlzIGZyZWVkIHRvIGJlIHVzZWQgYnkgYW5vdGhlciBzeW5jaHJvbml6YXRpb25cbiAqL1xuXG4vKipcbiAqIFN5bmNocm9uaXphdGlvbiB0aHJvdHRsZXIgdXNlZCB0byBsaW1pdCB0aGUgYW1vdW50IG9mIGNvbmN1cnJlbnQgc3luY2hyb25pemF0aW9ucyB0byBwcmV2ZW50IGFwcGxpY2F0aW9uXG4gKiBmcm9tIGJlaW5nIG92ZXJsb2FkZWQgZHVlIHRvIGV4Y2Vzc2l2ZSBudW1iZXIgb2Ygc3luY2hyb25pc2F0aW9uIHJlc3BvbnNlcyBiZWluZyBzZW50LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTeW5jaHJvbml6YXRpb25UaHJvdHRsZXIge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIHRoZSBzeW5jaHJvbml6YXRpb24gdGhyb3R0bGVyXG4gICAqIEBwYXJhbSB7TWV0YUFwaVdlYnNvY2tldENsaWVudH0gY2xpZW50IE1ldGFBcGkgd2Vic29ja2V0IGNsaWVudFxuICAgKiBAcGFyYW0ge051bWJlcn0gc29ja2V0SW5zdGFuY2VJbmRleCBpbmRleCBvZiBzb2NrZXQgaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSB0aHJvdHRsZXJcbiAgICogQHBhcmFtIHtTeW5jaHJvbml6YXRpb25UaHJvdHRsZXJPcHRzfSBvcHRzIHN5bmNocm9uaXphdGlvbiB0aHJvdHRsZXIgb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IoY2xpZW50LCBzb2NrZXRJbnN0YW5jZUluZGV4LCBvcHRzKSB7XG4gICAgY29uc3QgdmFsaWRhdG9yID0gbmV3IE9wdGlvbnNWYWxpZGF0b3IoKTtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB0aGlzLl9tYXhDb25jdXJyZW50U3luY2hyb25pemF0aW9ucyA9IHZhbGlkYXRvci52YWxpZGF0ZU5vblplcm8ob3B0cy5tYXhDb25jdXJyZW50U3luY2hyb25pemF0aW9ucywgMTUsXG4gICAgICAnc3luY2hyb25pemF0aW9uVGhyb3R0bGVyLm1heENvbmN1cnJlbnRTeW5jaHJvbml6YXRpb25zJyk7XG4gICAgdGhpcy5fcXVldWVUaW1lb3V0SW5TZWNvbmRzID0gdmFsaWRhdG9yLnZhbGlkYXRlTm9uWmVybyhvcHRzLnF1ZXVlVGltZW91dEluU2Vjb25kcywgMzAwLFxuICAgICAgJ3N5bmNocm9uaXphdGlvblRocm90dGxlci5xdWV1ZVRpbWVvdXRJblNlY29uZHMnKTtcbiAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25UaW1lb3V0SW5TZWNvbmRzID0gdmFsaWRhdG9yLnZhbGlkYXRlTm9uWmVybyhvcHRzLnN5bmNocm9uaXphdGlvblRpbWVvdXRJblNlY29uZHMsIDEwLFxuICAgICAgJ3N5bmNocm9uaXphdGlvblRocm90dGxlci5zeW5jaHJvbml6YXRpb25UaW1lb3V0SW5TZWNvbmRzJyk7XG4gICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuX3NvY2tldEluc3RhbmNlSW5kZXggPSBzb2NrZXRJbnN0YW5jZUluZGV4O1xuICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbklkcyA9IHt9O1xuICAgIHRoaXMuX2FjY291bnRzQnlTeW5jaHJvbml6YXRpb25JZHMgPSB7fTtcbiAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25RdWV1ZSA9IFtdO1xuICAgIHRoaXMuX3JlbW92ZU9sZFN5bmNJZHNJbnRlcnZhbCA9IG51bGw7XG4gICAgdGhpcy5fcHJvY2Vzc1F1ZXVlSW50ZXJ2YWwgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBzeW5jaHJvbml6YXRpb24gdGhyb3R0bGVyXG4gICAqL1xuICBzdGFydCgpIHtcbiAgICBpZighdGhpcy5fcmVtb3ZlT2xkU3luY0lkc0ludGVydmFsKSB7XG4gICAgICB0aGlzLl9yZW1vdmVPbGRTeW5jSWRzSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLl9yZW1vdmVPbGRTeW5jSWRzSm9iKCksIDEwMDApO1xuICAgICAgdGhpcy5fcHJvY2Vzc1F1ZXVlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLl9wcm9jZXNzUXVldWVKb2IoKSwgMTAwMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlaW5pdGlhbGl6ZXMgdGhlIHRocm90dGxlclxuICAgKi9cbiAgc3RvcCgpIHtcbiAgICBjbGVhckludGVydmFsKHRoaXMuX3JlbW92ZU9sZFN5bmNJZHNJbnRlcnZhbCk7XG4gICAgdGhpcy5fcmVtb3ZlT2xkU3luY0lkc0ludGVydmFsID0gbnVsbDtcbiAgICBjbGVhckludGVydmFsKHRoaXMuX3Byb2Nlc3NRdWV1ZUludGVydmFsKTtcbiAgICB0aGlzLl9wcm9jZXNzUXVldWVJbnRlcnZhbCA9IG51bGw7XG4gIH1cblxuICBhc3luYyBfcmVtb3ZlT2xkU3luY0lkc0pvYigpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLl9zeW5jaHJvbml6YXRpb25JZHMpKSB7XG4gICAgICBpZiAoKG5vdyAtIHRoaXMuX3N5bmNocm9uaXphdGlvbklkc1trZXldKSA+IHRoaXMuX3N5bmNocm9uaXphdGlvblRpbWVvdXRJblNlY29uZHMgKiAxMDAwKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zeW5jaHJvbml6YXRpb25JZHNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKHRoaXMuX3N5bmNocm9uaXphdGlvblF1ZXVlLmxlbmd0aCAmJiAoRGF0ZS5ub3coKSAtIHRoaXMuX3N5bmNocm9uaXphdGlvblF1ZXVlWzBdLnF1ZXVlVGltZSkgPiBcbiAgICAgICAgdGhpcy5fcXVldWVUaW1lb3V0SW5TZWNvbmRzICogMTAwMCkge1xuICAgICAgdGhpcy5fcmVtb3ZlRnJvbVF1ZXVlKHRoaXMuX3N5bmNocm9uaXphdGlvblF1ZXVlWzBdLnN5bmNocm9uaXphdGlvbklkLCAndGltZW91dCcpO1xuICAgIH1cbiAgICB0aGlzLl9hZHZhbmNlUXVldWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaWxscyBhIHN5bmNocm9uaXphdGlvbiBzbG90IHdpdGggc3luY2hyb25pemF0aW9uIGlkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBzeW5jaHJvbml6YXRpb24gaWRcbiAgICovXG4gIHVwZGF0ZVN5bmNocm9uaXphdGlvbklkKHN5bmNocm9uaXphdGlvbklkKSB7XG4gICAgaWYodGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkc1tzeW5jaHJvbml6YXRpb25JZF0pIHtcbiAgICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbklkc1tzeW5jaHJvbml6YXRpb25JZF0gPSBEYXRlLm5vdygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGN1cnJlbnRseSBzeW5jaHJvbml6aW5nIGFjY291bnQgaWRzXG4gICAqL1xuICBnZXQgc3luY2hyb25pemluZ0FjY291bnRzKCkge1xuICAgIGNvbnN0IHN5bmNocm9uaXppbmdBY2NvdW50cyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX3N5bmNocm9uaXphdGlvbklkcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgYWNjb3VudERhdGEgPSB0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzW2tleV07XG4gICAgICBpZihhY2NvdW50RGF0YSAmJiAhc3luY2hyb25pemluZ0FjY291bnRzLmluY2x1ZGVzKGFjY291bnREYXRhLmFjY291bnRJZCkpIHtcbiAgICAgICAgc3luY2hyb25pemluZ0FjY291bnRzLnB1c2goYWNjb3VudERhdGEuYWNjb3VudElkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3luY2hyb25pemluZ0FjY291bnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgY3VycmVubHkgYWN0aXZlIHN5bmNocm9uaXphdGlvbiBpZHNcbiAgICogQHJldHVybiB7U3RyaW5nW119IHN5bmNocm9uaXphdGlvbiBpZHNcbiAgICovXG4gIGdldCBhY3RpdmVTeW5jaHJvbml6YXRpb25JZHMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2FjY291bnRzQnlTeW5jaHJvbml6YXRpb25JZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFtb3VudCBvZiBtYXhpbXVtIGFsbG93ZWQgY29uY3VycmVudCBzeW5jaHJvbml6YXRpb25zXG4gICAqIEByZXR1cm4ge251bWJlcn0gbWF4aW11bSBhbGxvd2VkIGNvbmN1cnJlbnQgc3luY2hyb25pemF0aW9uc1xuICAgKi9cbiAgZ2V0IG1heENvbmN1cnJlbnRTeW5jaHJvbml6YXRpb25zKCkge1xuICAgIGNvbnN0IGNhbGN1bGF0ZWRNYXggPSBNYXRoLm1heChNYXRoLmNlaWwoXG4gICAgICB0aGlzLl9jbGllbnQuc3Vic2NyaWJlZEFjY291bnRJZHModGhpcy5fc29ja2V0SW5zdGFuY2VJbmRleCkubGVuZ3RoIC8gMTApLCAxKTtcbiAgICByZXR1cm4gTWF0aC5taW4oY2FsY3VsYXRlZE1heCwgdGhpcy5fbWF4Q29uY3VycmVudFN5bmNocm9uaXphdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmxhZyB3aGV0aGVyIHRoZXJlIGFyZSBmcmVlIHNsb3RzIGZvciBzeW5jaHJvbml6YXRpb24gcmVxdWVzdHNcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gZmxhZyB3aGV0aGVyIHRoZXJlIGFyZSBmcmVlIHNsb3RzIGZvciBzeW5jaHJvbml6YXRpb24gcmVxdWVzdHNcbiAgICovXG4gIGdldCBpc1N5bmNocm9uaXphdGlvbkF2YWlsYWJsZSgpIHtcbiAgICBpZiAodGhpcy5fY2xpZW50LnNvY2tldEluc3RhbmNlcy5yZWR1Y2UoKGFjYywgc29ja2V0SW5zdGFuY2UpID0+IFxuICAgICAgYWNjICsgc29ja2V0SW5zdGFuY2Uuc3luY2hyb25pemF0aW9uVGhyb3R0bGVyLnN5bmNocm9uaXppbmdBY2NvdW50cy5sZW5ndGgsIDApID49XG4gICAgICB0aGlzLl9tYXhDb25jdXJyZW50U3luY2hyb25pemF0aW9ucykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zeW5jaHJvbml6aW5nQWNjb3VudHMubGVuZ3RoIDwgdGhpcy5tYXhDb25jdXJyZW50U3luY2hyb25pemF0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHN5bmNocm9uaXphdGlvbnMgZnJvbSBxdWV1ZSBhbmQgZnJvbSB0aGUgbGlzdCBieSBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VJbmRleCBhY2NvdW50IGluc3RhbmNlIGluZGV4XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBob3N0IGFjY291bnQgaG9zdCBuYW1lXG4gICAqL1xuICByZW1vdmVJZEJ5UGFyYW1ldGVycyhhY2NvdW50SWQsIGluc3RhbmNlSW5kZXgsIGhvc3QpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkcykpIHtcbiAgICAgIGlmKHRoaXMuX2FjY291bnRzQnlTeW5jaHJvbml6YXRpb25JZHNba2V5XS5hY2NvdW50SWQgPT09IGFjY291bnRJZCAmJlxuICAgICAgICAgIHRoaXMuX2FjY291bnRzQnlTeW5jaHJvbml6YXRpb25JZHNba2V5XS5pbnN0YW5jZUluZGV4ID09PSBpbnN0YW5jZUluZGV4ICYmXG4gICAgICAgICAgdGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkc1trZXldLmhvc3QgPT09IGhvc3QpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVTeW5jaHJvbml6YXRpb25JZChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHN5bmNocm9uaXphdGlvbiBpZCBmcm9tIHNsb3RzIGFuZCByZW1vdmVzIGlkcyBmb3IgdGhlIHNhbWUgYWNjb3VudCBmcm9tIHRoZSBxdWV1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3luY2hyb25pemF0aW9uSWQgc3luY2hyb25pemF0aW9uIGlkXG4gICAqL1xuICByZW1vdmVTeW5jaHJvbml6YXRpb25JZChzeW5jaHJvbml6YXRpb25JZCkge1xuICAgIGlmICh0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzW3N5bmNocm9uaXphdGlvbklkXSkge1xuICAgICAgY29uc3QgYWNjb3VudElkID0gdGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkc1tzeW5jaHJvbml6YXRpb25JZF0uYWNjb3VudElkO1xuICAgICAgY29uc3QgaW5zdGFuY2VJbmRleCA9IHRoaXMuX2FjY291bnRzQnlTeW5jaHJvbml6YXRpb25JZHNbc3luY2hyb25pemF0aW9uSWRdLmluc3RhbmNlSW5kZXg7XG4gICAgICBjb25zdCBob3N0ID0gdGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkc1tzeW5jaHJvbml6YXRpb25JZF0uaG9zdDtcbiAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzKSkge1xuICAgICAgICBpZih0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzW2tleV0uYWNjb3VudElkID09PSBhY2NvdW50SWQgJiYgXG4gICAgICAgICAgdGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkc1trZXldLmluc3RhbmNlSW5kZXggPT09IGluc3RhbmNlSW5kZXggJiZcbiAgICAgICAgICB0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzW2tleV0uaG9zdCA9PT0gaG9zdCkge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZUZyb21RdWV1ZShrZXksICdjYW5jZWwnKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmKHRoaXMuX3N5bmNocm9uaXphdGlvbklkc1tzeW5jaHJvbml6YXRpb25JZF0pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zeW5jaHJvbml6YXRpb25JZHNbc3luY2hyb25pemF0aW9uSWRdO1xuICAgIH1cbiAgICB0aGlzLl9hZHZhbmNlUXVldWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgc3luY2hyb25pemF0aW9uIGlkcyBvbiBkaXNjb25uZWN0XG4gICAqL1xuICBvbkRpc2Nvbm5lY3QoKSB7XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uUXVldWUuZm9yRWFjaChzeW5jaHJvbml6YXRpb24gPT4ge1xuICAgICAgc3luY2hyb25pemF0aW9uLnJlc29sdmUoJ2NhbmNlbCcpO1xuICAgIH0pO1xuICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbklkcyA9IHt9O1xuICAgIHRoaXMuX2FjY291bnRzQnlTeW5jaHJvbml6YXRpb25JZHMgPSB7fTtcbiAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25RdWV1ZSA9IFtdO1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIHRoaXMuc3RhcnQoKTtcbiAgfVxuXG4gIF9hZHZhbmNlUXVldWUoKSB7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICB3aGlsZSh0aGlzLmlzU3luY2hyb25pemF0aW9uQXZhaWxhYmxlICYmIHRoaXMuX3N5bmNocm9uaXphdGlvblF1ZXVlLmxlbmd0aCAmJiBcbiAgICAgICAgaW5kZXggPCB0aGlzLl9zeW5jaHJvbml6YXRpb25RdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHF1ZXVlSXRlbSA9IHRoaXMuX3N5bmNocm9uaXphdGlvblF1ZXVlW2luZGV4XTtcbiAgICAgIHF1ZXVlSXRlbS5yZXNvbHZlKCdzeW5jaHJvbml6ZScpO1xuICAgICAgdGhpcy51cGRhdGVTeW5jaHJvbml6YXRpb25JZChxdWV1ZUl0ZW0uc3luY2hyb25pemF0aW9uSWQpO1xuICAgICAgaW5kZXgrKztcbiAgICB9XG4gIH1cblxuICBfcmVtb3ZlRnJvbVF1ZXVlKHN5bmNocm9uaXphdGlvbklkLCByZXN1bHQpIHtcbiAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25RdWV1ZS5mb3JFYWNoKChzeW5jSXRlbSwgaSkgPT4ge1xuICAgICAgaWYoc3luY0l0ZW0uc3luY2hyb25pemF0aW9uSWQgPT09IHN5bmNocm9uaXphdGlvbklkKSB7XG4gICAgICAgIHN5bmNJdGVtLnJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25RdWV1ZSA9IHRoaXMuX3N5bmNocm9uaXphdGlvblF1ZXVlLmZpbHRlcihpdGVtID0+IFxuICAgICAgaXRlbS5zeW5jaHJvbml6YXRpb25JZCAhPT0gc3luY2hyb25pemF0aW9uSWQpO1xuICB9XG5cbiAgYXN5bmMgX3Byb2Nlc3NRdWV1ZUpvYigpIHtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKHRoaXMuX3N5bmNocm9uaXphdGlvblF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBxdWV1ZUl0ZW0gPSB0aGlzLl9zeW5jaHJvbml6YXRpb25RdWV1ZVswXTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3luY2hyb25pemF0aW9uUXVldWVbMF0ucHJvbWlzZTtcbiAgICAgICAgaWYodGhpcy5fc3luY2hyb25pemF0aW9uUXVldWUubGVuZ3RoICYmIHRoaXMuX3N5bmNocm9uaXphdGlvblF1ZXVlWzBdLnN5bmNocm9uaXphdGlvbklkID09PSBcbiAgICAgICAgICAgIHF1ZXVlSXRlbS5zeW5jaHJvbml6YXRpb25JZCkge1xuICAgICAgICAgIHRoaXMuX3N5bmNocm9uaXphdGlvblF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbJyArIChuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpICsgJ10gRXJyb3IgcHJvY2Vzc2luZyBxdWV1ZSBqb2InLCBlcnIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTY2hlZHVsZXMgdG8gc2VuZCBhIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGZvciBhY2NvdW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZFxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdCByZXF1ZXN0IHRvIHNlbmRcbiAgICovXG4gIGFzeW5jIHNjaGVkdWxlU3luY2hyb25pemUoYWNjb3VudElkLCByZXF1ZXN0KSB7XG4gICAgY29uc3Qgc3luY2hyb25pemF0aW9uSWQgPSByZXF1ZXN0LnJlcXVlc3RJZDtcbiAgICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkcykpIHtcbiAgICAgIGlmKHRoaXMuX2FjY291bnRzQnlTeW5jaHJvbml6YXRpb25JZHNba2V5XS5hY2NvdW50SWQgPT09IGFjY291bnRJZCAmJlxuICAgICAgICB0aGlzLl9hY2NvdW50c0J5U3luY2hyb25pemF0aW9uSWRzW2tleV0uaW5zdGFuY2VJbmRleCA9PT0gcmVxdWVzdC5pbnN0YW5jZUluZGV4KSB7XG4gICAgICAgIHRoaXMucmVtb3ZlU3luY2hyb25pemF0aW9uSWQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fYWNjb3VudHNCeVN5bmNocm9uaXphdGlvbklkc1tzeW5jaHJvbml6YXRpb25JZF0gPSB7YWNjb3VudElkLCBpbnN0YW5jZUluZGV4OiByZXF1ZXN0Lmluc3RhbmNlSW5kZXgsXG4gICAgICBob3N0OiByZXF1ZXN0Lmhvc3R9O1xuICAgIGlmKCF0aGlzLmlzU3luY2hyb25pemF0aW9uQXZhaWxhYmxlKSB7XG4gICAgICBsZXQgcmVzb2x2ZTtcbiAgICAgIGxldCByZXF1ZXN0UmVzb2x2ZSA9IG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc3luY2hyb25pemF0aW9uUXVldWUucHVzaCh7XG4gICAgICAgIHN5bmNocm9uaXphdGlvbklkOiBzeW5jaHJvbml6YXRpb25JZCxcbiAgICAgICAgcHJvbWlzZTogcmVxdWVzdFJlc29sdmUsXG4gICAgICAgIHJlc29sdmUsXG4gICAgICAgIHF1ZXVlVGltZTogRGF0ZS5ub3coKVxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXF1ZXN0UmVzb2x2ZTtcbiAgICAgIGlmKHJlc3VsdCA9PT0gJ2NhbmNlbCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmKHJlc3VsdCA9PT0gJ3RpbWVvdXQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUaW1lb3V0RXJyb3IoYEFjY291bnQgJHthY2NvdW50SWR9IHN5bmNocm9uaXphdGlvbiAke3N5bmNocm9uaXphdGlvbklkfWAgK1xuICAgICAgICAnIHRpbWVkIG91dCBpbiBzeW5jaHJvbml6YXRpb24gcXVldWUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51cGRhdGVTeW5jaHJvbml6YXRpb25JZChzeW5jaHJvbml6YXRpb25JZCk7XG4gICAgYXdhaXQgdGhpcy5fY2xpZW50Ll9ycGNSZXF1ZXN0KGFjY291bnRJZCwgcmVxdWVzdCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxufSJdfQ==
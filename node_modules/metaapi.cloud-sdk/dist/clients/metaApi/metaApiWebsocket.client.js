'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _randomstring = require('randomstring');

var _randomstring2 = _interopRequireDefault(_randomstring);

var _socket = require('socket.io-client');

var _socket2 = _interopRequireDefault(_socket);

var _timeoutError = require('../timeoutError');

var _timeoutError2 = _interopRequireDefault(_timeoutError);

var _errorHandler = require('../errorHandler');

var _optionsValidator = require('../optionsValidator');

var _optionsValidator2 = _interopRequireDefault(_optionsValidator);

var _notSynchronizedError = require('./notSynchronizedError');

var _notSynchronizedError2 = _interopRequireDefault(_notSynchronizedError);

var _notConnectedError = require('./notConnectedError');

var _notConnectedError2 = _interopRequireDefault(_notConnectedError);

var _tradeError = require('./tradeError');

var _tradeError2 = _interopRequireDefault(_tradeError);

var _packetOrderer = require('./packetOrderer');

var _packetOrderer2 = _interopRequireDefault(_packetOrderer);

var _synchronizationThrottler = require('./synchronizationThrottler');

var _synchronizationThrottler2 = _interopRequireDefault(_synchronizationThrottler);

var _subscriptionManager = require('./subscriptionManager');

var _subscriptionManager2 = _interopRequireDefault(_subscriptionManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let PacketLogger;
if (typeof window === 'undefined') {
  // don't import PacketLogger for browser version
  PacketLogger = require('./packetLogger').default;
}

/**
 * MetaApi websocket API client (see https://metaapi.cloud/docs/client/websocket/overview/)
 */
class MetaApiWebsocketClient {

  /**
   * Constructs MetaApi websocket API client instance
   * @param {HttpClient} httpClient HTTP client
   * @param {String} token authorization token
   * @param {Object} opts websocket client options
   */
  // eslint-disable-next-line complexity
  constructor(httpClient, token, opts) {
    const validator = new _optionsValidator2.default();
    opts = opts || {};
    opts.packetOrderingTimeout = validator.validateNonZero(opts.packetOrderingTimeout, 60, 'packetOrderingTimeout');
    opts.synchronizationThrottler = opts.synchronizationThrottler || {};
    this._httpClient = httpClient;
    this._application = opts.application || 'MetaApi';
    this._domain = opts.domain || 'agiliumtrade.agiliumtrade.ai';
    this._url = `https://mt-client-api-v1.${this._domain}`;
    this._requestTimeout = validator.validateNonZero(opts.requestTimeout, 60, 'requestTimeout') * 1000;
    this._connectTimeout = validator.validateNonZero(opts.connectTimeout, 60, 'connectTimeout') * 1000;
    const retryOpts = opts.retryOpts || {};
    this._retries = validator.validateNumber(retryOpts.retries, 5, 'retryOpts.retries');
    this._minRetryDelayInSeconds = validator.validateNonZero(retryOpts.minDelayInSeconds, 1, 'retryOpts.minDelayInSeconds');
    this._maxRetryDelayInSeconds = validator.validateNonZero(retryOpts.maxDelayInSeconds, 30, 'retryOpts.maxDelayInSeconds');
    this._maxAccountsPerInstance = 100;
    this._subscribeCooldownInSeconds = validator.validateNonZero(retryOpts.subscribeCooldownInSeconds, 600, 'retryOpts.subscribeCooldownInSeconds');
    const eventProcessing = opts.eventProcessing || {};
    this._sequentialEventProcessing = validator.validateBoolean(eventProcessing.sequentialProcessing, false, 'eventProcessing.sequentialProcessing');
    this._useSharedClientApi = validator.validateBoolean(opts.useSharedClientApi, false, 'useSharedClientApi');
    this._token = token;
    this._synchronizationListeners = {};
    this._latencyListeners = [];
    this._reconnectListeners = [];
    this._connectedHosts = {};
    this._socketInstances = [];
    this._socketInstancesByAccounts = {};
    this._synchronizationThrottlerOpts = opts.synchronizationThrottler;
    this._subscriptionManager = new _subscriptionManager2.default(this);
    this._statusTimers = {};
    this._eventQueues = {};
    this._subscribeLock = null;
    this._packetOrderer = new _packetOrderer2.default(this, opts.packetOrderingTimeout);
    if (opts.packetLogger && opts.packetLogger.enabled) {
      this._packetLogger = new PacketLogger(opts.packetLogger);
      this._packetLogger.start();
    }
  }

  /**
   * Restarts the account synchronization process on an out of order packet
   * @param {String} accountId account id
   * @param {Number} instanceIndex instance index
   * @param {Number} expectedSequenceNumber expected s/n
   * @param {Number} actualSequenceNumber actual s/n
   * @param {Object} packet packet data
   * @param {Date} receivedAt time the packet was received at
   */
  onOutOfOrderPacket(accountId, instanceIndex, expectedSequenceNumber, actualSequenceNumber, packet, receivedAt) {
    console.error(`[${new Date().toISOString()}] MetaApi websocket client received an out of order ` + `packet type ${packet.type} for account id ${accountId}:${instanceIndex}. Expected s/n ` + `${expectedSequenceNumber} does not match the actual of ${actualSequenceNumber}`);
    this.ensureSubscribe(accountId, instanceIndex);
  }

  /**
   * Patch server URL for use in unit tests
   * @param {String} url patched server URL
   */
  set url(url) {
    this._url = url;
  }

  /**
   * Returns the list of socket instance dictionaries
   * @return {Object[]} list of socket instance dictionaries
   */
  get socketInstances() {
    return this._socketInstances;
  }

  /**
   * Returns the dictionary of socket instances by account ids
   * @return {Object} dictionary of socket instances by account ids
   */
  get socketInstancesByAccounts() {
    return this._socketInstancesByAccounts;
  }

  /**
   * Returns the list of subscribed account ids
   * @param {String} socketInstanceIndex socket instance index
   * @return {string[]} list of subscribed account ids
   */
  subscribedAccountIds(socketInstanceIndex) {
    const connectedIds = [];
    (0, _keys2.default)(this._connectedHosts).forEach(instanceId => {
      const accountId = instanceId.split(':')[0];
      if (!connectedIds.includes(accountId) && this._socketInstancesByAccounts[accountId] !== undefined && (this._socketInstancesByAccounts[accountId] === socketInstanceIndex || socketInstanceIndex === undefined)) {
        connectedIds.push(accountId);
      }
    });
    return connectedIds;
  }

  /**
   * Returns websocket client connection status
   * @param socketInstanceIndex socket instance index
   * @returns {Boolean} websocket client connection status
   */
  connected(socketInstanceIndex) {
    const instance = this._socketInstances.length > socketInstanceIndex ? this._socketInstances[socketInstanceIndex] : null;
    return instance && instance.socket && instance.socket.connected || false;
  }

  /**
   * Returns list of accounts assigned to instance
   * @param socketInstanceIndex socket instance index
   * @returns 
   */
  getAssignedAccounts(socketInstanceIndex) {
    const accountIds = [];
    (0, _keys2.default)(this._socketInstancesByAccounts).forEach(key => {
      if (this._socketInstancesByAccounts[key] === socketInstanceIndex) {
        accountIds.push(key);
      }
    });
    return accountIds;
  }

  /**
   * Locks subscription for a socket instance based on TooManyRequestsError metadata
   * @param socketInstanceIndex socket instance index
   * @param metadata TooManyRequestsError metadata
   */
  async lockSocketInstance(socketInstanceIndex, metadata) {
    if (metadata.type === 'LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_USER') {
      this._subscribeLock = {
        recommendedRetryTime: metadata.recommendedRetryTime,
        lockedAtAccounts: this.subscribedAccountIds().length,
        lockedAtTime: Date.now()
      };
    } else {
      const subscribedAccounts = this.subscribedAccountIds(socketInstanceIndex);
      if (subscribedAccounts.length === 0) {
        const socketInstance = this.socketInstances[socketInstanceIndex];
        socketInstance.socket.close();
        await this._reconnect(socketInstanceIndex);
      } else {
        const instance = this._socketInstances[socketInstanceIndex];
        instance.subscribeLock = {
          recommendedRetryTime: metadata.recommendedRetryTime,
          type: metadata.type,
          lockedAtAccounts: subscribedAccounts.length
        };
      }
    }
  }

  /**
   * Connects to MetaApi server via socket.io protocol
   * @returns {Promise} promise which resolves when connection is established
   */
  async connect() {
    let clientId = Math.random();
    let resolve, reject;
    let resolved = false;
    let result = new _promise2.default((res, rej) => {
      resolve = res;
      reject = rej;
    });
    const socketInstanceIndex = this._socketInstances.length;
    const instance = {
      id: socketInstanceIndex,
      connected: false,
      requestResolves: {},
      resolved: false,
      connectResult: result,
      sessionId: _randomstring2.default.generate(32),
      isReconnecting: false,
      socket: null,
      synchronizationThrottler: new _synchronizationThrottler2.default(this, socketInstanceIndex, this._synchronizationThrottlerOpts),
      subscribeLock: null
    };
    instance.connected = true;
    this._socketInstances.push(instance);
    const serverUrl = await this._getServerUrl();
    instance.synchronizationThrottler.start();
    const socketInstance = (0, _socket2.default)(serverUrl, {
      path: '/ws',
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      reconnectionAttempts: Infinity,
      timeout: this._connectTimeout,
      extraHeaders: {
        'Client-Id': clientId
      },
      query: {
        'auth-token': this._token,
        clientId: clientId,
        protocol: 2
      }
    });
    let firstConnect = true;
    instance.socket = socketInstance;
    if (this._socketInstances.length === 1) {
      this._packetOrderer.start();
    }
    socketInstance.on('connect', async () => {
      const isSharedClientApi = socketInstance.io.uri === this._url;
      // eslint-disable-next-line no-console
      console.log('[' + new Date().toISOString() + '] MetaApi websocket client connected to the MetaApi server ' + `via ${socketInstance.io.uri} ${isSharedClientApi ? 'shared' : 'dedicated'} server`);
      if (socketInstanceIndex === 0 && firstConnect && !isSharedClientApi) {
        console.log('Please note that it can take up to 3 minutes for your dedicated server to start for the ' + 'first time. During this time it is OK if you see some connection errors.');
        firstConnect = false;
      }
      instance.isReconnecting = false;
      if (!resolved) {
        resolved = true;
        resolve();
      } else {
        await this._fireReconnected(instance.id);
      }
      if (!instance.connected) {
        instance.socket.close();
      }
    });
    socketInstance.on('reconnect', async () => {
      instance.isReconnecting = false;
      await this._fireReconnected(instance.id);
    });
    socketInstance.on('connect_error', err => {
      // eslint-disable-next-line no-console
      console.log('[' + new Date().toISOString() + '] MetaApi websocket client connection error', err);
      instance.isReconnecting = false;
      if (!resolved) {
        resolved = true;
        reject(err);
      }
    });
    socketInstance.on('connect_timeout', timeout => {
      // eslint-disable-next-line no-console
      console.log('[' + new Date().toISOString() + '] MetaApi websocket client connection timeout');
      instance.isReconnecting = false;
      if (!resolved) {
        resolved = true;
        reject(new _timeoutError2.default('MetaApi websocket client connection timed out'));
      }
    });
    socketInstance.on('disconnect', async reason => {
      instance.synchronizationThrottler.onDisconnect();
      // eslint-disable-next-line no-console
      console.log('[' + new Date().toISOString() + '] MetaApi websocket client disconnected from the MetaApi ' + 'server because of ' + reason);
      instance.isReconnecting = false;
      await this._reconnect(instance.id);
    });
    socketInstance.on('error', async error => {
      // eslint-disable-next-line no-console
      console.error('[' + new Date().toISOString() + '] MetaApi websocket client error', error);
      instance.isReconnecting = false;
      await this._reconnect(instance.id);
    });
    socketInstance.on('response', data => {
      if (typeof data === 'string') {
        data = JSON.parse(data);
      }
      let requestResolve = instance.requestResolves[data.requestId] || { resolve: () => {}, reject: () => {} };
      delete instance.requestResolves[data.requestId];
      this._convertIsoTimeToDate(data);
      requestResolve.resolve(data);
      if (data.timestamps && requestResolve.type) {
        data.timestamps.clientProcessingFinished = new Date();
        for (let listener of this._latencyListeners) {
          _promise2.default.resolve().then(() => requestResolve.type === 'trade' ? listener.onTrade(data.accountId, data.timestamps) : listener.onResponse(data.accountId, requestResolve.type, data.timestamps)).catch(error => console.error('[' + new Date().toISOString() + '] Failed to process onResponse ' + 'event for account ' + data.accountId + ', request type ' + requestResolve.type, error));
        }
      }
    });
    socketInstance.on('processingError', data => {
      let requestResolve = instance.requestResolves[data.requestId] || { resolve: () => {}, reject: () => {} };
      delete instance.requestResolves[data.requestId];
      requestResolve.reject(this._convertError(data));
    });
    socketInstance.on('synchronization', async data => {
      if (typeof data === 'string') {
        data = JSON.parse(data);
      }
      if (!data.synchronizationId || instance.synchronizationThrottler.activeSynchronizationIds.includes(data.synchronizationId)) {
        if (this._packetLogger) {
          await this._packetLogger.logPacket(data);
        }
        this._convertIsoTimeToDate(data);
      } else {
        data.type = 'noop';
      }
      this.queuePacket(data);
    });
    return result;
  }

  /**
   * Closes connection to MetaApi server
   */
  close() {
    this._socketInstances.forEach(async instance => {
      if (instance.connected) {
        instance.connected = false;
        await instance.socket.close();
        for (let requestResolve of (0, _values2.default)(instance.requestResolves)) {
          requestResolve.reject(new Error('MetaApi connection closed'));
        }
        instance.requestResolves = {};
      }
    });
    this._synchronizationListeners = {};
    this._latencyListeners = [];
    this._socketInstancesByAccounts = {};
    this._socketInstances = [];
    this._packetOrderer.stop();
  }

  /**
   * MetaTrader account information (see https://metaapi.cloud/docs/client/models/metatraderAccountInformation/)
   * @typedef {Object} MetatraderAccountInformation
   * @property {String} platform platform id (mt4 or mt5)
   * @property {String} broker broker name
   * @property {String} currency account base currency ISO code
   * @property {String} server broker server name
   * @property {Number} balance account balance
   * @property {Number} equity account liquidation value
   * @property {Number} margin used margin
   * @property {Number} freeMargin free margin
   * @property {Number} leverage account leverage coefficient
   * @property {Number} marginLevel margin level calculated as % of equity/margin
   * @property {Boolean} tradeAllowed flag indicating that trading is allowed
   * @property {Boolean} [investorMode] flag indicating that investor password was used (supported for g2 only)
   * @property {String} marginMode margin calculation mode, one of ACCOUNT_MARGIN_MODE_EXCHANGE,
   * ACCOUNT_MARGIN_MODE_RETAIL_NETTING, ACCOUNT_MARGIN_MODE_RETAIL_HEDGING
   * @property {String} name Account owner name
   * @property {Number} login Account login
   * @property {Number} credit Account credit in the deposit currency
   */

  /**
   * Returns account information for a specified MetaTrader account (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readAccountInformation/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @returns {Promise<MetatraderAccountInformation>} promise resolving with account information
   */
  async getAccountInformation(accountId) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getAccountInformation' });
    return response.accountInformation;
  }

  /**
   * MetaTrader position
   * @typedef {Object} MetatraderPosition
   * @property {Number} id position id (ticket number)
   * @property {String} type position type (one of POSITION_TYPE_BUY, POSITION_TYPE_SELL)
   * @property {String} symbol position symbol
   * @property {Number} magic position magic number, identifies the EA which opened the position
   * @property {Date} time time position was opened at
   * @property {String} brokerTime time position was opened at, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {Date} updateTime last position modification time
   * @property {Number} openPrice position open price
   * @property {Number} currentPrice current price
   * @property {Number} currentTickValue current tick value
   * @property {Number} [stopLoss] optional position stop loss price
   * @property {Number} [takeProfit] optional position take profit price
   * @property {Number} volume position volume
   * @property {Number} swap position cumulative swap
   * @property {Number} profit position cumulative profit
   * @property {String} [comment] optional position comment. The sum of the line lengths of the comment and the clientId
   * must be less than or equal to 26. For more information see https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} [clientId] optional client-assigned id. The id value can be assigned when submitting a trade and
   * will be present on position, history orders and history deals related to the trade. You can use this field to bind
   * your trades to objects in your application and then track trade progress. The sum of the line lengths of the
   * comment and the clientId must be less than or equal to 26. For more information see
   * https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {Number} unrealizedProfit profit of the part of the position which is not yet closed, including swap
   * @property {Number} realizedProfit profit of the already closed part, including commissions and swap
   * @property {Number} commission position commission
   * @property {String} reason position opening reason. One of POSITION_REASON_CLIENT, POSITION_REASON_EXPERT,
   * POSITION_REASON_MOBILE, POSITION_REASON_WEB, POSITION_REASON_UNKNOWN. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/positionproperties#enum_position_reason',
   * @property {Number} [accountCurrencyExchangeRate] current exchange rate of account currency into account base
   * currency (USD if you did not override it)
   * @property {String} [originalComment] position original comment (present if possible to restore from history)
   * @property {String} [updatePending] flag indicating that position original comment and clientId was not identified
   * yet and will be updated in a future packet
   */

  /**
   * Returns positions for a specified MetaTrader account (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readPositions/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @returns {Promise<Array<MetatraderPosition>} promise resolving with array of open positions
   */
  async getPositions(accountId) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getPositions' });
    return response.positions;
  }

  /**
   * Returns specific position for a MetaTrader account (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readPosition/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} positionId position id
   * @return {Promise<MetatraderPosition>} promise resolving with MetaTrader position found
   */
  async getPosition(accountId, positionId) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getPosition', positionId });
    return response.position;
  }

  /**
   * MetaTrader order
   * @typedef {Object} MetatraderOrder
   * @property {Number} id order id (ticket number)
   * @property {String} type order type (one of ORDER_TYPE_SELL, ORDER_TYPE_BUY, ORDER_TYPE_BUY_LIMIT,
   * ORDER_TYPE_SELL_LIMIT, ORDER_TYPE_BUY_STOP, ORDER_TYPE_SELL_STOP). See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_type
   * @property {String} state order state one of (ORDER_STATE_STARTED, ORDER_STATE_PLACED, ORDER_STATE_CANCELED,
   * ORDER_STATE_PARTIAL, ORDER_STATE_FILLED, ORDER_STATE_REJECTED, ORDER_STATE_EXPIRED, ORDER_STATE_REQUEST_ADD,
   * ORDER_STATE_REQUEST_MODIFY, ORDER_STATE_REQUEST_CANCEL). See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_state
   * @property {Number} magic order magic number, identifies the EA which created the order
   * @property {Date} time time order was created at
   * @property {String} brokerTime time time order was created at, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {Date} [doneTime] time order was executed or canceled at. Will be specified for
   * completed orders only
   * @property {String} [doneBrokerTime] time order was executed or canceled at, in broker timezone,
   * YYYY-MM-DD HH:mm:ss.SSS format. Will be specified for completed orders only
   * @property {String} symbol order symbol
   * @property {Number} openPrice order open price (market price for market orders, limit price for limit orders or stop
   * price for stop orders)
   * @property {Number} currentPrice current price
   * @property {Number} [stopLoss] order stop loss price
   * @property {Number} [takeProfit] order take profit price
   * @property {Number} volume order requested quantity
   * @property {Number} currentVolume order remaining quantity, i.e. requested quantity - filled quantity
   * @property {String} positionId order position id. Present only if the order has a position attached to it
   * @property {String} [comment] order comment. The sum of the line lengths of the comment and the clientId
   * must be less than or equal to 26. For more information see https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} originalComment optional order original comment (present if possible to restore original comment
   * from history)
   * @property {String} [clientId] client-assigned id. The id value can be assigned when submitting a trade and
   * will be present on position, history orders and history deals related to the trade. You can use this field to bind
   * your trades to objects in your application and then track trade progress. The sum of the line lengths of the
   * comment and the clientId must be less than or equal to 26. For more information see
   * https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} platform platform id (mt4 or mt5)
   * @property {Boolean} [updatePending] flag indicating that order client id and original comment was not
   * identified yet and will be updated in a future synchronization packet
   * @property {String} reason order opening reason. One of ORDER_REASON_CLIENT, ORDER_REASON_MOBILE, ORDER_REASON_WEB,
   * ORDER_REASON_EXPERT, ORDER_REASON_SL, ORDER_REASON_TP, ORDER_REASON_SO, ORDER_REASON_UNKNOWN. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_reason.
   * @property {String} fillingMode order filling mode. One of ORDER_FILLING_FOK, ORDER_FILLING_IOC,
   * ORDER_FILLING_RETURN. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_type_filling.
   * @property {String} expirationType order expiration type. One of ORDER_TIME_GTC, ORDER_TIME_DAY,
   * ORDER_TIME_SPECIFIED, ORDER_TIME_SPECIFIED_DAY. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_type_time
   * @property {Date} expirationTime optional order expiration time
   * @property {Number} [accountCurrencyExchangeRate] current exchange rate of account currency into account base
   * currency (USD if you did not override it)
   * @property {String} [closeByPositionId] identifier of an opposite position used for closing by order
   * ORDER_TYPE_CLOSE_BY
   * @property {Number} [stopLimitPrice] the Limit order price for the StopLimit order
   */

  /**
   * Returns open orders for a specified MetaTrader account (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readOrders/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @return {Promise<Array<MetatraderOrder>>} promise resolving with open MetaTrader orders
   */
  async getOrders(accountId) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getOrders' });
    return response.orders;
  }

  /**
   * Returns specific open order for a MetaTrader account (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readOrder/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} orderId order id (ticket number)
   * @return {Promise<MetatraderOrder>} promise resolving with metatrader order found
   */
  async getOrder(accountId, orderId) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getOrder', orderId });
    return response.order;
  }

  /**
   * MetaTrader history orders search query response
   * @typedef {Object} MetatraderHistoryOrders
   * @property {Array<MetatraderOrder>} historyOrders array of history orders returned
   * @property {Boolean} synchronizing flag indicating that history order initial synchronization is still in progress
   * and thus search results may be incomplete
   */

  /**
   * Returns the history of completed orders for a specific ticket number (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readHistoryOrdersByTicket/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} ticket ticket number (order id)
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */
  async getHistoryOrdersByTicket(accountId, ticket) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getHistoryOrdersByTicket', ticket });
    return {
      historyOrders: response.historyOrders,
      synchronizing: response.synchronizing
    };
  }

  /**
   * Returns the history of completed orders for a specific position id (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readHistoryOrdersByPosition/)
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} positionId position id
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */
  async getHistoryOrdersByPosition(accountId, positionId) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getHistoryOrdersByPosition',
      positionId });
    return {
      historyOrders: response.historyOrders,
      synchronizing: response.synchronizing
    };
  }

  /**
   * Returns the history of completed orders for a specific time range (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readHistoryOrdersByTimeRange/)
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {Date} startTime start of time range, inclusive
   * @param {Date} endTime end of time range, exclusive
   * @param {Number} offset pagination offset, default is 0
   * @param {Number} limit pagination limit, default is 1000
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */
  async getHistoryOrdersByTimeRange(accountId, startTime, endTime, offset = 0, limit = 1000) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getHistoryOrdersByTimeRange',
      startTime, endTime, offset, limit });
    return {
      historyOrders: response.historyOrders,
      synchronizing: response.synchronizing
    };
  }

  /**
   * MetaTrader history deals search query response
   * @typedef {Object} MetatraderDeals
   * @property {Array<MetatraderDeal>} deals array of history deals returned
   * @property {Boolean} synchronizing flag indicating that deal initial synchronization is still in progress
   * and thus search results may be incomplete
   */

  /**
   * MetaTrader deal
   * @typedef {Object} MetatraderDeal
   * @property {String} id deal id (ticket number)
   * @property {String} type deal type (one of DEAL_TYPE_BUY, DEAL_TYPE_SELL, DEAL_TYPE_BALANCE, DEAL_TYPE_CREDIT,
   * DEAL_TYPE_CHARGE, DEAL_TYPE_CORRECTION, DEAL_TYPE_BONUS, DEAL_TYPE_COMMISSION, DEAL_TYPE_COMMISSION_DAILY,
   * DEAL_TYPE_COMMISSION_MONTHLY, DEAL_TYPE_COMMISSION_AGENT_DAILY, DEAL_TYPE_COMMISSION_AGENT_MONTHLY,
   * DEAL_TYPE_INTEREST, DEAL_TYPE_BUY_CANCELED, DEAL_TYPE_SELL_CANCELED, DEAL_DIVIDEND, DEAL_DIVIDEND_FRANKED,
   * DEAL_TAX). See https://www.mql5.com/en/docs/constants/tradingconstants/dealproperties#enum_deal_type
   * @property {String} entryType deal entry type (one of DEAL_ENTRY_IN, DEAL_ENTRY_OUT, DEAL_ENTRY_INOUT,
   * DEAL_ENTRY_OUT_BY). See https://www.mql5.com/en/docs/constants/tradingconstants/dealproperties#enum_deal_entry
   * @property {String} [symbol] symbol deal relates to
   * @property {Number} [magic] deal magic number, identifies the EA which initiated the deal
   * @property {Date} time time the deal was conducted at
   * @property {String} brokerTime time time the deal was conducted at, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {Number} [volume] deal volume
   * @property {Number} [price] the price the deal was conducted at
   * @property {Number} [commission] deal commission
   * @property {Number} [swap] deal swap
   * @property {Number} profit deal profit
   * @property {String} [positionId] id of position the deal relates to
   * @property {String} [orderId] id of order the deal relates to
   * @property {String} [comment] deal comment. The sum of the line lengths of the comment and the clientId
   * must be less than or equal to 26. For more information see https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} [originalComment] deal original comment (present if possible to restore original comment
   * from history)
   * @property {String} [clientId] client-assigned id. The id value can be assigned when submitting a trade and
   * will be present on position, history orders and history deals related to the trade. You can use this field to bind
   * your trades to objects in your application and then track trade progress. The sum of the line lengths of the
   * comment and the clientId must be less than or equal to 26. For more information see
   * https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} platform platform id (mt4 or mt5)
   * @property {Boolean} [updatePending] flag indicating that deal client id and original comment was not
   * identified yet and will be updated in a future synchronization packet
   * @property {String} [reason] optional deal execution reason. One of DEAL_REASON_CLIENT, DEAL_REASON_MOBILE,
   * DEAL_REASON_WEB, DEAL_REASON_EXPERT, DEAL_REASON_SL, DEAL_REASON_TP, DEAL_REASON_SO, DEAL_REASON_ROLLOVER,
   * DEAL_REASON_VMARGIN, DEAL_REASON_SPLIT, DEAL_REASON_UNKNOWN. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/dealproperties#enum_deal_reason.
   * @property {Number} [accountCurrencyExchangeRate] current exchange rate of account currency into account base
   * currency (USD if you did not override it)
   */

  /**
   * Returns history deals with a specific ticket number (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readDealsByTicket/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} ticket ticket number (deal id for MT5 or order id for MT4)
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */
  async getDealsByTicket(accountId, ticket) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getDealsByTicket', ticket });
    return {
      deals: response.deals,
      synchronizing: response.synchronizing
    };
  }

  /**
   * Returns history deals for a specific position id (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readDealsByPosition/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} positionId position id
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */
  async getDealsByPosition(accountId, positionId) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getDealsByPosition', positionId });
    return {
      deals: response.deals,
      synchronizing: response.synchronizing
    };
  }

  /**
   * Returns history deals with for a specific time range (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readDealsByTimeRange/).
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {Date} startTime start of time range, inclusive
   * @param {Date} endTime end of time range, exclusive
   * @param {Number} offset pagination offset, default is 0
   * @param {Number} limit pagination limit, default is 1000
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */
  async getDealsByTimeRange(accountId, startTime, endTime, offset = 0, limit = 1000) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getDealsByTimeRange', startTime,
      endTime, offset, limit });
    return {
      deals: response.deals,
      synchronizing: response.synchronizing
    };
  }

  /**
   * Clears the order and transaction history of a specified application so that it can be synchronized from scratch
   * (see https://metaapi.cloud/docs/client/websocket/api/removeHistory/).
   * @param {String} accountId id of the MetaTrader account to remove history for
   * @param {String} [application] application to remove history for
   * @return {Promise} promise resolving when the history is cleared
   */
  removeHistory(accountId, application) {
    return this._rpcRequest(accountId, { application, type: 'removeHistory' });
  }

  /**
   * Clears the order and transaction history of a specified application and removes the application (see
   * https://metaapi.cloud/docs/client/websocket/api/removeApplication/).
   * @param {String} accountId id of the MetaTrader account to remove history and application for
   * @return {Promise} promise resolving when the history is cleared
   */
  removeApplication(accountId) {
    return this._rpcRequest(accountId, { type: 'removeApplication' });
  }

  /**
   * MetaTrader trade response
   * @typedef {Object} MetatraderTradeResponse
   * @property {Number} numericCode numeric response code, see
   * https://www.mql5.com/en/docs/constants/errorswarnings/enum_trade_return_codes and
   * https://book.mql4.com/appendix/errors. Response codes which indicate success are 0, 10008-10010, 10025. The rest
   * codes are errors
   * @property {String} stringCode string response code, see
   * https://www.mql5.com/en/docs/constants/errorswarnings/enum_trade_return_codes and
   * https://book.mql4.com/appendix/errors. Response codes which indicate success are ERR_NO_ERROR,
   * TRADE_RETCODE_PLACED, TRADE_RETCODE_DONE, TRADE_RETCODE_DONE_PARTIAL, TRADE_RETCODE_NO_CHANGES. The rest codes are
   * errors.
   * @property {String} message human-readable response message
   * @property {String} orderId order id which was created/modified during the trade
   * @property {String} positionId position id which was modified during the trade
   */

  /**
   * Execute a trade on a connected MetaTrader account (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {String} accountId id of the MetaTrader account to execute trade for
   * @param {MetatraderTrade} trade trade to execute (see docs for possible trade types)
   * @returns {Promise<MetatraderTradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  async trade(accountId, trade) {
    let response = await this._rpcRequest(accountId, { type: 'trade', trade });
    response.response = response.response || {};
    response.response.stringCode = response.response.stringCode || response.response.description;
    response.response.numericCode = response.response.numericCode !== undefined ? response.response.numericCode : response.response.error;
    if (['ERR_NO_ERROR', 'TRADE_RETCODE_PLACED', 'TRADE_RETCODE_DONE', 'TRADE_RETCODE_DONE_PARTIAL', 'TRADE_RETCODE_NO_CHANGES'].includes(response.response.stringCode || response.response.description)) {
      return response.response;
    } else {
      throw new _tradeError2.default(response.response.message, response.response.numericCode, response.response.stringCode);
    }
  }

  /**
   * Creates a task that ensures the account gets subscribed to the server
   * @param {String} accountId account id to subscribe
   * @param {Number} [instanceNumber] instance index number
   */
  ensureSubscribe(accountId, instanceNumber) {
    this._subscriptionManager.subscribe(accountId, instanceNumber);
  }

  /**
   * Subscribes to the Metatrader terminal events (see https://metaapi.cloud/docs/client/websocket/api/subscribe/).
   * @param {String} accountId id of the MetaTrader account to subscribe to
   * @param {Number} [instanceNumber] instance index number
   * @returns {Promise} promise which resolves when subscription started
   */
  subscribe(accountId, instanceNumber) {
    return this._rpcRequest(accountId, { type: 'subscribe', instanceIndex: instanceNumber });
  }

  /**
   * Reconnects to the Metatrader terminal (see https://metaapi.cloud/docs/client/websocket/api/reconnect/).
   * @param {String} accountId id of the MetaTrader account to reconnect
   * @returns {Promise} promise which resolves when reconnection started
   */
  reconnect(accountId) {
    return this._rpcRequest(accountId, { type: 'reconnect' });
  }

  /**
   * Requests the terminal to start synchronization process
   * (see https://metaapi.cloud/docs/client/websocket/synchronizing/synchronize/).
   * @param {String} accountId id of the MetaTrader account to synchronize
   * @param {Number} instanceIndex instance index
   * @param {String} host name of host to synchronize with
   * @param {String} synchronizationId synchronization request id
   * @param {Date} startingHistoryOrderTime from what date to start synchronizing history orders from. If not specified,
   * the entire order history will be downloaded.
   * @param {Date} startingDealTime from what date to start deal synchronization from. If not specified, then all
   * history deals will be downloaded.
   * @returns {Promise} promise which resolves when synchronization started
   */
  synchronize(accountId, instanceIndex, host, synchronizationId, startingHistoryOrderTime, startingDealTime) {
    const syncThrottler = this._socketInstances[this._socketInstancesByAccounts[accountId]].synchronizationThrottler;
    return syncThrottler.scheduleSynchronize(accountId, { requestId: synchronizationId,
      type: 'synchronize', startingHistoryOrderTime, startingDealTime, instanceIndex, host });
  }

  /**
   * Waits for server-side terminal state synchronization to complete.
   * (see https://metaapi.cloud/docs/client/websocket/synchronizing/waitSynchronized/).
   * @param {String} accountId id of the MetaTrader account to synchronize
   * @param {Number} instanceNumber instance index number
   * @param {String} applicationPattern MetaApi application regular expression pattern, default is .*
   * @param {Number} timeoutInSeconds timeout in seconds, default is 300 seconds
   * @returns {Promise} promise which resolves when synchronization started
   */
  waitSynchronized(accountId, instanceNumber, applicationPattern, timeoutInSeconds) {
    return this._rpcRequest(accountId, { type: 'waitSynchronized', applicationPattern, timeoutInSeconds,
      instanceIndex: instanceNumber }, timeoutInSeconds + 1);
  }

  /**
   * Market data subscription
   * @typedef {Object} MarketDataSubscription
   * @property {string} type subscription type, one of quotes, candles, ticks, or marketDepth
   * @property {string} [timeframe] when subscription type is candles, defines the timeframe according to which the
   * candles must be generated. Allowed values for MT5 are 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m, 15m, 20m, 30m, 1h, 2h, 3h,
   * 4h, 6h, 8h, 12h, 1d, 1w, 1mn. Allowed values for MT4 are 1m, 5m, 15m 30m, 1h, 4h, 1d, 1w, 1mn
   * @property {number} [intervalInMilliseconds] defines how frequently the terminal will stream data to client. If not
   * set, then the value configured in account will be used
   */

  /**
   * Subscribes on market data of specified symbol (see
   * https://metaapi.cloud/docs/client/websocket/marketDataStreaming/subscribeToMarketData/).
   * @param {String} accountId id of the MetaTrader account
   * @param {Number} instanceNumber instance index number
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataSubscription>} subscriptions array of market data subscription to create or update
   * @returns {Promise} promise which resolves when subscription request was processed
   */
  subscribeToMarketData(accountId, instanceNumber, symbol, subscriptions) {
    return this._rpcRequest(accountId, { type: 'subscribeToMarketData', symbol, subscriptions,
      instanceIndex: instanceNumber });
  }

  /**
   * Market data unsubscription
   * @typedef {Object} MarketDataUnsubscription
   * @property {string} type subscription type, one of quotes, candles, ticks, or marketDepth
   */

  /**
   * Unsubscribes from market data of specified symbol (see
   * https://metaapi.cloud/docs/client/websocket/marketDataStreaming/unsubscribeFromMarketData/).
   * @param {String} accountId id of the MetaTrader account
   * @param {Number} instanceNumber instance index
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataUnsubscription>} subscriptions array of subscriptions to cancel
   * @returns {Promise} promise which resolves when unsubscription request was processed
   */
  unsubscribeFromMarketData(accountId, instanceNumber, symbol, subscriptions) {
    return this._rpcRequest(accountId, { type: 'unsubscribeFromMarketData', symbol, subscriptions,
      instanceIndex: instanceNumber });
  }

  /**
   * Retrieves symbols available on an account (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readSymbols/).
   * @param {String} accountId id of the MetaTrader account to retrieve symbols for
   * @returns {Promise<Array<string>>} promise which resolves when symbols are retrieved
   */
  async getSymbols(accountId) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getSymbols' });
    return response.symbols;
  }

  /**
   * Retrieves specification for a symbol (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readSymbolSpecification/).
   * @param {String} accountId id of the MetaTrader account to retrieve symbol specification for
   * @param {String} symbol symbol to retrieve specification for
   * @returns {Promise<MetatraderSymbolSpecification>} promise which resolves when specification is retrieved
   */
  async getSymbolSpecification(accountId, symbol) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getSymbolSpecification', symbol });
    return response.specification;
  }

  /**
   * Retrieves price for a symbol (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readSymbolPrice/).
   * @param {String} accountId id of the MetaTrader account to retrieve symbol price for
   * @param {String} symbol symbol to retrieve price for
   * @returns {Promise<MetatraderSymbolPrice>} promise which resolves when price is retrieved
   */
  async getSymbolPrice(accountId, symbol) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getSymbolPrice', symbol });
    return response.price;
  }

  /**
   * Retrieves price for a symbol (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readCandle/).
   * @param {string} accountId id of the MetaTrader account to retrieve candle for
   * @param {string} symbol symbol to retrieve candle for
   * @param {string} timeframe defines the timeframe according to which the candle must be generated. Allowed values for
   * MT5 are 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, 1d, 1w, 1mn. Allowed values
   * for MT4 are 1m, 5m, 15m 30m, 1h, 4h, 1d, 1w, 1mn
   * @returns {Promise<MetatraderCandle>} promise which resolves when candle is retrieved
   */
  async getCandle(accountId, symbol, timeframe) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getCandle', symbol, timeframe });
    return response.candle;
  }

  /**
   * Retrieves latest tick for a symbol (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readTick/).
   * @param {string} accountId id of the MetaTrader account to retrieve symbol tick for
   * @param {string} symbol symbol to retrieve tick for
   * @returns {Promise<MetatraderTick>} promise which resolves when tick is retrieved
   */
  async getTick(accountId, symbol) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getTick', symbol });
    return response.tick;
  }

  /**
   * Retrieves latest order book for a symbol (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readBook/).
   * @param {string} accountId id of the MetaTrader account to retrieve symbol order book for
   * @param {string} symbol symbol to retrieve order book for
   * @returns {Promise<MetatraderBook>} promise which resolves when order book is retrieved
   */
  async getBook(accountId, symbol) {
    let response = await this._rpcRequest(accountId, { application: 'RPC', type: 'getBook', symbol });
    return response.book;
  }

  /**
   * Sends client uptime stats to the server.
   * @param {String} accountId id of the MetaTrader account to retrieve symbol price for
   * @param {Object} uptime uptime statistics to send to the server
   * @returns {Promise} promise which resolves when uptime statistics is submitted
   */
  saveUptime(accountId, uptime) {
    return this._rpcRequest(accountId, { type: 'saveUptime', uptime });
  }

  /**
   * Unsubscribe from account (see
   * https://metaapi.cloud/docs/client/websocket/api/synchronizing/unsubscribe).
   * @param {String} accountId id of the MetaTrader account to retrieve symbol price for
   * @returns {Promise} promise which resolves when socket unsubscribed
   */
  async unsubscribe(accountId) {
    this._subscriptionManager.cancelAccount(accountId);
    try {
      await this._rpcRequest(accountId, { type: 'unsubscribe' });
      delete this._socketInstancesByAccounts[accountId];
    } catch (err) {
      if (!(err instanceof _errorHandler.NotFoundError)) {
        throw err;
      }
    }
  }

  /**
   * Adds synchronization listener for specific account
   * @param {String} accountId account id
   * @param {SynchronizationListener} listener synchronization listener to add
   */
  addSynchronizationListener(accountId, listener) {
    let listeners = this._synchronizationListeners[accountId];
    if (!listeners) {
      listeners = [];
      this._synchronizationListeners[accountId] = listeners;
    }
    listeners.push(listener);
  }

  /**
   * Removes synchronization listener for specific account
   * @param {String} accountId account id
   * @param {SynchronizationListener} listener synchronization listener to remove
   */
  removeSynchronizationListener(accountId, listener) {
    let listeners = this._synchronizationListeners[accountId];
    if (!listeners) {
      listeners = [];
    }
    listeners = listeners.filter(l => l !== listener);
    this._synchronizationListeners[accountId] = listeners;
  }

  /**
   * Adds latency listener
   * @param {LatencyListener} listener latency listener to add
   */
  addLatencyListener(listener) {
    this._latencyListeners.push(listener);
  }

  /**
   * Removes latency listener
   * @param {LatencyListener} listener latency listener to remove
   */
  removeLatencyListener(listener) {
    this._latencyListeners = this._latencyListeners.filter(l => l !== listener);
  }

  /**
   * Adds reconnect listener
   * @param {ReconnectListener} listener reconnect listener to add
   * @param {String} accountId account id of listener
   */
  addReconnectListener(listener, accountId) {
    this._reconnectListeners.push({ accountId, listener });
  }

  /**
   * Removes reconnect listener
   * @param {ReconnectListener} listener listener to remove
   */
  removeReconnectListener(listener) {
    this._reconnectListeners = this._reconnectListeners.filter(l => l.listener !== listener);
  }

  /**
   * Removes all listeners. Intended for use in unit tests.
   */
  removeAllListeners() {
    this._synchronizationListeners = {};
    this._reconnectListeners = [];
  }

  /**
   * Queues an account packet for processing
   * @param {Object} packet packet to process
   */
  queuePacket(packet) {
    const accountId = packet.accountId;
    const packets = this._packetOrderer.restoreOrder(packet).filter(p => p.type !== 'noop');
    if (this._sequentialEventProcessing && packet.sequenceNumber !== undefined) {
      const events = packets.map(packetItem => () => _promise2.default.resolve(this._processSynchronizationPacket(packetItem)));
      if (!this._eventQueues[accountId]) {
        this._eventQueues[accountId] = events;
        this._callAccountEvents(accountId);
      } else {
        this._eventQueues[accountId] = this._eventQueues[accountId].concat(events);
      }
    } else {
      packets.forEach(packetItem => this._processSynchronizationPacket(packetItem));
    }
  }

  /**
   * Queues account event for processing
   * @param {String} accountId account id
   * @param {Promise} event event to execute
   */
  queueEvent(accountId, event) {
    if (this._sequentialEventProcessing) {
      if (!this._eventQueues[accountId]) {
        this._eventQueues[accountId] = [event];
        this._callAccountEvents(accountId);
      } else {
        this._eventQueues[accountId].push(event);
      }
    } else {
      event();
    }
  }

  async _callAccountEvents(accountId) {
    if (this._eventQueues[accountId]) {
      while (this._eventQueues[accountId].length) {
        await this._eventQueues[accountId][0]();
        this._eventQueues[accountId].shift();
      }
      delete this._eventQueues[accountId];
    }
  }

  async _reconnect(socketInstanceIndex) {
    const instance = this.socketInstances[socketInstanceIndex];
    if (instance) {
      while (!instance.socket.connected && !instance.isReconnecting && instance.connected) {
        await this._tryReconnect(socketInstanceIndex);
      }
    }
  }

  _tryReconnect(socketInstanceIndex) {
    const instance = this.socketInstances[socketInstanceIndex];
    return new _promise2.default(resolve => setTimeout(async () => {
      if (!instance.socket.connected && !instance.isReconnecting && instance.connected) {
        instance.sessionId = _randomstring2.default.generate(32);
        const clientId = Math.random();
        instance.socket.close();
        instance.socket.io.opts.extraHeaders['Client-Id'] = clientId;
        instance.socket.io.opts.query.clientId = clientId;
        instance.isReconnecting = true;
        instance.socket.io.uri = await this._getServerUrl();
        instance.socket.connect();
      }
      resolve();
    }, 1000));
  }

  //eslint-disable-next-line complexity, max-statements
  async _rpcRequest(accountId, request, timeoutInSeconds) {
    let socketInstanceIndex = null;
    if (this._socketInstancesByAccounts[accountId] !== undefined) {
      socketInstanceIndex = this._socketInstancesByAccounts[accountId];
    } else {
      while (this._subscribeLock && (new Date(this._subscribeLock.recommendedRetryTime).getTime() > Date.now() && this.subscribedAccountIds().length < this._subscribeLock.lockedAtAccounts || new Date(this._subscribeLock.lockedAtTime).getTime() + this._subscribeCooldownInSeconds * 1000 > Date.now() && this.subscribedAccountIds().length >= this._subscribeLock.lockedAtAccounts)) {
        await new _promise2.default(res => setTimeout(res, 1000));
      }
      for (let index = 0; index < this._socketInstances.length; index++) {
        const accountCounter = this.getAssignedAccounts(index).length;
        const instance = this.socketInstances[index];
        if (instance.subscribeLock) {
          if (instance.subscribeLock.type === 'LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_USER_PER_SERVER' && (new Date(instance.subscribeLock.recommendedRetryTime).getTime() > Date.now() || this.subscribedAccountIds(index).length >= instance.subscribeLock.lockedAtAccounts)) {
            continue;
          }
          if (instance.subscribeLock.type === 'LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_SERVER' && new Date(instance.subscribeLock.recommendedRetryTime).getTime() > Date.now() && this.subscribedAccountIds(index).length >= instance.subscribeLock.lockedAtAccounts) {
            continue;
          }
        }
        if (accountCounter < this._maxAccountsPerInstance) {
          socketInstanceIndex = index;
          break;
        }
      }
      if (socketInstanceIndex === null) {
        socketInstanceIndex = this._socketInstances.length;
        await this.connect();
      }
      this._socketInstancesByAccounts[accountId] = socketInstanceIndex;
    }
    const instance = this._socketInstances[socketInstanceIndex];
    if (!instance.connected) {
      await this.connect();
    } else if (!this.connected(socketInstanceIndex)) {
      await instance.connectResult;
    }
    if (request.type === 'subscribe') {
      request.sessionId = instance.sessionId;
    }
    if (['trade', 'subscribe'].includes(request.type)) {
      return this._makeRequest(accountId, request, timeoutInSeconds);
    }
    let retryCounter = 0;
    while (true) {
      //eslint-disable-line no-constant-condition
      try {
        return await this._makeRequest(accountId, request, timeoutInSeconds);
      } catch (err) {
        if (err.name === 'TooManyRequestsError') {
          let calcRetryCounter = retryCounter;
          let calcRequestTime = 0;
          while (calcRetryCounter < this._retries) {
            calcRetryCounter++;
            calcRequestTime += Math.min(Math.pow(2, calcRetryCounter) * this._minRetryDelayInSeconds, this._maxRetryDelayInSeconds) * 1000;
          }
          const retryTime = new Date(err.metadata.recommendedRetryTime).getTime();
          if (Date.now() + calcRequestTime > retryTime && retryCounter < this._retries) {
            if (Date.now() < retryTime) {
              await new _promise2.default(res => setTimeout(res, retryTime - Date.now()));
            }
            retryCounter++;
          } else {
            throw err;
          }
        } else if (['NotSynchronizedError', 'TimeoutError', 'NotAuthenticatedError', 'InternalError'].includes(err.name) && retryCounter < this._retries) {
          await new _promise2.default(res => setTimeout(res, Math.min(Math.pow(2, retryCounter) * this._minRetryDelayInSeconds, this._maxRetryDelayInSeconds) * 1000));
          retryCounter++;
        } else {
          throw err;
        }
        if (this._socketInstancesByAccounts[accountId] === undefined) {
          throw err;
        }
      }
    }
  }

  _makeRequest(accountId, request, timeoutInSeconds) {
    const socketInstance = this._socketInstances[this._socketInstancesByAccounts[accountId]];
    let requestId = request.requestId || _randomstring2.default.generate(32);
    request.timestamps = { clientProcessingStarted: new Date() };
    let result = _promise2.default.race([new _promise2.default((resolve, reject) => socketInstance.requestResolves[requestId] = { resolve, reject, type: request.type }), new _promise2.default((resolve, reject) => setTimeout(() => reject(new _timeoutError2.default('MetaApi websocket client ' + `request ${request.requestId} of type ${request.type} timed out. Please make sure your account is connected ` + 'to broker before retrying your request.')), timeoutInSeconds * 1000 || this._requestTimeout))]);
    request.accountId = accountId;
    request.application = request.application || this._application;
    if (!request.requestId) {
      request.requestId = requestId;
    }
    socketInstance.socket.emit('request', request);
    return result;
  }

  // eslint-disable-next-line complexity
  _convertError(data) {
    if (data.error === 'ValidationError') {
      return new _errorHandler.ValidationError(data.message, data.details);
    } else if (data.error === 'NotFoundError') {
      return new _errorHandler.NotFoundError(data.message);
    } else if (data.error === 'NotSynchronizedError') {
      return new _notSynchronizedError2.default(data.message);
    } else if (data.error === 'TimeoutError') {
      return new _timeoutError2.default(data.message);
    } else if (data.error === 'NotAuthenticatedError') {
      return new _notConnectedError2.default(data.message);
    } else if (data.error === 'TradeError') {
      return new _tradeError2.default(data.message, data.numericCode, data.stringCode);
    } else if (data.error === 'UnauthorizedError') {
      this.close();
      return new _errorHandler.UnauthorizedError(data.message);
    } else if (data.error === 'TooManyRequestsError') {
      return new _errorHandler.TooManyRequestsError(data.message, data.metadata);
    } else {
      return new _errorHandler.InternalError(data.message);
    }
  }

  // eslint-disable-next-line complexity
  _convertIsoTimeToDate(packet) {
    // eslint-disable-next-line guard-for-in
    for (let field in packet) {
      let value = packet[field];
      if (typeof value === 'string' && field.match(/time$|Time$/) && !field.match(/brokerTime$|BrokerTime$|timeframe$/)) {
        packet[field] = new Date(value);
      }
      if (Array.isArray(value)) {
        for (let item of value) {
          this._convertIsoTimeToDate(item);
        }
      }
      if (typeof value === 'object') {
        this._convertIsoTimeToDate(value);
      }
    }
    if (packet && packet.timestamps) {
      // eslint-disable-next-line guard-for-in
      for (let field in packet.timestamps) {
        packet.timestamps[field] = new Date(packet.timestamps[field]);
      }
    }
    if (packet && packet.type === 'prices') {
      for (let price of packet.prices || []) {
        if (price.timestamps) {
          // eslint-disable-next-line guard-for-in
          for (let field in price.timestamps) {
            price.timestamps[field] = new Date(price.timestamps[field]);
          }
        }
      }
    }
  }

  /**
   * MetaTrader symbol specification. Contains symbol specification (see
   * https://metaapi.cloud/docs/client/models/metatraderSymbolSpecification/)
   * @typedef {Object} MetatraderSymbolSpecification
   * @property {String} symbol symbol (e.g. a currency pair or an index)
   * @property {Number} tickSize tick size
   * @property {Number} minVolume minimum order volume for the symbol
   * @property {Number} maxVolume maximum order volume for the symbol
   * @property {Number} volumeStep order volume step for the symbol
   * @property {Array<String>} list of allowed order filling modes. Can contain ORDER_FILLING_FOK, ORDER_FILLING_IOC or
   * both. See https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#symbol_filling_mode for more
   * details.
   * @property {String} deal execution mode. Possible values are SYMBOL_TRADE_EXECUTION_REQUEST,
   * SYMBOL_TRADE_EXECUTION_INSTANT, SYMBOL_TRADE_EXECUTION_MARKET, SYMBOL_TRADE_EXECUTION_EXCHANGE. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_trade_execution for more
   * details.
   * @property {Number} contractSize trade contract size
   * @property {MetatraderSessions} quoteSessions quote sessions, indexed by day of week
   * @property {MetatraderSessions} tradeSessions trade sessions, indexed by day of week
   * @property {String} [tradeMode] order execution type. Possible values are SYMBOL_TRADE_MODE_DISABLED,
   * SYMBOL_TRADE_MODE_LONGONLY, SYMBOL_TRADE_MODE_SHORTONLY, SYMBOL_TRADE_MODE_CLOSEONLY, SYMBOL_TRADE_MODE_FULL. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_trade_mode for more
   * details
   * @property {Number} [bondAccruedInterest] accrued interest – accumulated coupon interest, i.e. part of the coupon
   * interest calculated in proportion to the number of days since the coupon bond issuance or the last coupon interest
   * payment
   * @property {Number} [bondFaceValue] face value – initial bond value set by the issuer
   * @property {Number} [optionStrike] the strike price of an option. The price at which an option buyer can buy (in a
   * Call option) or sell (in a Put option) the underlying asset, and the option seller is obliged to sell or buy the
   * appropriate amount of the underlying asset.
   * @property {Number} [optionPriceSensivity] option/warrant sensitivity shows by how many points the price of the
   * option's underlying asset should change so that the price of the option changes by one point
   * @property {Number} [liquidityRate] liquidity Rate is the share of the asset that can be used for the margin
   * @property {Number} initialMargin initial margin means the amount in the margin currency required for opening a
   * position with the volume of one lot. It is used for checking a client's assets when he or she enters the market
   * @property {Number} maintenanceMargin the maintenance margin. If it is set, it sets the margin amount in the margin
   * currency of the symbol, charged from one lot. It is used for checking a client's assets when his/her account state
   * changes. If the maintenance margin is equal to 0, the initial margin is used
   * @property {Number} hedgedMargin contract size or margin value per one lot of hedged positions (oppositely directed
   * positions of one symbol). Two margin calculation methods are possible for hedged positions. The calculation method
   * is defined by the broker
   * @property {Boolean} [hedgedMarginUsesLargerLeg] calculating hedging margin using the larger leg (Buy or Sell)
   * @properties {String} marginCurrency margin currency
   * @property {String} priceCalculationMode contract price calculation mode. One of SYMBOL_CALC_MODE_UNKNOWN,
   * SYMBOL_CALC_MODE_FOREX, SYMBOL_CALC_MODE_FOREX_NO_LEVERAGE, SYMBOL_CALC_MODE_FUTURES, SYMBOL_CALC_MODE_CFD,
   * SYMBOL_CALC_MODE_CFDINDEX, SYMBOL_CALC_MODE_CFDLEVERAGE, SYMBOL_CALC_MODE_EXCH_STOCKS,
   * SYMBOL_CALC_MODE_EXCH_FUTURES, SYMBOL_CALC_MODE_EXCH_FUTURES_FORTS, SYMBOL_CALC_MODE_EXCH_BONDS,
   * SYMBOL_CALC_MODE_EXCH_STOCKS_MOEX, SYMBOL_CALC_MODE_EXCH_BONDS_MOEX, SYMBOL_CALC_MODE_SERV_COLLATERAL. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_calc_mode for more details
   * @property {String} baseCurrency base currency
   * @property {String} [profitCurrency] profit currency
   * @property {String} swapMode swap calculation model. Allowed values are SYMBOL_SWAP_MODE_DISABLED,
   * SYMBOL_SWAP_MODE_POINTS, SYMBOL_SWAP_MODE_CURRENCY_SYMBOL, SYMBOL_SWAP_MODE_CURRENCY_MARGIN,
   * SYMBOL_SWAP_MODE_CURRENCY_DEPOSIT, SYMBOL_SWAP_MODE_INTEREST_CURRENT, SYMBOL_SWAP_MODE_INTEREST_OPEN,
   * SYMBOL_SWAP_MODE_REOPEN_CURRENT, SYMBOL_SWAP_MODE_REOPEN_BID. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_swap_mode for more details
   * @property {Number} [swapLong] long swap value
   * @property {Number} [swapShort] short swap value
   * @property {String} [swapRollover3Days] day of week to charge 3 days swap rollover. Allowed values are SUNDAY,
   * MONDAY, TUESDAY, WEDNESDAY, THURDAY, FRIDAY, SATURDAY, NONE
   * @property {Array<String>} allowedExpirationModes allowed order expiration modes. Allowed values are
   * SYMBOL_EXPIRATION_GTC, SYMBOL_EXPIRATION_DAY, SYMBOL_EXPIRATION_SPECIFIED, SYMBOL_EXPIRATION_SPECIFIED_DAY.
   * See https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#symbol_expiration_mode for more
   * details
   * @property {Array<String>} allowedOrderTypes allowed order types. Allowed values are SYMBOL_ORDER_MARKET,
   * SYMBOL_ORDER_LIMIT, SYMBOL_ORDER_STOP, SYMBOL_ORDER_STOP_LIMIT, SYMBOL_ORDER_SL, SYMBOL_ORDER_TP,
   * SYMBOL_ORDER_CLOSEBY. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#symbol_order_mode for more details
   * @property {String} orderGTCMode if the expirationMode property is set to SYMBOL_EXPIRATION_GTC (good till
   * canceled), the expiration of pending orders, as well as of Stop Loss/Take Profit orders should be additionally set
   * using this enumeration. Allowed values are SYMBOL_ORDERS_GTC, SYMBOL_ORDERS_DAILY,
   * SYMBOL_ORDERS_DAILY_EXCLUDING_STOPS. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_order_gtc_mode for more
   * details
   * @property {Number} digits digits after a decimal point
   * @property {String} [path] path in the symbol tree
   * @property {String} description symbol description
   * @property {Date} [startTime] date of the symbol trade beginning (usually used for futures)
   * @property {Date} [expirationTime] date of the symbol trade end (usually used for futures)
   */

  /**
   * Metatrader trade or quote session container, indexed by weekday
   * @typedef {Object} MetatraderSessions
   * @property {Array<MetatraderSession>} [SUNDAY] array of sessions for SUNDAY
   * @property {Array<MetatraderSession>} [MONDAY] array of sessions for MONDAY
   * @property {Array<MetatraderSession>} [TUESDAY] array of sessions for TUESDAY
   * @property {Array<MetatraderSession>} [WEDNESDAY] array of sessions for WEDNESDAY
   * @property {Array<MetatraderSession>} [THURSDAY] array of sessions for THURSDAY
   * @property {Array<MetatraderSession>} [FRIDAY] array of sessions for FRIDAY
   * @property {Array<MetatraderSession>} [SATURDAY] array of sessions for SATURDAY
   */

  /**
   * Metatrader trade or quote session
   * @typedef {Object} MetatraderSession
   * @property {String} from session start time, in hh.mm.ss.SSS format
   * @property {String} to session end time, in hh.mm.ss.SSS format
   */

  /**
   * MetaTrader symbol price. Contains current price for a symbol (see
   * https://metaapi.cloud/docs/client/models/metatraderSymbolPrice/)
   * @typedef {Object} MetatraderSymbolPrice
   * @property {String} symbol symbol (e.g. a currency pair or an index)
   * @property {Number} bid bid price
   * @property {Number} ask ask price
   * @property {Number} profitTickValue tick value for a profitable position
   * @property {Number} lossTickValue tick value for a losing position
   * @property {Number} [accountCurrencyExchangeRate] current exchange rate of account currency into account base
   * currency (USD if you did not override it)
   * @property {Date} time quote time, in ISO format
   * @property {String} brokerTime time quote time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   */

  /**
   * MetaTrader candle
   * @typedef {Object} MetatraderCandle
   * @property {string} symbol symbol (e.g. currency pair or an index)
   * @property {string} timeframe timeframe candle was generated for, e.g. 1h. One of 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m,
   * 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, 1d, 1w, 1mn
   * @property {Date} time candle opening time
   * @property {string} brokerTime candle opening time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {number} open open price
   * @property {number} high high price
   * @property {number} low low price
   * @property {number} close close price
   * @property {number} tickVolume tick volume, i.e. number of ticks inside the candle
   * @property {number} spread spread in points
   * @property {number} volume trade volume
   */

  /**
   * MetaTrader tick data
   * @typedef {Object} MetatraderTick
   * @property {string} symbol symbol (e.g. a currency pair or an index)
   * @property {Date} time time
   * @property {string} brokerTime time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {number} [bid] bid price
   * @property {number} [ask] ask price
   * @property {number} [last] last deal price
   * @property {number} [volume] volume for the current last deal price
   * @property {string} side is tick a result of buy or sell deal, one of buy or sell
   */

  /**
   * MetaTrader order book
   * @typedef {Object} MetatraderBook
   * @property {string} symbol symbol (e.g. a currency pair or an index)
   * @property {Date} time time
   * @property {string} brokerTime time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {Array<MetatraderBookEntry>} book list of order book entries
   */

  /**
   * MetaTrader order book entry
   * @typedef {Object} MetatraderBookEntry
   * @property {string} type entry type, one of BOOK_TYPE_SELL, BOOK_TYPE_BUY, BOOK_TYPE_SELL_MARKET,
   * BOOK_TYPE_BUY_MARKET
   * @property {number} price price
   * @property {number} volume volume
   */

  // eslint-disable-next-line complexity,max-statements
  async _processSynchronizationPacket(data) {
    try {
      const socketInstance = this._socketInstances[this._socketInstancesByAccounts[data.accountId]];
      if (data.synchronizationId && socketInstance) {
        socketInstance.synchronizationThrottler.updateSynchronizationId(data.synchronizationId);
      }
      const instanceNumber = data.instanceIndex || 0;
      let instanceId = data.accountId + ':' + instanceNumber + ':' + (data.host || 0);
      let instanceIndex = instanceNumber + ':' + (data.host || 0);

      const isOnlyActiveInstance = () => {
        const activeInstanceIds = (0, _keys2.default)(this._connectedHosts).filter(instance => instance.startsWith(data.accountId + ':' + instanceNumber));
        return !activeInstanceIds.length || activeInstanceIds.length === 1 && activeInstanceIds[0] === instanceId;
      };

      const cancelDisconnectTimer = () => {
        if (this._statusTimers[instanceId]) {
          clearTimeout(this._statusTimers[instanceId]);
        }
      };

      const resetDisconnectTimer = () => {
        cancelDisconnectTimer();
        this._statusTimers[instanceId] = setTimeout(async () => {
          if (isOnlyActiveInstance()) {
            this._subscriptionManager.onTimeout(data.accountId, instanceNumber);
          }
          this.queueEvent(data.accountId, () => _promise2.default.resolve(onDisconnected(true)));
        }, 60000);
      };

      const onDisconnected = async (isTimeout = false) => {
        if (this._connectedHosts[instanceId]) {
          if (isOnlyActiveInstance()) {
            const onDisconnectedPromises = [];
            if (!isTimeout) {
              onDisconnectedPromises.push(this._subscriptionManager.onDisconnected(data.accountId, instanceNumber));
            }
            for (let listener of this._synchronizationListeners[data.accountId] || []) {
              onDisconnectedPromises.push(_promise2.default.resolve(listener.onDisconnected(instanceIndex))
              // eslint-disable-next-line no-console
              .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about disconnected event', err)));
            }
            await _promise2.default.all(onDisconnectedPromises);
          } else {
            const onStreamClosedPromises = [];
            this._packetOrderer.onStreamClosed(instanceId);
            socketInstance.synchronizationThrottler.removeIdByParameters(data.accountId, instanceNumber, data.host);
            for (let listener of this._synchronizationListeners[data.accountId] || []) {
              onStreamClosedPromises.push(_promise2.default.resolve(listener.onStreamClosed(instanceIndex))
              // eslint-disable-next-line no-console
              .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about stream closed event', err)));
            }
            await _promise2.default.all(onStreamClosedPromises);
          }
          delete this._connectedHosts[instanceId];
        }
      };
      if (data.type === 'authenticated') {
        resetDisconnectTimer();
        if (!data.sessionId || data.sessionId === socketInstance.sessionId) {
          this._connectedHosts[instanceId] = data.host;
          const onConnectedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onConnectedPromises.push(_promise2.default.resolve(listener.onConnected(instanceIndex, data.replicas))
            // eslint-disable-next-line no-console
            .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about connected event', err)));
          }
          this._subscriptionManager.cancelSubscribe(data.accountId + ':' + instanceNumber);
          await _promise2.default.all(onConnectedPromises);
        }
      } else if (data.type === 'disconnected') {
        cancelDisconnectTimer();
        await onDisconnected();
      } else if (data.type === 'synchronizationStarted') {
        const promises = [];
        for (let listener of this._synchronizationListeners[data.accountId] || []) {
          promises.push(_promise2.default.resolve(listener.onSynchronizationStarted(instanceIndex))
          // eslint-disable-next-line no-console
          .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about synchronization started event', err)));
        }
        await _promise2.default.all(promises);
      } else if (data.type === 'accountInformation') {
        if (data.accountInformation) {
          const onAccountInformationUpdatedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onAccountInformationUpdatedPromises.push(_promise2.default.resolve(listener.onAccountInformationUpdated(instanceIndex, data.accountInformation))
            // eslint-disable-next-line no-console
            .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about accountInformation event', err)));
          }
          await _promise2.default.all(onAccountInformationUpdatedPromises);
        }
      } else if (data.type === 'deals') {
        for (let deal of data.deals || []) {
          const onDealAddedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onDealAddedPromises.push(_promise2.default.resolve(listener.onDealAdded(instanceIndex, deal))
            // eslint-disable-next-line no-console
            .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about deals event', err)));
          }
          await _promise2.default.all(onDealAddedPromises);
        }
      } else if (data.type === 'orders') {
        const onOrderUpdatedPromises = [];
        for (let listener of this._synchronizationListeners[data.accountId] || []) {
          onOrderUpdatedPromises.push(_promise2.default.resolve(listener.onOrdersReplaced(instanceIndex, data.orders || []))
          // eslint-disable-next-line no-console
          .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about orders event', err)));
        }
        await _promise2.default.all(onOrderUpdatedPromises);
      } else if (data.type === 'historyOrders') {
        for (let historyOrder of data.historyOrders || []) {
          const onHistoryOrderAddedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onHistoryOrderAddedPromises.push(_promise2.default.resolve(listener.onHistoryOrderAdded(instanceIndex, historyOrder))
            // eslint-disable-next-line no-console
            .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about historyOrders event', err)));
          }
          await _promise2.default.all(onHistoryOrderAddedPromises);
        }
      } else if (data.type === 'positions') {
        const onPositionUpdatedPromises = [];
        for (let listener of this._synchronizationListeners[data.accountId] || []) {
          onPositionUpdatedPromises.push(_promise2.default.resolve(listener.onPositionsReplaced(instanceIndex, data.positions || []))
          // eslint-disable-next-line no-console
          .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about positions event', err)));
        }
        await _promise2.default.all(onPositionUpdatedPromises);
      } else if (data.type === 'update') {
        if (data.accountInformation) {
          const onAccountInformationUpdatedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onAccountInformationUpdatedPromises.push(_promise2.default.resolve(listener.onAccountInformationUpdated(instanceIndex, data.accountInformation))
            // eslint-disable-next-line no-console
            .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about update event', err)));
          }
          await _promise2.default.all(onAccountInformationUpdatedPromises);
        }
        for (let position of data.updatedPositions || []) {
          const onPositionUpdatedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onPositionUpdatedPromises.push(_promise2.default.resolve(listener.onPositionUpdated(instanceIndex, position))
            // eslint-disable-next-line no-console
            .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about update event', err)));
          }
          await _promise2.default.all(onPositionUpdatedPromises);
        }
        for (let positionId of data.removedPositionIds || []) {
          const onPositionRemovedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onPositionRemovedPromises.push(_promise2.default.resolve(listener.onPositionRemoved(instanceIndex, positionId))
            // eslint-disable-next-line no-console
            .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about update event', err)));
          }
          await _promise2.default.all(onPositionRemovedPromises);
        }
        for (let order of data.updatedOrders || []) {
          const onOrderUpdatedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onOrderUpdatedPromises.push(_promise2.default.resolve(listener.onOrderUpdated(instanceIndex, order))
            // eslint-disable-next-line no-console
            .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about update event', err)));
          }
          await _promise2.default.all(onOrderUpdatedPromises);
        }
        for (let orderId of data.completedOrderIds || []) {
          const onOrderCompletedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onOrderCompletedPromises.push(_promise2.default.resolve(listener.onOrderCompleted(instanceIndex, orderId))
            // eslint-disable-next-line no-console
            .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about update event', err)));
          }
          await _promise2.default.all(onOrderCompletedPromises);
        }
        for (let historyOrder of data.historyOrders || []) {
          const onHistoryOrderAddedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onHistoryOrderAddedPromises.push(_promise2.default.resolve(listener.onHistoryOrderAdded(instanceIndex, historyOrder))
            // eslint-disable-next-line no-console
            .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about update event', err)));
          }
          await _promise2.default.all(onHistoryOrderAddedPromises);
        }
        for (let deal of data.deals || []) {
          const onDealAddedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onDealAddedPromises.push(_promise2.default.resolve(listener.onDealAdded(instanceIndex, deal))
            // eslint-disable-next-line no-console
            .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about update event', err)));
          }
          await _promise2.default.all(onDealAddedPromises);
        }
        if (data.timestamps) {
          data.timestamps.clientProcessingFinished = new Date();
          const onUpdatePromises = [];
          // eslint-disable-next-line max-depth
          for (let listener of this._latencyListeners || []) {
            onUpdatePromises.push(_promise2.default.resolve(listener.onUpdate(data.accountId, data.timestamps))
            // eslint-disable-next-line no-console
            .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify latency ` + 'listener about update event', err)));
          }
          await _promise2.default.all(onUpdatePromises);
        }
      } else if (data.type === 'dealSynchronizationFinished') {
        const onDealSynchronizationFinishedPromises = [];
        for (let listener of this._synchronizationListeners[data.accountId] || []) {
          if (socketInstance) {
            socketInstance.synchronizationThrottler.removeSynchronizationId(data.synchronizationId);
          }
          onDealSynchronizationFinishedPromises.push(_promise2.default.resolve(listener.onDealSynchronizationFinished(instanceIndex, data.synchronizationId))
          // eslint-disable-next-line no-console
          .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener about ` + 'dealSynchronizationFinished event', err)));
        }
        await _promise2.default.all(onDealSynchronizationFinishedPromises);
      } else if (data.type === 'orderSynchronizationFinished') {
        const onOrderSynchronizationFinishedPromises = [];
        for (let listener of this._synchronizationListeners[data.accountId] || []) {
          onOrderSynchronizationFinishedPromises.push(_promise2.default.resolve(listener.onOrderSynchronizationFinished(instanceIndex, data.synchronizationId))
          // eslint-disable-next-line no-console
          .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener about ` + 'orderSynchronizationFinished event', err)));
        }
        await _promise2.default.all(onOrderSynchronizationFinishedPromises);
      } else if (data.type === 'status') {
        if (!this._connectedHosts[instanceId]) {
          if (this._statusTimers[instanceId] && data.authenticated && (this._subscriptionManager.isDisconnectedRetryMode(data.accountId, instanceNumber) || !this._subscriptionManager.isAccountSubscribing(data.accountId, instanceNumber))) {
            this._subscriptionManager.cancelSubscribe(data.accountId + ':' + instanceNumber);
            await new _promise2.default(res => setTimeout(res, 10));
            // eslint-disable-next-line no-console
            console.log('[' + new Date().toISOString() + '] it seems like we are not connected to a running API ' + 'server yet, retrying subscription for account ' + instanceId);
            this.ensureSubscribe(data.accountId, instanceNumber);
          }
        } else {
          resetDisconnectTimer();
          const onBrokerConnectionStatusChangedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onBrokerConnectionStatusChangedPromises.push(_promise2.default.resolve(listener.onBrokerConnectionStatusChanged(instanceIndex, !!data.connected))
            // eslint-disable-next-line no-console
            .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener about ` + 'brokerConnectionStatusChanged event', err)));
          }
          await _promise2.default.all(onBrokerConnectionStatusChangedPromises);
          if (data.healthStatus) {
            const onHealthStatusPromises = [];
            // eslint-disable-next-line max-depth
            for (let listener of this._synchronizationListeners[data.accountId] || []) {
              onHealthStatusPromises.push(_promise2.default.resolve(listener.onHealthStatus(instanceIndex, data.healthStatus))
              // eslint-disable-next-line no-console
              .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener about ` + 'server-side healthStatus event', err)));
            }
            await _promise2.default.all(onHealthStatusPromises);
          }
        }
      } else if (data.type === 'downgradeSubscription') {
        // eslint-disable-next-line no-console
        console.log(`${data.accountId}:${instanceIndex}: Market data subscriptions for symbol ${data.symbol} were ` + `downgraded by the server due to rate limits. Updated subscriptions: ${(0, _stringify2.default)(data.updates)}, ` + `removed subscriptions: ${(0, _stringify2.default)(data.unsubscriptions)}. Please read ` + 'https://metaapi.cloud/docs/client/rateLimiting/ for more details.');
        const onSubscriptionDowngradePromises = [];
        for (let listener of this._synchronizationListeners[data.accountId] || []) {
          onSubscriptionDowngradePromises.push(_promise2.default.resolve(listener.onSubscriptionDowngraded(instanceIndex, data.symbol, data.updates, data.unsubscriptions))
          // eslint-disable-next-line no-console
          .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about subscription downgrade event', err)));
        }
        await _promise2.default.all(onSubscriptionDowngradePromises);
      } else if (data.type === 'specifications') {
        const onSymbolSpecificationsUpdatedPromises = [];
        for (let listener of this._synchronizationListeners[data.accountId] || []) {
          onSymbolSpecificationsUpdatedPromises.push(_promise2.default.resolve(listener.onSymbolSpecificationsUpdated(instanceIndex, data.specifications || [], data.removedSymbols || []))
          // eslint-disable-next-line no-console
          .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about specifications updated event', err)));
        }
        await _promise2.default.all(onSymbolSpecificationsUpdatedPromises);
        for (let specification of data.specifications || []) {
          const onSymbolSpecificationUpdatedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onSymbolSpecificationUpdatedPromises.push(_promise2.default.resolve(listener.onSymbolSpecificationUpdated(instanceIndex, specification))
            // eslint-disable-next-line no-console
            .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about specification updated event', err)));
          }
          await _promise2.default.all(onSymbolSpecificationUpdatedPromises);
        }
        for (let removedSymbol of data.removedSymbols || []) {
          const onSymbolSpecificationRemovedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onSymbolSpecificationRemovedPromises.push(_promise2.default.resolve(listener.onSymbolSpecificationRemoved(instanceIndex, removedSymbol))
            // eslint-disable-next-line no-console
            .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about specifications removed event', err)));
          }
          await _promise2.default.all(onSymbolSpecificationRemovedPromises);
        }
      } else if (data.type === 'prices') {
        let prices = data.prices || [];
        let candles = data.candles || [];
        let ticks = data.ticks || [];
        let books = data.books || [];
        const onSymbolPricesUpdatedPromises = [];
        for (let listener of this._synchronizationListeners[data.accountId] || []) {
          if (prices.length) {
            onSymbolPricesUpdatedPromises.push(_promise2.default.resolve(listener.onSymbolPricesUpdated(instanceIndex, prices, data.equity, data.margin, data.freeMargin, data.marginLevel, data.accountCurrencyExchangeRate))
            // eslint-disable-next-line no-console
            .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about prices event', err)));
          }
          if (candles.length) {
            onSymbolPricesUpdatedPromises.push(_promise2.default.resolve(listener.onCandlesUpdated(instanceIndex, candles, data.equity, data.margin, data.freeMargin, data.marginLevel, data.accountCurrencyExchangeRate))
            // eslint-disable-next-line no-console
            .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about candles event', err)));
          }
          if (ticks.length) {
            onSymbolPricesUpdatedPromises.push(_promise2.default.resolve(listener.onTicksUpdated(instanceIndex, ticks, data.equity, data.margin, data.freeMargin, data.marginLevel, data.accountCurrencyExchangeRate))
            // eslint-disable-next-line no-console
            .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about ticks event', err)));
          }
          if (books.length) {
            onSymbolPricesUpdatedPromises.push(_promise2.default.resolve(listener.onBooksUpdated(instanceIndex, books, data.equity, data.margin, data.freeMargin, data.marginLevel, data.accountCurrencyExchangeRate))
            // eslint-disable-next-line no-console
            .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about books event', err)));
          }
        }
        await _promise2.default.all(onSymbolPricesUpdatedPromises);
        for (let price of prices) {
          const onSymbolPriceUpdatedPromises = [];
          for (let listener of this._synchronizationListeners[data.accountId] || []) {
            onSymbolPriceUpdatedPromises.push(_promise2.default.resolve(listener.onSymbolPriceUpdated(instanceIndex, price))
            // eslint-disable-next-line no-console
            .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify listener ` + 'about price event', err)));
          }
          await _promise2.default.all(onSymbolPriceUpdatedPromises);
        }
        for (let price of prices) {
          if (price.timestamps) {
            price.timestamps.clientProcessingFinished = new Date();
            const onSymbolPricePromises = [];
            // eslint-disable-next-line max-depth
            for (let listener of this._latencyListeners || []) {
              onSymbolPricePromises.push(_promise2.default.resolve(listener.onSymbolPrice(data.accountId, price.symbol, price.timestamps))
              // eslint-disable-next-line no-console
              .catch(err => console.error(`${data.accountId}:${instanceIndex}: Failed to notify latency ` + 'listener about price event', err)));
            }
            await _promise2.default.all(onSymbolPricePromises);
          }
        }
      }
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error('Failed to process incoming synchronization packet', err);
    }
  }

  async _fireReconnected(socketInstanceIndex) {
    try {
      const reconnectListeners = [];
      for (let listener of this._reconnectListeners) {
        if (this._socketInstancesByAccounts[listener.accountId] === socketInstanceIndex) {
          reconnectListeners.push(listener);
        }
      }
      const reconnectAccountIds = reconnectListeners.map(listener => listener.accountId);
      this._subscriptionManager.onReconnected(socketInstanceIndex, reconnectAccountIds);
      this._packetOrderer.onReconnected(reconnectAccountIds);

      for (let listener of reconnectListeners) {
        this.queueEvent(listener.accountId, () => _promise2.default.resolve(listener.listener.onReconnected())
        // eslint-disable-next-line no-console
        .catch(err => console.error('[' + new Date().toISOString() + '] Failed to notify reconnect listener', err)));
      }
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error('[' + new Date().toISOString() + '] Failed to process reconnected event', err);
    }
  }

  async _getServerUrl() {
    if (this._useSharedClientApi) {
      return this._url;
    } else {
      const opts = {
        url: `https://mt-provisioning-api-v1.${this._domain}/users/current/servers/mt-client-api`,
        method: 'GET',
        headers: {
          'auth-token': this._token
        },
        json: true
      };
      const response = await this._httpClient.request(opts);
      return response.url;
    }
  }

}
exports.default = MetaApiWebsocketClient;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9jbGllbnRzL21ldGFBcGkvbWV0YUFwaVdlYnNvY2tldC5jbGllbnQuZXM2Il0sIm5hbWVzIjpbIlBhY2tldExvZ2dlciIsIndpbmRvdyIsInJlcXVpcmUiLCJkZWZhdWx0IiwiTWV0YUFwaVdlYnNvY2tldENsaWVudCIsImNvbnN0cnVjdG9yIiwiaHR0cENsaWVudCIsInRva2VuIiwib3B0cyIsInZhbGlkYXRvciIsIk9wdGlvbnNWYWxpZGF0b3IiLCJwYWNrZXRPcmRlcmluZ1RpbWVvdXQiLCJ2YWxpZGF0ZU5vblplcm8iLCJzeW5jaHJvbml6YXRpb25UaHJvdHRsZXIiLCJfaHR0cENsaWVudCIsIl9hcHBsaWNhdGlvbiIsImFwcGxpY2F0aW9uIiwiX2RvbWFpbiIsImRvbWFpbiIsIl91cmwiLCJfcmVxdWVzdFRpbWVvdXQiLCJyZXF1ZXN0VGltZW91dCIsIl9jb25uZWN0VGltZW91dCIsImNvbm5lY3RUaW1lb3V0IiwicmV0cnlPcHRzIiwiX3JldHJpZXMiLCJ2YWxpZGF0ZU51bWJlciIsInJldHJpZXMiLCJfbWluUmV0cnlEZWxheUluU2Vjb25kcyIsIm1pbkRlbGF5SW5TZWNvbmRzIiwiX21heFJldHJ5RGVsYXlJblNlY29uZHMiLCJtYXhEZWxheUluU2Vjb25kcyIsIl9tYXhBY2NvdW50c1Blckluc3RhbmNlIiwiX3N1YnNjcmliZUNvb2xkb3duSW5TZWNvbmRzIiwic3Vic2NyaWJlQ29vbGRvd25JblNlY29uZHMiLCJldmVudFByb2Nlc3NpbmciLCJfc2VxdWVudGlhbEV2ZW50UHJvY2Vzc2luZyIsInZhbGlkYXRlQm9vbGVhbiIsInNlcXVlbnRpYWxQcm9jZXNzaW5nIiwiX3VzZVNoYXJlZENsaWVudEFwaSIsInVzZVNoYXJlZENsaWVudEFwaSIsIl90b2tlbiIsIl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnMiLCJfbGF0ZW5jeUxpc3RlbmVycyIsIl9yZWNvbm5lY3RMaXN0ZW5lcnMiLCJfY29ubmVjdGVkSG9zdHMiLCJfc29ja2V0SW5zdGFuY2VzIiwiX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHMiLCJfc3luY2hyb25pemF0aW9uVGhyb3R0bGVyT3B0cyIsIl9zdWJzY3JpcHRpb25NYW5hZ2VyIiwiU3Vic2NyaXB0aW9uTWFuYWdlciIsIl9zdGF0dXNUaW1lcnMiLCJfZXZlbnRRdWV1ZXMiLCJfc3Vic2NyaWJlTG9jayIsIl9wYWNrZXRPcmRlcmVyIiwiUGFja2V0T3JkZXJlciIsInBhY2tldExvZ2dlciIsImVuYWJsZWQiLCJfcGFja2V0TG9nZ2VyIiwic3RhcnQiLCJvbk91dE9mT3JkZXJQYWNrZXQiLCJhY2NvdW50SWQiLCJpbnN0YW5jZUluZGV4IiwiZXhwZWN0ZWRTZXF1ZW5jZU51bWJlciIsImFjdHVhbFNlcXVlbmNlTnVtYmVyIiwicGFja2V0IiwicmVjZWl2ZWRBdCIsImNvbnNvbGUiLCJlcnJvciIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInR5cGUiLCJlbnN1cmVTdWJzY3JpYmUiLCJ1cmwiLCJzb2NrZXRJbnN0YW5jZXMiLCJzb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzIiwic3Vic2NyaWJlZEFjY291bnRJZHMiLCJzb2NrZXRJbnN0YW5jZUluZGV4IiwiY29ubmVjdGVkSWRzIiwiZm9yRWFjaCIsImluc3RhbmNlSWQiLCJzcGxpdCIsImluY2x1ZGVzIiwidW5kZWZpbmVkIiwicHVzaCIsImNvbm5lY3RlZCIsImluc3RhbmNlIiwibGVuZ3RoIiwic29ja2V0IiwiZ2V0QXNzaWduZWRBY2NvdW50cyIsImFjY291bnRJZHMiLCJrZXkiLCJsb2NrU29ja2V0SW5zdGFuY2UiLCJtZXRhZGF0YSIsInJlY29tbWVuZGVkUmV0cnlUaW1lIiwibG9ja2VkQXRBY2NvdW50cyIsImxvY2tlZEF0VGltZSIsIm5vdyIsInN1YnNjcmliZWRBY2NvdW50cyIsInNvY2tldEluc3RhbmNlIiwiY2xvc2UiLCJfcmVjb25uZWN0Iiwic3Vic2NyaWJlTG9jayIsImNvbm5lY3QiLCJjbGllbnRJZCIsIk1hdGgiLCJyYW5kb20iLCJyZXNvbHZlIiwicmVqZWN0IiwicmVzb2x2ZWQiLCJyZXN1bHQiLCJyZXMiLCJyZWoiLCJpZCIsInJlcXVlc3RSZXNvbHZlcyIsImNvbm5lY3RSZXN1bHQiLCJzZXNzaW9uSWQiLCJyYW5kb21zdHJpbmciLCJnZW5lcmF0ZSIsImlzUmVjb25uZWN0aW5nIiwiU3luY2hyb25pemF0aW9uVGhyb3R0bGVyIiwic2VydmVyVXJsIiwiX2dldFNlcnZlclVybCIsInBhdGgiLCJyZWNvbm5lY3Rpb24iLCJyZWNvbm5lY3Rpb25EZWxheSIsInJlY29ubmVjdGlvbkRlbGF5TWF4IiwicmVjb25uZWN0aW9uQXR0ZW1wdHMiLCJJbmZpbml0eSIsInRpbWVvdXQiLCJleHRyYUhlYWRlcnMiLCJxdWVyeSIsInByb3RvY29sIiwiZmlyc3RDb25uZWN0Iiwib24iLCJpc1NoYXJlZENsaWVudEFwaSIsImlvIiwidXJpIiwibG9nIiwiX2ZpcmVSZWNvbm5lY3RlZCIsImVyciIsIlRpbWVvdXRFcnJvciIsInJlYXNvbiIsIm9uRGlzY29ubmVjdCIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJyZXF1ZXN0UmVzb2x2ZSIsInJlcXVlc3RJZCIsIl9jb252ZXJ0SXNvVGltZVRvRGF0ZSIsInRpbWVzdGFtcHMiLCJjbGllbnRQcm9jZXNzaW5nRmluaXNoZWQiLCJsaXN0ZW5lciIsInRoZW4iLCJvblRyYWRlIiwib25SZXNwb25zZSIsImNhdGNoIiwiX2NvbnZlcnRFcnJvciIsInN5bmNocm9uaXphdGlvbklkIiwiYWN0aXZlU3luY2hyb25pemF0aW9uSWRzIiwibG9nUGFja2V0IiwicXVldWVQYWNrZXQiLCJFcnJvciIsInN0b3AiLCJnZXRBY2NvdW50SW5mb3JtYXRpb24iLCJyZXNwb25zZSIsIl9ycGNSZXF1ZXN0IiwiYWNjb3VudEluZm9ybWF0aW9uIiwiZ2V0UG9zaXRpb25zIiwicG9zaXRpb25zIiwiZ2V0UG9zaXRpb24iLCJwb3NpdGlvbklkIiwicG9zaXRpb24iLCJnZXRPcmRlcnMiLCJvcmRlcnMiLCJnZXRPcmRlciIsIm9yZGVySWQiLCJvcmRlciIsImdldEhpc3RvcnlPcmRlcnNCeVRpY2tldCIsInRpY2tldCIsImhpc3RvcnlPcmRlcnMiLCJzeW5jaHJvbml6aW5nIiwiZ2V0SGlzdG9yeU9yZGVyc0J5UG9zaXRpb24iLCJnZXRIaXN0b3J5T3JkZXJzQnlUaW1lUmFuZ2UiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwib2Zmc2V0IiwibGltaXQiLCJnZXREZWFsc0J5VGlja2V0IiwiZGVhbHMiLCJnZXREZWFsc0J5UG9zaXRpb24iLCJnZXREZWFsc0J5VGltZVJhbmdlIiwicmVtb3ZlSGlzdG9yeSIsInJlbW92ZUFwcGxpY2F0aW9uIiwidHJhZGUiLCJzdHJpbmdDb2RlIiwiZGVzY3JpcHRpb24iLCJudW1lcmljQ29kZSIsIlRyYWRlRXJyb3IiLCJtZXNzYWdlIiwiaW5zdGFuY2VOdW1iZXIiLCJzdWJzY3JpYmUiLCJyZWNvbm5lY3QiLCJzeW5jaHJvbml6ZSIsImhvc3QiLCJzdGFydGluZ0hpc3RvcnlPcmRlclRpbWUiLCJzdGFydGluZ0RlYWxUaW1lIiwic3luY1Rocm90dGxlciIsInNjaGVkdWxlU3luY2hyb25pemUiLCJ3YWl0U3luY2hyb25pemVkIiwiYXBwbGljYXRpb25QYXR0ZXJuIiwidGltZW91dEluU2Vjb25kcyIsInN1YnNjcmliZVRvTWFya2V0RGF0YSIsInN5bWJvbCIsInN1YnNjcmlwdGlvbnMiLCJ1bnN1YnNjcmliZUZyb21NYXJrZXREYXRhIiwiZ2V0U3ltYm9scyIsInN5bWJvbHMiLCJnZXRTeW1ib2xTcGVjaWZpY2F0aW9uIiwic3BlY2lmaWNhdGlvbiIsImdldFN5bWJvbFByaWNlIiwicHJpY2UiLCJnZXRDYW5kbGUiLCJ0aW1lZnJhbWUiLCJjYW5kbGUiLCJnZXRUaWNrIiwidGljayIsImdldEJvb2siLCJib29rIiwic2F2ZVVwdGltZSIsInVwdGltZSIsInVuc3Vic2NyaWJlIiwiY2FuY2VsQWNjb3VudCIsIk5vdEZvdW5kRXJyb3IiLCJhZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lciIsImxpc3RlbmVycyIsInJlbW92ZVN5bmNocm9uaXphdGlvbkxpc3RlbmVyIiwiZmlsdGVyIiwibCIsImFkZExhdGVuY3lMaXN0ZW5lciIsInJlbW92ZUxhdGVuY3lMaXN0ZW5lciIsImFkZFJlY29ubmVjdExpc3RlbmVyIiwicmVtb3ZlUmVjb25uZWN0TGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJwYWNrZXRzIiwicmVzdG9yZU9yZGVyIiwicCIsInNlcXVlbmNlTnVtYmVyIiwiZXZlbnRzIiwibWFwIiwicGFja2V0SXRlbSIsIl9wcm9jZXNzU3luY2hyb25pemF0aW9uUGFja2V0IiwiX2NhbGxBY2NvdW50RXZlbnRzIiwiY29uY2F0IiwicXVldWVFdmVudCIsImV2ZW50Iiwic2hpZnQiLCJfdHJ5UmVjb25uZWN0Iiwic2V0VGltZW91dCIsInJlcXVlc3QiLCJnZXRUaW1lIiwiaW5kZXgiLCJhY2NvdW50Q291bnRlciIsIl9tYWtlUmVxdWVzdCIsInJldHJ5Q291bnRlciIsIm5hbWUiLCJjYWxjUmV0cnlDb3VudGVyIiwiY2FsY1JlcXVlc3RUaW1lIiwibWluIiwicG93IiwicmV0cnlUaW1lIiwiY2xpZW50UHJvY2Vzc2luZ1N0YXJ0ZWQiLCJyYWNlIiwiZW1pdCIsIlZhbGlkYXRpb25FcnJvciIsImRldGFpbHMiLCJOb3RTeW5jaHJvbml6ZWRFcnJvciIsIk5vdENvbm5lY3RlZEVycm9yIiwiVW5hdXRob3JpemVkRXJyb3IiLCJUb29NYW55UmVxdWVzdHNFcnJvciIsIkludGVybmFsRXJyb3IiLCJmaWVsZCIsInZhbHVlIiwibWF0Y2giLCJBcnJheSIsImlzQXJyYXkiLCJpdGVtIiwicHJpY2VzIiwidXBkYXRlU3luY2hyb25pemF0aW9uSWQiLCJpc09ubHlBY3RpdmVJbnN0YW5jZSIsImFjdGl2ZUluc3RhbmNlSWRzIiwic3RhcnRzV2l0aCIsImNhbmNlbERpc2Nvbm5lY3RUaW1lciIsImNsZWFyVGltZW91dCIsInJlc2V0RGlzY29ubmVjdFRpbWVyIiwib25UaW1lb3V0Iiwib25EaXNjb25uZWN0ZWQiLCJpc1RpbWVvdXQiLCJvbkRpc2Nvbm5lY3RlZFByb21pc2VzIiwiYWxsIiwib25TdHJlYW1DbG9zZWRQcm9taXNlcyIsIm9uU3RyZWFtQ2xvc2VkIiwicmVtb3ZlSWRCeVBhcmFtZXRlcnMiLCJvbkNvbm5lY3RlZFByb21pc2VzIiwib25Db25uZWN0ZWQiLCJyZXBsaWNhcyIsImNhbmNlbFN1YnNjcmliZSIsInByb21pc2VzIiwib25TeW5jaHJvbml6YXRpb25TdGFydGVkIiwib25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkUHJvbWlzZXMiLCJvbkFjY291bnRJbmZvcm1hdGlvblVwZGF0ZWQiLCJkZWFsIiwib25EZWFsQWRkZWRQcm9taXNlcyIsIm9uRGVhbEFkZGVkIiwib25PcmRlclVwZGF0ZWRQcm9taXNlcyIsIm9uT3JkZXJzUmVwbGFjZWQiLCJoaXN0b3J5T3JkZXIiLCJvbkhpc3RvcnlPcmRlckFkZGVkUHJvbWlzZXMiLCJvbkhpc3RvcnlPcmRlckFkZGVkIiwib25Qb3NpdGlvblVwZGF0ZWRQcm9taXNlcyIsIm9uUG9zaXRpb25zUmVwbGFjZWQiLCJ1cGRhdGVkUG9zaXRpb25zIiwib25Qb3NpdGlvblVwZGF0ZWQiLCJyZW1vdmVkUG9zaXRpb25JZHMiLCJvblBvc2l0aW9uUmVtb3ZlZFByb21pc2VzIiwib25Qb3NpdGlvblJlbW92ZWQiLCJ1cGRhdGVkT3JkZXJzIiwib25PcmRlclVwZGF0ZWQiLCJjb21wbGV0ZWRPcmRlcklkcyIsIm9uT3JkZXJDb21wbGV0ZWRQcm9taXNlcyIsIm9uT3JkZXJDb21wbGV0ZWQiLCJvblVwZGF0ZVByb21pc2VzIiwib25VcGRhdGUiLCJvbkRlYWxTeW5jaHJvbml6YXRpb25GaW5pc2hlZFByb21pc2VzIiwicmVtb3ZlU3luY2hyb25pemF0aW9uSWQiLCJvbkRlYWxTeW5jaHJvbml6YXRpb25GaW5pc2hlZCIsIm9uT3JkZXJTeW5jaHJvbml6YXRpb25GaW5pc2hlZFByb21pc2VzIiwib25PcmRlclN5bmNocm9uaXphdGlvbkZpbmlzaGVkIiwiYXV0aGVudGljYXRlZCIsImlzRGlzY29ubmVjdGVkUmV0cnlNb2RlIiwiaXNBY2NvdW50U3Vic2NyaWJpbmciLCJvbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkUHJvbWlzZXMiLCJvbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkIiwiaGVhbHRoU3RhdHVzIiwib25IZWFsdGhTdGF0dXNQcm9taXNlcyIsIm9uSGVhbHRoU3RhdHVzIiwidXBkYXRlcyIsInVuc3Vic2NyaXB0aW9ucyIsIm9uU3Vic2NyaXB0aW9uRG93bmdyYWRlUHJvbWlzZXMiLCJvblN1YnNjcmlwdGlvbkRvd25ncmFkZWQiLCJvblN5bWJvbFNwZWNpZmljYXRpb25zVXBkYXRlZFByb21pc2VzIiwib25TeW1ib2xTcGVjaWZpY2F0aW9uc1VwZGF0ZWQiLCJzcGVjaWZpY2F0aW9ucyIsInJlbW92ZWRTeW1ib2xzIiwib25TeW1ib2xTcGVjaWZpY2F0aW9uVXBkYXRlZFByb21pc2VzIiwib25TeW1ib2xTcGVjaWZpY2F0aW9uVXBkYXRlZCIsInJlbW92ZWRTeW1ib2wiLCJvblN5bWJvbFNwZWNpZmljYXRpb25SZW1vdmVkUHJvbWlzZXMiLCJvblN5bWJvbFNwZWNpZmljYXRpb25SZW1vdmVkIiwiY2FuZGxlcyIsInRpY2tzIiwiYm9va3MiLCJvblN5bWJvbFByaWNlc1VwZGF0ZWRQcm9taXNlcyIsIm9uU3ltYm9sUHJpY2VzVXBkYXRlZCIsImVxdWl0eSIsIm1hcmdpbiIsImZyZWVNYXJnaW4iLCJtYXJnaW5MZXZlbCIsImFjY291bnRDdXJyZW5jeUV4Y2hhbmdlUmF0ZSIsIm9uQ2FuZGxlc1VwZGF0ZWQiLCJvblRpY2tzVXBkYXRlZCIsIm9uQm9va3NVcGRhdGVkIiwib25TeW1ib2xQcmljZVVwZGF0ZWRQcm9taXNlcyIsIm9uU3ltYm9sUHJpY2VVcGRhdGVkIiwib25TeW1ib2xQcmljZVByb21pc2VzIiwib25TeW1ib2xQcmljZSIsInJlY29ubmVjdExpc3RlbmVycyIsInJlY29ubmVjdEFjY291bnRJZHMiLCJvblJlY29u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LEdBQTFGLENBSHNDLENBQTFDO0FBSUQ7QUFDRixLQWpCRCxDQWlCRSxPQUFPQSxHQUFQLEVBQVk7QUFDWjtBQUNBekUsY0FBUUMsS0FBUixDQUFjLE1BQU8sSUFBSUMsSUFBSixFQUFELENBQWFDLFdBQWIsRUFBTixHQUFtQyx1Q0FBakQsRUFBMEZzRSxHQUExRjtBQUNEO0FBQ0Y7O0FBRUQsUUFBTWxCLGFBQU4sR0FBc0I7QUFDcEIsUUFBRyxLQUFLbkYsbUJBQVIsRUFBNkI7QUFDM0IsYUFBTyxLQUFLcEIsSUFBWjtBQUNELEtBRkQsTUFFTztBQUNMLFlBQU1YLE9BQU87QUFDWGlFLGFBQU0sa0NBQWlDLEtBQUt4RCxPQUFRLHNDQUR6QztBQUVYMFcsZ0JBQVEsS0FGRztBQUdYQyxpQkFBUztBQUNQLHdCQUFjLEtBQUtuVjtBQURaLFNBSEU7QUFNWG9WLGNBQU07QUFOSyxPQUFiO0FBUUEsWUFBTXhOLFdBQVcsTUFBTSxLQUFLdkosV0FBTCxDQUFpQnFQLE9BQWpCLENBQXlCM1AsSUFBekIsQ0FBdkI7QUFDQSxhQUFPNkosU0FBUzVGLEdBQWhCO0FBQ0Q7QUFDRjs7QUE5MkR5QztrQkFBdkJyRSxzQiIsImZpbGUiOiJtZXRhQXBpV2Vic29ja2V0LmNsaWVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHJhbmRvbXN0cmluZyBmcm9tICdyYW5kb21zdHJpbmcnO1xuaW1wb3J0IHNvY2tldElPIGZyb20gJ3NvY2tldC5pby1jbGllbnQnO1xuaW1wb3J0IFRpbWVvdXRFcnJvciBmcm9tICcuLi90aW1lb3V0RXJyb3InO1xuaW1wb3J0IHtWYWxpZGF0aW9uRXJyb3IsIE5vdEZvdW5kRXJyb3IsIEludGVybmFsRXJyb3IsIFVuYXV0aG9yaXplZEVycm9yLCBUb29NYW55UmVxdWVzdHNFcnJvcn0gZnJvbSAnLi4vZXJyb3JIYW5kbGVyJztcbmltcG9ydCBPcHRpb25zVmFsaWRhdG9yIGZyb20gJy4uL29wdGlvbnNWYWxpZGF0b3InO1xuaW1wb3J0IE5vdFN5bmNocm9uaXplZEVycm9yIGZyb20gJy4vbm90U3luY2hyb25pemVkRXJyb3InO1xuaW1wb3J0IE5vdENvbm5lY3RlZEVycm9yIGZyb20gJy4vbm90Q29ubmVjdGVkRXJyb3InO1xuaW1wb3J0IFRyYWRlRXJyb3IgZnJvbSAnLi90cmFkZUVycm9yJztcbmltcG9ydCBQYWNrZXRPcmRlcmVyIGZyb20gJy4vcGFja2V0T3JkZXJlcic7XG5pbXBvcnQgU3luY2hyb25pemF0aW9uVGhyb3R0bGVyIGZyb20gJy4vc3luY2hyb25pemF0aW9uVGhyb3R0bGVyJztcbmltcG9ydCBTdWJzY3JpcHRpb25NYW5hZ2VyIGZyb20gJy4vc3Vic2NyaXB0aW9uTWFuYWdlcic7XG5cbmxldCBQYWNrZXRMb2dnZXI7XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHsgLy8gZG9uJ3QgaW1wb3J0IFBhY2tldExvZ2dlciBmb3IgYnJvd3NlciB2ZXJzaW9uXG4gIFBhY2tldExvZ2dlciA9IHJlcXVpcmUoJy4vcGFja2V0TG9nZ2VyJykuZGVmYXVsdDtcbn1cblxuLyoqXG4gKiBNZXRhQXBpIHdlYnNvY2tldCBBUEkgY2xpZW50IChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9vdmVydmlldy8pXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1ldGFBcGlXZWJzb2NrZXRDbGllbnQge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIE1ldGFBcGkgd2Vic29ja2V0IEFQSSBjbGllbnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtIdHRwQ2xpZW50fSBodHRwQ2xpZW50IEhUVFAgY2xpZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbiBhdXRob3JpemF0aW9uIHRva2VuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIHdlYnNvY2tldCBjbGllbnQgb3B0aW9uc1xuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgY29uc3RydWN0b3IoaHR0cENsaWVudCwgdG9rZW4sIG9wdHMpIHtcbiAgICBjb25zdCB2YWxpZGF0b3IgPSBuZXcgT3B0aW9uc1ZhbGlkYXRvcigpO1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIG9wdHMucGFja2V0T3JkZXJpbmdUaW1lb3V0ID0gdmFsaWRhdG9yLnZhbGlkYXRlTm9uWmVybyhvcHRzLnBhY2tldE9yZGVyaW5nVGltZW91dCwgNjAsICdwYWNrZXRPcmRlcmluZ1RpbWVvdXQnKTtcbiAgICBvcHRzLnN5bmNocm9uaXphdGlvblRocm90dGxlciA9IG9wdHMuc3luY2hyb25pemF0aW9uVGhyb3R0bGVyIHx8IHt9O1xuICAgIHRoaXMuX2h0dHBDbGllbnQgPSBodHRwQ2xpZW50O1xuICAgIHRoaXMuX2FwcGxpY2F0aW9uID0gb3B0cy5hcHBsaWNhdGlvbiB8fCAnTWV0YUFwaSc7XG4gICAgdGhpcy5fZG9tYWluID0gb3B0cy5kb21haW4gfHwgJ2FnaWxpdW10cmFkZS5hZ2lsaXVtdHJhZGUuYWknO1xuICAgIHRoaXMuX3VybCA9IGBodHRwczovL210LWNsaWVudC1hcGktdjEuJHt0aGlzLl9kb21haW59YDtcbiAgICB0aGlzLl9yZXF1ZXN0VGltZW91dCA9IHZhbGlkYXRvci52YWxpZGF0ZU5vblplcm8ob3B0cy5yZXF1ZXN0VGltZW91dCwgNjAsICdyZXF1ZXN0VGltZW91dCcpICogMTAwMDtcbiAgICB0aGlzLl9jb25uZWN0VGltZW91dCA9IHZhbGlkYXRvci52YWxpZGF0ZU5vblplcm8ob3B0cy5jb25uZWN0VGltZW91dCwgNjAsICdjb25uZWN0VGltZW91dCcpICogMTAwMDtcbiAgICBjb25zdCByZXRyeU9wdHMgPSBvcHRzLnJldHJ5T3B0cyB8fCB7fTtcbiAgICB0aGlzLl9yZXRyaWVzID0gdmFsaWRhdG9yLnZhbGlkYXRlTnVtYmVyKHJldHJ5T3B0cy5yZXRyaWVzLCA1LCAncmV0cnlPcHRzLnJldHJpZXMnKTtcbiAgICB0aGlzLl9taW5SZXRyeURlbGF5SW5TZWNvbmRzID0gdmFsaWRhdG9yLnZhbGlkYXRlTm9uWmVybyhyZXRyeU9wdHMubWluRGVsYXlJblNlY29uZHMsIDEsXG4gICAgICAncmV0cnlPcHRzLm1pbkRlbGF5SW5TZWNvbmRzJyk7XG4gICAgdGhpcy5fbWF4UmV0cnlEZWxheUluU2Vjb25kcyA9IHZhbGlkYXRvci52YWxpZGF0ZU5vblplcm8ocmV0cnlPcHRzLm1heERlbGF5SW5TZWNvbmRzLCAzMCxcbiAgICAgICdyZXRyeU9wdHMubWF4RGVsYXlJblNlY29uZHMnKTtcbiAgICB0aGlzLl9tYXhBY2NvdW50c1Blckluc3RhbmNlID0gMTAwO1xuICAgIHRoaXMuX3N1YnNjcmliZUNvb2xkb3duSW5TZWNvbmRzID0gdmFsaWRhdG9yLnZhbGlkYXRlTm9uWmVybyhyZXRyeU9wdHMuc3Vic2NyaWJlQ29vbGRvd25JblNlY29uZHMsIDYwMCwgXG4gICAgICAncmV0cnlPcHRzLnN1YnNjcmliZUNvb2xkb3duSW5TZWNvbmRzJyk7XG4gICAgY29uc3QgZXZlbnRQcm9jZXNzaW5nID0gb3B0cy5ldmVudFByb2Nlc3NpbmcgfHwge307XG4gICAgdGhpcy5fc2VxdWVudGlhbEV2ZW50UHJvY2Vzc2luZyA9IHZhbGlkYXRvci52YWxpZGF0ZUJvb2xlYW4oZXZlbnRQcm9jZXNzaW5nLnNlcXVlbnRpYWxQcm9jZXNzaW5nLCBmYWxzZSxcbiAgICAgICdldmVudFByb2Nlc3Npbmcuc2VxdWVudGlhbFByb2Nlc3NpbmcnKTtcbiAgICB0aGlzLl91c2VTaGFyZWRDbGllbnRBcGkgPSB2YWxpZGF0b3IudmFsaWRhdGVCb29sZWFuKG9wdHMudXNlU2hhcmVkQ2xpZW50QXBpLCBmYWxzZSwgJ3VzZVNoYXJlZENsaWVudEFwaScpO1xuICAgIHRoaXMuX3Rva2VuID0gdG9rZW47XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5fbGF0ZW5jeUxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX3JlY29ubmVjdExpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX2Nvbm5lY3RlZEhvc3RzID0ge307XG4gICAgdGhpcy5fc29ja2V0SW5zdGFuY2VzID0gW107XG4gICAgdGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50cyA9IHt9O1xuICAgIHRoaXMuX3N5bmNocm9uaXphdGlvblRocm90dGxlck9wdHMgPSBvcHRzLnN5bmNocm9uaXphdGlvblRocm90dGxlcjtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyID0gbmV3IFN1YnNjcmlwdGlvbk1hbmFnZXIodGhpcyk7XG4gICAgdGhpcy5fc3RhdHVzVGltZXJzID0ge307XG4gICAgdGhpcy5fZXZlbnRRdWV1ZXMgPSB7fTtcbiAgICB0aGlzLl9zdWJzY3JpYmVMb2NrID0gbnVsbDtcbiAgICB0aGlzLl9wYWNrZXRPcmRlcmVyID0gbmV3IFBhY2tldE9yZGVyZXIodGhpcywgb3B0cy5wYWNrZXRPcmRlcmluZ1RpbWVvdXQpO1xuICAgIGlmKG9wdHMucGFja2V0TG9nZ2VyICYmIG9wdHMucGFja2V0TG9nZ2VyLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuX3BhY2tldExvZ2dlciA9IG5ldyBQYWNrZXRMb2dnZXIob3B0cy5wYWNrZXRMb2dnZXIpO1xuICAgICAgdGhpcy5fcGFja2V0TG9nZ2VyLnN0YXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc3RhcnRzIHRoZSBhY2NvdW50IHN5bmNocm9uaXphdGlvbiBwcm9jZXNzIG9uIGFuIG91dCBvZiBvcmRlciBwYWNrZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnN0YW5jZUluZGV4IGluc3RhbmNlIGluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZFNlcXVlbmNlTnVtYmVyIGV4cGVjdGVkIHMvblxuICAgKiBAcGFyYW0ge051bWJlcn0gYWN0dWFsU2VxdWVuY2VOdW1iZXIgYWN0dWFsIHMvblxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IHBhY2tldCBkYXRhXG4gICAqIEBwYXJhbSB7RGF0ZX0gcmVjZWl2ZWRBdCB0aW1lIHRoZSBwYWNrZXQgd2FzIHJlY2VpdmVkIGF0XG4gICAqL1xuICBvbk91dE9mT3JkZXJQYWNrZXQoYWNjb3VudElkLCBpbnN0YW5jZUluZGV4LCBleHBlY3RlZFNlcXVlbmNlTnVtYmVyLCBhY3R1YWxTZXF1ZW5jZU51bWJlciwgcGFja2V0LCByZWNlaXZlZEF0KSB7XG4gICAgY29uc29sZS5lcnJvcihgWyR7KG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCl9XSBNZXRhQXBpIHdlYnNvY2tldCBjbGllbnQgcmVjZWl2ZWQgYW4gb3V0IG9mIG9yZGVyIGAgK1xuICAgICAgYHBhY2tldCB0eXBlICR7cGFja2V0LnR5cGV9IGZvciBhY2NvdW50IGlkICR7YWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9LiBFeHBlY3RlZCBzL24gYCArXG4gICAgICBgJHtleHBlY3RlZFNlcXVlbmNlTnVtYmVyfSBkb2VzIG5vdCBtYXRjaCB0aGUgYWN0dWFsIG9mICR7YWN0dWFsU2VxdWVuY2VOdW1iZXJ9YCk7XG4gICAgdGhpcy5lbnN1cmVTdWJzY3JpYmUoYWNjb3VudElkLCBpbnN0YW5jZUluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXRjaCBzZXJ2ZXIgVVJMIGZvciB1c2UgaW4gdW5pdCB0ZXN0c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIHBhdGNoZWQgc2VydmVyIFVSTFxuICAgKi9cbiAgc2V0IHVybCh1cmwpIHtcbiAgICB0aGlzLl91cmwgPSB1cmw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBzb2NrZXQgaW5zdGFuY2UgZGljdGlvbmFyaWVzXG4gICAqIEByZXR1cm4ge09iamVjdFtdfSBsaXN0IG9mIHNvY2tldCBpbnN0YW5jZSBkaWN0aW9uYXJpZXNcbiAgICovXG4gIGdldCBzb2NrZXRJbnN0YW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvY2tldEluc3RhbmNlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkaWN0aW9uYXJ5IG9mIHNvY2tldCBpbnN0YW5jZXMgYnkgYWNjb3VudCBpZHNcbiAgICogQHJldHVybiB7T2JqZWN0fSBkaWN0aW9uYXJ5IG9mIHNvY2tldCBpbnN0YW5jZXMgYnkgYWNjb3VudCBpZHNcbiAgICovXG4gIGdldCBzb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2Ygc3Vic2NyaWJlZCBhY2NvdW50IGlkc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc29ja2V0SW5zdGFuY2VJbmRleCBzb2NrZXQgaW5zdGFuY2UgaW5kZXhcbiAgICogQHJldHVybiB7c3RyaW5nW119IGxpc3Qgb2Ygc3Vic2NyaWJlZCBhY2NvdW50IGlkc1xuICAgKi9cbiAgc3Vic2NyaWJlZEFjY291bnRJZHMoc29ja2V0SW5zdGFuY2VJbmRleCkge1xuICAgIGNvbnN0IGNvbm5lY3RlZElkcyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX2Nvbm5lY3RlZEhvc3RzKS5mb3JFYWNoKGluc3RhbmNlSWQgPT4ge1xuICAgICAgY29uc3QgYWNjb3VudElkID0gaW5zdGFuY2VJZC5zcGxpdCgnOicpWzBdO1xuICAgICAgaWYoIWNvbm5lY3RlZElkcy5pbmNsdWRlcyhhY2NvdW50SWQpICYmIHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbYWNjb3VudElkXSAhPT0gdW5kZWZpbmVkICYmIChcbiAgICAgICAgdGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1thY2NvdW50SWRdID09PSBzb2NrZXRJbnN0YW5jZUluZGV4IHx8IFxuICAgICAgICBzb2NrZXRJbnN0YW5jZUluZGV4ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIGNvbm5lY3RlZElkcy5wdXNoKGFjY291bnRJZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbm5lY3RlZElkcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdlYnNvY2tldCBjbGllbnQgY29ubmVjdGlvbiBzdGF0dXNcbiAgICogQHBhcmFtIHNvY2tldEluc3RhbmNlSW5kZXggc29ja2V0IGluc3RhbmNlIGluZGV4XG4gICAqIEByZXR1cm5zIHtCb29sZWFufSB3ZWJzb2NrZXQgY2xpZW50IGNvbm5lY3Rpb24gc3RhdHVzXG4gICAqL1xuICBjb25uZWN0ZWQoc29ja2V0SW5zdGFuY2VJbmRleCkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5fc29ja2V0SW5zdGFuY2VzLmxlbmd0aCA+IHNvY2tldEluc3RhbmNlSW5kZXggPyBcbiAgICAgIHRoaXMuX3NvY2tldEluc3RhbmNlc1tzb2NrZXRJbnN0YW5jZUluZGV4XSA6IG51bGw7XG4gICAgcmV0dXJuIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5zb2NrZXQgJiYgaW5zdGFuY2Uuc29ja2V0LmNvbm5lY3RlZCkgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBsaXN0IG9mIGFjY291bnRzIGFzc2lnbmVkIHRvIGluc3RhbmNlXG4gICAqIEBwYXJhbSBzb2NrZXRJbnN0YW5jZUluZGV4IHNvY2tldCBpbnN0YW5jZSBpbmRleFxuICAgKiBAcmV0dXJucyBcbiAgICovXG4gIGdldEFzc2lnbmVkQWNjb3VudHMoc29ja2V0SW5zdGFuY2VJbmRleCkge1xuICAgIGNvbnN0IGFjY291bnRJZHMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAodGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1trZXldID09PSBzb2NrZXRJbnN0YW5jZUluZGV4KSB7XG4gICAgICAgIGFjY291bnRJZHMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhY2NvdW50SWRzO1xuICB9XG5cbiAgLyoqXG4gICAqIExvY2tzIHN1YnNjcmlwdGlvbiBmb3IgYSBzb2NrZXQgaW5zdGFuY2UgYmFzZWQgb24gVG9vTWFueVJlcXVlc3RzRXJyb3IgbWV0YWRhdGFcbiAgICogQHBhcmFtIHNvY2tldEluc3RhbmNlSW5kZXggc29ja2V0IGluc3RhbmNlIGluZGV4XG4gICAqIEBwYXJhbSBtZXRhZGF0YSBUb29NYW55UmVxdWVzdHNFcnJvciBtZXRhZGF0YVxuICAgKi9cbiAgYXN5bmMgbG9ja1NvY2tldEluc3RhbmNlKHNvY2tldEluc3RhbmNlSW5kZXgsIG1ldGFkYXRhKSB7XG4gICAgaWYgKG1ldGFkYXRhLnR5cGUgPT09ICdMSU1JVF9BQ0NPVU5UX1NVQlNDUklQVElPTlNfUEVSX1VTRVInKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpYmVMb2NrID0ge1xuICAgICAgICByZWNvbW1lbmRlZFJldHJ5VGltZTogbWV0YWRhdGEucmVjb21tZW5kZWRSZXRyeVRpbWUsXG4gICAgICAgIGxvY2tlZEF0QWNjb3VudHM6IHRoaXMuc3Vic2NyaWJlZEFjY291bnRJZHMoKS5sZW5ndGgsXG4gICAgICAgIGxvY2tlZEF0VGltZTogRGF0ZS5ub3coKVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3Vic2NyaWJlZEFjY291bnRzID0gdGhpcy5zdWJzY3JpYmVkQWNjb3VudElkcyhzb2NrZXRJbnN0YW5jZUluZGV4KTtcbiAgICAgIGlmIChzdWJzY3JpYmVkQWNjb3VudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IHNvY2tldEluc3RhbmNlID0gdGhpcy5zb2NrZXRJbnN0YW5jZXNbc29ja2V0SW5zdGFuY2VJbmRleF07XG4gICAgICAgIHNvY2tldEluc3RhbmNlLnNvY2tldC5jbG9zZSgpO1xuICAgICAgICBhd2FpdCB0aGlzLl9yZWNvbm5lY3Qoc29ja2V0SW5zdGFuY2VJbmRleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuX3NvY2tldEluc3RhbmNlc1tzb2NrZXRJbnN0YW5jZUluZGV4XTtcbiAgICAgICAgaW5zdGFuY2Uuc3Vic2NyaWJlTG9jayA9IHtcbiAgICAgICAgICByZWNvbW1lbmRlZFJldHJ5VGltZTogbWV0YWRhdGEucmVjb21tZW5kZWRSZXRyeVRpbWUsXG4gICAgICAgICAgdHlwZTogbWV0YWRhdGEudHlwZSxcbiAgICAgICAgICBsb2NrZWRBdEFjY291bnRzOiBzdWJzY3JpYmVkQWNjb3VudHMubGVuZ3RoXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRvIE1ldGFBcGkgc2VydmVyIHZpYSBzb2NrZXQuaW8gcHJvdG9jb2xcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkXG4gICAqL1xuICBhc3luYyBjb25uZWN0KCkge1xuICAgIGxldCBjbGllbnRJZCA9IE1hdGgucmFuZG9tKCk7XG4gICAgbGV0IHJlc29sdmUsIHJlamVjdDtcbiAgICBsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICBsZXQgcmVzdWx0ID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICByZXNvbHZlID0gcmVzO1xuICAgICAgcmVqZWN0ID0gcmVqO1xuICAgIH0pO1xuICAgIGNvbnN0IHNvY2tldEluc3RhbmNlSW5kZXggPSB0aGlzLl9zb2NrZXRJbnN0YW5jZXMubGVuZ3RoO1xuICAgIGNvbnN0IGluc3RhbmNlID0ge1xuICAgICAgaWQ6IHNvY2tldEluc3RhbmNlSW5kZXgsXG4gICAgICBjb25uZWN0ZWQ6IGZhbHNlLFxuICAgICAgcmVxdWVzdFJlc29sdmVzOiB7fSxcbiAgICAgIHJlc29sdmVkOiBmYWxzZSxcbiAgICAgIGNvbm5lY3RSZXN1bHQ6IHJlc3VsdCxcbiAgICAgIHNlc3Npb25JZDogcmFuZG9tc3RyaW5nLmdlbmVyYXRlKDMyKSxcbiAgICAgIGlzUmVjb25uZWN0aW5nOiBmYWxzZSxcbiAgICAgIHNvY2tldDogbnVsbCxcbiAgICAgIHN5bmNocm9uaXphdGlvblRocm90dGxlcjogbmV3IFN5bmNocm9uaXphdGlvblRocm90dGxlcih0aGlzLCBzb2NrZXRJbnN0YW5jZUluZGV4LFxuICAgICAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25UaHJvdHRsZXJPcHRzKSxcbiAgICAgIHN1YnNjcmliZUxvY2s6IG51bGxcbiAgICB9O1xuICAgIGluc3RhbmNlLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgdGhpcy5fc29ja2V0SW5zdGFuY2VzLnB1c2goaW5zdGFuY2UpO1xuICAgIGNvbnN0IHNlcnZlclVybCA9IGF3YWl0IHRoaXMuX2dldFNlcnZlclVybCgpO1xuICAgIGluc3RhbmNlLnN5bmNocm9uaXphdGlvblRocm90dGxlci5zdGFydCgpO1xuICAgIGNvbnN0IHNvY2tldEluc3RhbmNlID0gc29ja2V0SU8oc2VydmVyVXJsLCB7XG4gICAgICBwYXRoOiAnL3dzJyxcbiAgICAgIHJlY29ubmVjdGlvbjogdHJ1ZSxcbiAgICAgIHJlY29ubmVjdGlvbkRlbGF5OiAxMDAwLFxuICAgICAgcmVjb25uZWN0aW9uRGVsYXlNYXg6IDUwMDAsXG4gICAgICByZWNvbm5lY3Rpb25BdHRlbXB0czogSW5maW5pdHksXG4gICAgICB0aW1lb3V0OiB0aGlzLl9jb25uZWN0VGltZW91dCxcbiAgICAgIGV4dHJhSGVhZGVyczoge1xuICAgICAgICAnQ2xpZW50LUlkJzogY2xpZW50SWRcbiAgICAgIH0sXG4gICAgICBxdWVyeToge1xuICAgICAgICAnYXV0aC10b2tlbic6IHRoaXMuX3Rva2VuLFxuICAgICAgICBjbGllbnRJZDogY2xpZW50SWQsXG4gICAgICAgIHByb3RvY29sOiAyXG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGZpcnN0Q29ubmVjdCA9IHRydWU7XG4gICAgaW5zdGFuY2Uuc29ja2V0ID0gc29ja2V0SW5zdGFuY2U7XG4gICAgaWYgKHRoaXMuX3NvY2tldEluc3RhbmNlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuX3BhY2tldE9yZGVyZXIuc3RhcnQoKTtcbiAgICB9IFxuICAgIHNvY2tldEluc3RhbmNlLm9uKCdjb25uZWN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaXNTaGFyZWRDbGllbnRBcGkgPSBzb2NrZXRJbnN0YW5jZS5pby51cmkgPT09IHRoaXMuX3VybDtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmxvZygnWycgKyAobmV3IERhdGUoKSkudG9JU09TdHJpbmcoKSArICddIE1ldGFBcGkgd2Vic29ja2V0IGNsaWVudCBjb25uZWN0ZWQgdG8gdGhlIE1ldGFBcGkgc2VydmVyICcrXG4gICAgICAgIGB2aWEgJHtzb2NrZXRJbnN0YW5jZS5pby51cml9ICR7aXNTaGFyZWRDbGllbnRBcGkgPyAnc2hhcmVkJyA6ICdkZWRpY2F0ZWQnfSBzZXJ2ZXJgKTtcbiAgICAgIGlmIChzb2NrZXRJbnN0YW5jZUluZGV4ID09PSAwICYmIGZpcnN0Q29ubmVjdCAmJiAhaXNTaGFyZWRDbGllbnRBcGkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1BsZWFzZSBub3RlIHRoYXQgaXQgY2FuIHRha2UgdXAgdG8gMyBtaW51dGVzIGZvciB5b3VyIGRlZGljYXRlZCBzZXJ2ZXIgdG8gc3RhcnQgZm9yIHRoZSAnICtcbiAgICAgICAgJ2ZpcnN0IHRpbWUuIER1cmluZyB0aGlzIHRpbWUgaXQgaXMgT0sgaWYgeW91IHNlZSBzb21lIGNvbm5lY3Rpb24gZXJyb3JzLicpO1xuICAgICAgICBmaXJzdENvbm5lY3QgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGluc3RhbmNlLmlzUmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICBpZiAoIXJlc29sdmVkKSB7XG4gICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fZmlyZVJlY29ubmVjdGVkKGluc3RhbmNlLmlkKTtcbiAgICAgIH1cbiAgICAgIGlmICghaW5zdGFuY2UuY29ubmVjdGVkKSB7XG4gICAgICAgIGluc3RhbmNlLnNvY2tldC5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNvY2tldEluc3RhbmNlLm9uKCdyZWNvbm5lY3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBpbnN0YW5jZS5pc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgYXdhaXQgdGhpcy5fZmlyZVJlY29ubmVjdGVkKGluc3RhbmNlLmlkKTtcbiAgICB9KTtcbiAgICBzb2NrZXRJbnN0YW5jZS5vbignY29ubmVjdF9lcnJvcicsIChlcnIpID0+IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmxvZygnWycgKyAobmV3IERhdGUoKSkudG9JU09TdHJpbmcoKSArICddIE1ldGFBcGkgd2Vic29ja2V0IGNsaWVudCBjb25uZWN0aW9uIGVycm9yJywgZXJyKTtcbiAgICAgIGluc3RhbmNlLmlzUmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICBpZiAoIXJlc29sdmVkKSB7XG4gICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ2Nvbm5lY3RfdGltZW91dCcsICh0aW1lb3V0KSA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5sb2coJ1snICsgKG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCkgKyAnXSBNZXRhQXBpIHdlYnNvY2tldCBjbGllbnQgY29ubmVjdGlvbiB0aW1lb3V0Jyk7XG4gICAgICBpbnN0YW5jZS5pc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgICByZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIHJlamVjdChuZXcgVGltZW91dEVycm9yKCdNZXRhQXBpIHdlYnNvY2tldCBjbGllbnQgY29ubmVjdGlvbiB0aW1lZCBvdXQnKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ2Rpc2Nvbm5lY3QnLCBhc3luYyAocmVhc29uKSA9PiB7XG4gICAgICBpbnN0YW5jZS5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIub25EaXNjb25uZWN0KCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5sb2coJ1snICsgKG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCkgKyAnXSBNZXRhQXBpIHdlYnNvY2tldCBjbGllbnQgZGlzY29ubmVjdGVkIGZyb20gdGhlIE1ldGFBcGkgJyArXG4gICAgICAgICAgJ3NlcnZlciBiZWNhdXNlIG9mICcgKyByZWFzb24pO1xuICAgICAgaW5zdGFuY2UuaXNSZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgIGF3YWl0IHRoaXMuX3JlY29ubmVjdChpbnN0YW5jZS5pZCk7XG4gICAgfSk7XG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ2Vycm9yJywgYXN5bmMgKGVycm9yKSA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5lcnJvcignWycgKyAobmV3IERhdGUoKSkudG9JU09TdHJpbmcoKSArICddIE1ldGFBcGkgd2Vic29ja2V0IGNsaWVudCBlcnJvcicsIGVycm9yKTtcbiAgICAgIGluc3RhbmNlLmlzUmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICBhd2FpdCB0aGlzLl9yZWNvbm5lY3QoaW5zdGFuY2UuaWQpO1xuICAgIH0pO1xuICAgIHNvY2tldEluc3RhbmNlLm9uKCdyZXNwb25zZScsIGRhdGEgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH1cbiAgICAgIGxldCByZXF1ZXN0UmVzb2x2ZSA9IChpbnN0YW5jZS5yZXF1ZXN0UmVzb2x2ZXNbZGF0YS5yZXF1ZXN0SWRdIHx8IHtyZXNvbHZlOiAoKSA9PiB7fSwgcmVqZWN0OiAoKSA9PiB7fX0pO1xuICAgICAgZGVsZXRlIGluc3RhbmNlLnJlcXVlc3RSZXNvbHZlc1tkYXRhLnJlcXVlc3RJZF07XG4gICAgICB0aGlzLl9jb252ZXJ0SXNvVGltZVRvRGF0ZShkYXRhKTtcbiAgICAgIHJlcXVlc3RSZXNvbHZlLnJlc29sdmUoZGF0YSk7XG4gICAgICBpZiAoZGF0YS50aW1lc3RhbXBzICYmIHJlcXVlc3RSZXNvbHZlLnR5cGUpIHtcbiAgICAgICAgZGF0YS50aW1lc3RhbXBzLmNsaWVudFByb2Nlc3NpbmdGaW5pc2hlZCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX2xhdGVuY3lMaXN0ZW5lcnMpIHtcbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gcmVxdWVzdFJlc29sdmUudHlwZSA9PT0gJ3RyYWRlJyA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLm9uVHJhZGUoZGF0YS5hY2NvdW50SWQsIGRhdGEudGltZXN0YW1wcykgOlxuICAgICAgICAgICAgICBsaXN0ZW5lci5vblJlc3BvbnNlKGRhdGEuYWNjb3VudElkLCByZXF1ZXN0UmVzb2x2ZS50eXBlLCBkYXRhLnRpbWVzdGFtcHMpKVxuICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IGNvbnNvbGUuZXJyb3IoJ1snICsgKG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCkgKyAnXSBGYWlsZWQgdG8gcHJvY2VzcyBvblJlc3BvbnNlICcgK1xuICAgICAgICAgICAgICAgICdldmVudCBmb3IgYWNjb3VudCAnICsgZGF0YS5hY2NvdW50SWQgKyAnLCByZXF1ZXN0IHR5cGUgJyArIHJlcXVlc3RSZXNvbHZlLnR5cGUsIGVycm9yKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBzb2NrZXRJbnN0YW5jZS5vbigncHJvY2Vzc2luZ0Vycm9yJywgZGF0YSA9PiB7XG4gICAgICBsZXQgcmVxdWVzdFJlc29sdmUgPSAoaW5zdGFuY2UucmVxdWVzdFJlc29sdmVzW2RhdGEucmVxdWVzdElkXSB8fCB7cmVzb2x2ZTogKCkgPT4ge30sIHJlamVjdDogKCkgPT4ge319KTtcbiAgICAgIGRlbGV0ZSBpbnN0YW5jZS5yZXF1ZXN0UmVzb2x2ZXNbZGF0YS5yZXF1ZXN0SWRdO1xuICAgICAgcmVxdWVzdFJlc29sdmUucmVqZWN0KHRoaXMuX2NvbnZlcnRFcnJvcihkYXRhKSk7XG4gICAgfSk7XG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ3N5bmNocm9uaXphdGlvbicsIGFzeW5jIGRhdGEgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmKCghZGF0YS5zeW5jaHJvbml6YXRpb25JZCkgfHxcbiAgICAgIGluc3RhbmNlLnN5bmNocm9uaXphdGlvblRocm90dGxlci5hY3RpdmVTeW5jaHJvbml6YXRpb25JZHNcbiAgICAgICAgLmluY2x1ZGVzKGRhdGEuc3luY2hyb25pemF0aW9uSWQpKSB7XG4gICAgICAgIGlmKHRoaXMuX3BhY2tldExvZ2dlcikge1xuICAgICAgICAgIGF3YWl0IHRoaXMuX3BhY2tldExvZ2dlci5sb2dQYWNrZXQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udmVydElzb1RpbWVUb0RhdGUoZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLnR5cGUgPSAnbm9vcCc7XG4gICAgICB9XG4gICAgICB0aGlzLnF1ZXVlUGFja2V0KGRhdGEpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIGNvbm5lY3Rpb24gdG8gTWV0YUFwaSBzZXJ2ZXJcbiAgICovXG4gIGNsb3NlKCkge1xuICAgIHRoaXMuX3NvY2tldEluc3RhbmNlcy5mb3JFYWNoKGFzeW5jIChpbnN0YW5jZSkgPT4ge1xuICAgICAgaWYgKGluc3RhbmNlLmNvbm5lY3RlZCkge1xuICAgICAgICBpbnN0YW5jZS5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgYXdhaXQgaW5zdGFuY2Uuc29ja2V0LmNsb3NlKCk7XG4gICAgICAgIGZvciAobGV0IHJlcXVlc3RSZXNvbHZlIG9mIE9iamVjdC52YWx1ZXMoaW5zdGFuY2UucmVxdWVzdFJlc29sdmVzKSkge1xuICAgICAgICAgIHJlcXVlc3RSZXNvbHZlLnJlamVjdChuZXcgRXJyb3IoJ01ldGFBcGkgY29ubmVjdGlvbiBjbG9zZWQnKSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UucmVxdWVzdFJlc29sdmVzID0ge307XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5fbGF0ZW5jeUxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHMgPSB7fTtcbiAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXMgPSBbXTtcbiAgICB0aGlzLl9wYWNrZXRPcmRlcmVyLnN0b3AoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRhVHJhZGVyIGFjY291bnQgaW5mb3JtYXRpb24gKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvbW9kZWxzL21ldGF0cmFkZXJBY2NvdW50SW5mb3JtYXRpb24vKVxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhdHJhZGVyQWNjb3VudEluZm9ybWF0aW9uXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwbGF0Zm9ybSBwbGF0Zm9ybSBpZCAobXQ0IG9yIG10NSlcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGJyb2tlciBicm9rZXIgbmFtZVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gY3VycmVuY3kgYWNjb3VudCBiYXNlIGN1cnJlbmN5IElTTyBjb2RlXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzZXJ2ZXIgYnJva2VyIHNlcnZlciBuYW1lXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBiYWxhbmNlIGFjY291bnQgYmFsYW5jZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gZXF1aXR5IGFjY291bnQgbGlxdWlkYXRpb24gdmFsdWVcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG1hcmdpbiB1c2VkIG1hcmdpblxuICAgKiBAcHJvcGVydHkge051bWJlcn0gZnJlZU1hcmdpbiBmcmVlIG1hcmdpblxuICAgKiBAcHJvcGVydHkge051bWJlcn0gbGV2ZXJhZ2UgYWNjb3VudCBsZXZlcmFnZSBjb2VmZmljaWVudFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gbWFyZ2luTGV2ZWwgbWFyZ2luIGxldmVsIGNhbGN1bGF0ZWQgYXMgJSBvZiBlcXVpdHkvbWFyZ2luXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gdHJhZGVBbGxvd2VkIGZsYWcgaW5kaWNhdGluZyB0aGF0IHRyYWRpbmcgaXMgYWxsb3dlZFxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtpbnZlc3Rvck1vZGVdIGZsYWcgaW5kaWNhdGluZyB0aGF0IGludmVzdG9yIHBhc3N3b3JkIHdhcyB1c2VkIChzdXBwb3J0ZWQgZm9yIGcyIG9ubHkpXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBtYXJnaW5Nb2RlIG1hcmdpbiBjYWxjdWxhdGlvbiBtb2RlLCBvbmUgb2YgQUNDT1VOVF9NQVJHSU5fTU9ERV9FWENIQU5HRSxcbiAgICogQUNDT1VOVF9NQVJHSU5fTU9ERV9SRVRBSUxfTkVUVElORywgQUNDT1VOVF9NQVJHSU5fTU9ERV9SRVRBSUxfSEVER0lOR1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gbmFtZSBBY2NvdW50IG93bmVyIG5hbWVcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGxvZ2luIEFjY291bnQgbG9naW5cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGNyZWRpdCBBY2NvdW50IGNyZWRpdCBpbiB0aGUgZGVwb3NpdCBjdXJyZW5jeVxuICAgKi9cblxuICAvKipcbiAgICogUmV0dXJucyBhY2NvdW50IGluZm9ybWF0aW9uIGZvciBhIHNwZWNpZmllZCBNZXRhVHJhZGVyIGFjY291bnQgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZWFkVHJhZGluZ1Rlcm1pbmFsU3RhdGUvcmVhZEFjY291bnRJbmZvcm1hdGlvbi8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGZvclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVyQWNjb3VudEluZm9ybWF0aW9uPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBhY2NvdW50IGluZm9ybWF0aW9uXG4gICAqL1xuICBhc3luYyBnZXRBY2NvdW50SW5mb3JtYXRpb24oYWNjb3VudElkKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRBY2NvdW50SW5mb3JtYXRpb24nfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmFjY291bnRJbmZvcm1hdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRhVHJhZGVyIHBvc2l0aW9uXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJQb3NpdGlvblxuICAgKiBAcHJvcGVydHkge051bWJlcn0gaWQgcG9zaXRpb24gaWQgKHRpY2tldCBudW1iZXIpXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0eXBlIHBvc2l0aW9uIHR5cGUgKG9uZSBvZiBQT1NJVElPTl9UWVBFX0JVWSwgUE9TSVRJT05fVFlQRV9TRUxMKVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gc3ltYm9sIHBvc2l0aW9uIHN5bWJvbFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gbWFnaWMgcG9zaXRpb24gbWFnaWMgbnVtYmVyLCBpZGVudGlmaWVzIHRoZSBFQSB3aGljaCBvcGVuZWQgdGhlIHBvc2l0aW9uXG4gICAqIEBwcm9wZXJ0eSB7RGF0ZX0gdGltZSB0aW1lIHBvc2l0aW9uIHdhcyBvcGVuZWQgYXRcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGJyb2tlclRpbWUgdGltZSBwb3NpdGlvbiB3YXMgb3BlbmVkIGF0LCBpbiBicm9rZXIgdGltZXpvbmUsIFlZWVktTU0tREQgSEg6bW06c3MuU1NTIGZvcm1hdFxuICAgKiBAcHJvcGVydHkge0RhdGV9IHVwZGF0ZVRpbWUgbGFzdCBwb3NpdGlvbiBtb2RpZmljYXRpb24gdGltZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gb3BlblByaWNlIHBvc2l0aW9uIG9wZW4gcHJpY2VcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGN1cnJlbnRQcmljZSBjdXJyZW50IHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjdXJyZW50VGlja1ZhbHVlIGN1cnJlbnQgdGljayB2YWx1ZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW3N0b3BMb3NzXSBvcHRpb25hbCBwb3NpdGlvbiBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFt0YWtlUHJvZml0XSBvcHRpb25hbCBwb3NpdGlvbiB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gdm9sdW1lIHBvc2l0aW9uIHZvbHVtZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gc3dhcCBwb3NpdGlvbiBjdW11bGF0aXZlIHN3YXBcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHByb2ZpdCBwb3NpdGlvbiBjdW11bGF0aXZlIHByb2ZpdFxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2NvbW1lbnRdIG9wdGlvbmFsIHBvc2l0aW9uIGNvbW1lbnQuIFRoZSBzdW0gb2YgdGhlIGxpbmUgbGVuZ3RocyBvZiB0aGUgY29tbWVudCBhbmQgdGhlIGNsaWVudElkXG4gICAqIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDI2LiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L2NsaWVudElkVXNhZ2UvXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbY2xpZW50SWRdIG9wdGlvbmFsIGNsaWVudC1hc3NpZ25lZCBpZC4gVGhlIGlkIHZhbHVlIGNhbiBiZSBhc3NpZ25lZCB3aGVuIHN1Ym1pdHRpbmcgYSB0cmFkZSBhbmRcbiAgICogd2lsbCBiZSBwcmVzZW50IG9uIHBvc2l0aW9uLCBoaXN0b3J5IG9yZGVycyBhbmQgaGlzdG9yeSBkZWFscyByZWxhdGVkIHRvIHRoZSB0cmFkZS4gWW91IGNhbiB1c2UgdGhpcyBmaWVsZCB0byBiaW5kXG4gICAqIHlvdXIgdHJhZGVzIHRvIG9iamVjdHMgaW4geW91ciBhcHBsaWNhdGlvbiBhbmQgdGhlbiB0cmFjayB0cmFkZSBwcm9ncmVzcy4gVGhlIHN1bSBvZiB0aGUgbGluZSBsZW5ndGhzIG9mIHRoZVxuICAgKiBjb21tZW50IGFuZCB0aGUgY2xpZW50SWQgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMjYuIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvY2xpZW50SWRVc2FnZS9cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHVucmVhbGl6ZWRQcm9maXQgcHJvZml0IG9mIHRoZSBwYXJ0IG9mIHRoZSBwb3NpdGlvbiB3aGljaCBpcyBub3QgeWV0IGNsb3NlZCwgaW5jbHVkaW5nIHN3YXBcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHJlYWxpemVkUHJvZml0IHByb2ZpdCBvZiB0aGUgYWxyZWFkeSBjbG9zZWQgcGFydCwgaW5jbHVkaW5nIGNvbW1pc3Npb25zIGFuZCBzd2FwXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb21taXNzaW9uIHBvc2l0aW9uIGNvbW1pc3Npb25cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHJlYXNvbiBwb3NpdGlvbiBvcGVuaW5nIHJlYXNvbi4gT25lIG9mIFBPU0lUSU9OX1JFQVNPTl9DTElFTlQsIFBPU0lUSU9OX1JFQVNPTl9FWFBFUlQsXG4gICAqIFBPU0lUSU9OX1JFQVNPTl9NT0JJTEUsIFBPU0lUSU9OX1JFQVNPTl9XRUIsIFBPU0lUSU9OX1JFQVNPTl9VTktOT1dOLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvdHJhZGluZ2NvbnN0YW50cy9wb3NpdGlvbnByb3BlcnRpZXMjZW51bV9wb3NpdGlvbl9yZWFzb24nLFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW2FjY291bnRDdXJyZW5jeUV4Y2hhbmdlUmF0ZV0gY3VycmVudCBleGNoYW5nZSByYXRlIG9mIGFjY291bnQgY3VycmVuY3kgaW50byBhY2NvdW50IGJhc2VcbiAgICogY3VycmVuY3kgKFVTRCBpZiB5b3UgZGlkIG5vdCBvdmVycmlkZSBpdClcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtvcmlnaW5hbENvbW1lbnRdIHBvc2l0aW9uIG9yaWdpbmFsIGNvbW1lbnQgKHByZXNlbnQgaWYgcG9zc2libGUgdG8gcmVzdG9yZSBmcm9tIGhpc3RvcnkpXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbdXBkYXRlUGVuZGluZ10gZmxhZyBpbmRpY2F0aW5nIHRoYXQgcG9zaXRpb24gb3JpZ2luYWwgY29tbWVudCBhbmQgY2xpZW50SWQgd2FzIG5vdCBpZGVudGlmaWVkXG4gICAqIHlldCBhbmQgd2lsbCBiZSB1cGRhdGVkIGluIGEgZnV0dXJlIHBhY2tldFxuICAgKi9cblxuICAvKipcbiAgICogUmV0dXJucyBwb3NpdGlvbnMgZm9yIGEgc3BlY2lmaWVkIE1ldGFUcmFkZXIgYWNjb3VudCAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JlYWRUcmFkaW5nVGVybWluYWxTdGF0ZS9yZWFkUG9zaXRpb25zLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXR1cm4gaW5mb3JtYXRpb24gZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PE1ldGF0cmFkZXJQb3NpdGlvbj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggYXJyYXkgb2Ygb3BlbiBwb3NpdGlvbnNcbiAgICovXG4gIGFzeW5jIGdldFBvc2l0aW9ucyhhY2NvdW50SWQpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldFBvc2l0aW9ucyd9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UucG9zaXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc3BlY2lmaWMgcG9zaXRpb24gZm9yIGEgTWV0YVRyYWRlciBhY2NvdW50IChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmVhZFRyYWRpbmdUZXJtaW5hbFN0YXRlL3JlYWRQb3NpdGlvbi8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGZvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb25JZCBwb3NpdGlvbiBpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE1ldGF0cmFkZXJQb3NpdGlvbj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggTWV0YVRyYWRlciBwb3NpdGlvbiBmb3VuZFxuICAgKi9cbiAgYXN5bmMgZ2V0UG9zaXRpb24oYWNjb3VudElkLCBwb3NpdGlvbklkKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRQb3NpdGlvbicsIHBvc2l0aW9uSWR9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UucG9zaXRpb247XG4gIH1cblxuICAvKipcbiAgICogTWV0YVRyYWRlciBvcmRlclxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhdHJhZGVyT3JkZXJcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGlkIG9yZGVyIGlkICh0aWNrZXQgbnVtYmVyKVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gdHlwZSBvcmRlciB0eXBlIChvbmUgb2YgT1JERVJfVFlQRV9TRUxMLCBPUkRFUl9UWVBFX0JVWSwgT1JERVJfVFlQRV9CVVlfTElNSVQsXG4gICAqIE9SREVSX1RZUEVfU0VMTF9MSU1JVCwgT1JERVJfVFlQRV9CVVlfU1RPUCwgT1JERVJfVFlQRV9TRUxMX1NUT1ApLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvdHJhZGluZ2NvbnN0YW50cy9vcmRlcnByb3BlcnRpZXMjZW51bV9vcmRlcl90eXBlXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzdGF0ZSBvcmRlciBzdGF0ZSBvbmUgb2YgKE9SREVSX1NUQVRFX1NUQVJURUQsIE9SREVSX1NUQVRFX1BMQUNFRCwgT1JERVJfU1RBVEVfQ0FOQ0VMRUQsXG4gICAqIE9SREVSX1NUQVRFX1BBUlRJQUwsIE9SREVSX1NUQVRFX0ZJTExFRCwgT1JERVJfU1RBVEVfUkVKRUNURUQsIE9SREVSX1NUQVRFX0VYUElSRUQsIE9SREVSX1NUQVRFX1JFUVVFU1RfQURELFxuICAgKiBPUkRFUl9TVEFURV9SRVFVRVNUX01PRElGWSwgT1JERVJfU1RBVEVfUkVRVUVTVF9DQU5DRUwpLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvdHJhZGluZ2NvbnN0YW50cy9vcmRlcnByb3BlcnRpZXMjZW51bV9vcmRlcl9zdGF0ZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gbWFnaWMgb3JkZXIgbWFnaWMgbnVtYmVyLCBpZGVudGlmaWVzIHRoZSBFQSB3aGljaCBjcmVhdGVkIHRoZSBvcmRlclxuICAgKiBAcHJvcGVydHkge0RhdGV9IHRpbWUgdGltZSBvcmRlciB3YXMgY3JlYXRlZCBhdFxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gYnJva2VyVGltZSB0aW1lIHRpbWUgb3JkZXIgd2FzIGNyZWF0ZWQgYXQsIGluIGJyb2tlciB0aW1lem9uZSwgWVlZWS1NTS1ERCBISDptbTpzcy5TU1MgZm9ybWF0XG4gICAqIEBwcm9wZXJ0eSB7RGF0ZX0gW2RvbmVUaW1lXSB0aW1lIG9yZGVyIHdhcyBleGVjdXRlZCBvciBjYW5jZWxlZCBhdC4gV2lsbCBiZSBzcGVjaWZpZWQgZm9yXG4gICAqIGNvbXBsZXRlZCBvcmRlcnMgb25seVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2RvbmVCcm9rZXJUaW1lXSB0aW1lIG9yZGVyIHdhcyBleGVjdXRlZCBvciBjYW5jZWxlZCBhdCwgaW4gYnJva2VyIHRpbWV6b25lLFxuICAgKiBZWVlZLU1NLUREIEhIOm1tOnNzLlNTUyBmb3JtYXQuIFdpbGwgYmUgc3BlY2lmaWVkIGZvciBjb21wbGV0ZWQgb3JkZXJzIG9ubHlcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHN5bWJvbCBvcmRlciBzeW1ib2xcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG9wZW5QcmljZSBvcmRlciBvcGVuIHByaWNlIChtYXJrZXQgcHJpY2UgZm9yIG1hcmtldCBvcmRlcnMsIGxpbWl0IHByaWNlIGZvciBsaW1pdCBvcmRlcnMgb3Igc3RvcFxuICAgKiBwcmljZSBmb3Igc3RvcCBvcmRlcnMpXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjdXJyZW50UHJpY2UgY3VycmVudCBwcmljZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW3N0b3BMb3NzXSBvcmRlciBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFt0YWtlUHJvZml0XSBvcmRlciB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gdm9sdW1lIG9yZGVyIHJlcXVlc3RlZCBxdWFudGl0eVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gY3VycmVudFZvbHVtZSBvcmRlciByZW1haW5pbmcgcXVhbnRpdHksIGkuZS4gcmVxdWVzdGVkIHF1YW50aXR5IC0gZmlsbGVkIHF1YW50aXR5XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwb3NpdGlvbklkIG9yZGVyIHBvc2l0aW9uIGlkLiBQcmVzZW50IG9ubHkgaWYgdGhlIG9yZGVyIGhhcyBhIHBvc2l0aW9uIGF0dGFjaGVkIHRvIGl0XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbY29tbWVudF0gb3JkZXIgY29tbWVudC4gVGhlIHN1bSBvZiB0aGUgbGluZSBsZW5ndGhzIG9mIHRoZSBjb21tZW50IGFuZCB0aGUgY2xpZW50SWRcbiAgICogbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMjYuIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvY2xpZW50SWRVc2FnZS9cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IG9yaWdpbmFsQ29tbWVudCBvcHRpb25hbCBvcmRlciBvcmlnaW5hbCBjb21tZW50IChwcmVzZW50IGlmIHBvc3NpYmxlIHRvIHJlc3RvcmUgb3JpZ2luYWwgY29tbWVudFxuICAgKiBmcm9tIGhpc3RvcnkpXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbY2xpZW50SWRdIGNsaWVudC1hc3NpZ25lZCBpZC4gVGhlIGlkIHZhbHVlIGNhbiBiZSBhc3NpZ25lZCB3aGVuIHN1Ym1pdHRpbmcgYSB0cmFkZSBhbmRcbiAgICogd2lsbCBiZSBwcmVzZW50IG9uIHBvc2l0aW9uLCBoaXN0b3J5IG9yZGVycyBhbmQgaGlzdG9yeSBkZWFscyByZWxhdGVkIHRvIHRoZSB0cmFkZS4gWW91IGNhbiB1c2UgdGhpcyBmaWVsZCB0byBiaW5kXG4gICAqIHlvdXIgdHJhZGVzIHRvIG9iamVjdHMgaW4geW91ciBhcHBsaWNhdGlvbiBhbmQgdGhlbiB0cmFjayB0cmFkZSBwcm9ncmVzcy4gVGhlIHN1bSBvZiB0aGUgbGluZSBsZW5ndGhzIG9mIHRoZVxuICAgKiBjb21tZW50IGFuZCB0aGUgY2xpZW50SWQgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMjYuIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvY2xpZW50SWRVc2FnZS9cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHBsYXRmb3JtIHBsYXRmb3JtIGlkIChtdDQgb3IgbXQ1KVxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt1cGRhdGVQZW5kaW5nXSBmbGFnIGluZGljYXRpbmcgdGhhdCBvcmRlciBjbGllbnQgaWQgYW5kIG9yaWdpbmFsIGNvbW1lbnQgd2FzIG5vdFxuICAgKiBpZGVudGlmaWVkIHlldCBhbmQgd2lsbCBiZSB1cGRhdGVkIGluIGEgZnV0dXJlIHN5bmNocm9uaXphdGlvbiBwYWNrZXRcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHJlYXNvbiBvcmRlciBvcGVuaW5nIHJlYXNvbi4gT25lIG9mIE9SREVSX1JFQVNPTl9DTElFTlQsIE9SREVSX1JFQVNPTl9NT0JJTEUsIE9SREVSX1JFQVNPTl9XRUIsXG4gICAqIE9SREVSX1JFQVNPTl9FWFBFUlQsIE9SREVSX1JFQVNPTl9TTCwgT1JERVJfUkVBU09OX1RQLCBPUkRFUl9SRUFTT05fU08sIE9SREVSX1JFQVNPTl9VTktOT1dOLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvdHJhZGluZ2NvbnN0YW50cy9vcmRlcnByb3BlcnRpZXMjZW51bV9vcmRlcl9yZWFzb24uXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBmaWxsaW5nTW9kZSBvcmRlciBmaWxsaW5nIG1vZGUuIE9uZSBvZiBPUkRFUl9GSUxMSU5HX0ZPSywgT1JERVJfRklMTElOR19JT0MsXG4gICAqIE9SREVSX0ZJTExJTkdfUkVUVVJOLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvdHJhZGluZ2NvbnN0YW50cy9vcmRlcnByb3BlcnRpZXMjZW51bV9vcmRlcl90eXBlX2ZpbGxpbmcuXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBleHBpcmF0aW9uVHlwZSBvcmRlciBleHBpcmF0aW9uIHR5cGUuIE9uZSBvZiBPUkRFUl9USU1FX0dUQywgT1JERVJfVElNRV9EQVksXG4gICAqIE9SREVSX1RJTUVfU1BFQ0lGSUVELCBPUkRFUl9USU1FX1NQRUNJRklFRF9EQVkuIFNlZVxuICAgKiBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy90cmFkaW5nY29uc3RhbnRzL29yZGVycHJvcGVydGllcyNlbnVtX29yZGVyX3R5cGVfdGltZVxuICAgKiBAcHJvcGVydHkge0RhdGV9IGV4cGlyYXRpb25UaW1lIG9wdGlvbmFsIG9yZGVyIGV4cGlyYXRpb24gdGltZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW2FjY291bnRDdXJyZW5jeUV4Y2hhbmdlUmF0ZV0gY3VycmVudCBleGNoYW5nZSByYXRlIG9mIGFjY291bnQgY3VycmVuY3kgaW50byBhY2NvdW50IGJhc2VcbiAgICogY3VycmVuY3kgKFVTRCBpZiB5b3UgZGlkIG5vdCBvdmVycmlkZSBpdClcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtjbG9zZUJ5UG9zaXRpb25JZF0gaWRlbnRpZmllciBvZiBhbiBvcHBvc2l0ZSBwb3NpdGlvbiB1c2VkIGZvciBjbG9zaW5nIGJ5IG9yZGVyXG4gICAqIE9SREVSX1RZUEVfQ0xPU0VfQllcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzdG9wTGltaXRQcmljZV0gdGhlIExpbWl0IG9yZGVyIHByaWNlIGZvciB0aGUgU3RvcExpbWl0IG9yZGVyXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG9wZW4gb3JkZXJzIGZvciBhIHNwZWNpZmllZCBNZXRhVHJhZGVyIGFjY291bnQgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZWFkVHJhZGluZ1Rlcm1pbmFsU3RhdGUvcmVhZE9yZGVycy8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGZvclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PE1ldGF0cmFkZXJPcmRlcj4+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIG9wZW4gTWV0YVRyYWRlciBvcmRlcnNcbiAgICovXG4gIGFzeW5jIGdldE9yZGVycyhhY2NvdW50SWQpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldE9yZGVycyd9KTtcbiAgICByZXR1cm4gcmVzcG9uc2Uub3JkZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc3BlY2lmaWMgb3BlbiBvcmRlciBmb3IgYSBNZXRhVHJhZGVyIGFjY291bnQgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZWFkVHJhZGluZ1Rlcm1pbmFsU3RhdGUvcmVhZE9yZGVyLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXR1cm4gaW5mb3JtYXRpb24gZm9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcmRlcklkIG9yZGVyIGlkICh0aWNrZXQgbnVtYmVyKVxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE1ldGF0cmFkZXJPcmRlcj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggbWV0YXRyYWRlciBvcmRlciBmb3VuZFxuICAgKi9cbiAgYXN5bmMgZ2V0T3JkZXIoYWNjb3VudElkLCBvcmRlcklkKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRPcmRlcicsIG9yZGVySWR9KTtcbiAgICByZXR1cm4gcmVzcG9uc2Uub3JkZXI7XG4gIH1cblxuICAvKipcbiAgICogTWV0YVRyYWRlciBoaXN0b3J5IG9yZGVycyBzZWFyY2ggcXVlcnkgcmVzcG9uc2VcbiAgICogQHR5cGVkZWYge09iamVjdH0gTWV0YXRyYWRlckhpc3RvcnlPcmRlcnNcbiAgICogQHByb3BlcnR5IHtBcnJheTxNZXRhdHJhZGVyT3JkZXI+fSBoaXN0b3J5T3JkZXJzIGFycmF5IG9mIGhpc3Rvcnkgb3JkZXJzIHJldHVybmVkXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc3luY2hyb25pemluZyBmbGFnIGluZGljYXRpbmcgdGhhdCBoaXN0b3J5IG9yZGVyIGluaXRpYWwgc3luY2hyb25pemF0aW9uIGlzIHN0aWxsIGluIHByb2dyZXNzXG4gICAqIGFuZCB0aHVzIHNlYXJjaCByZXN1bHRzIG1heSBiZSBpbmNvbXBsZXRlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoaXN0b3J5IG9mIGNvbXBsZXRlZCBvcmRlcnMgZm9yIGEgc3BlY2lmaWMgdGlja2V0IG51bWJlciAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlSGlzdG9yaWNhbERhdGEvcmVhZEhpc3RvcnlPcmRlcnNCeVRpY2tldC8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGZvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGlja2V0IHRpY2tldCBudW1iZXIgKG9yZGVyIGlkKVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVySGlzdG9yeU9yZGVycz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcmVxdWVzdCByZXN1bHRzIGNvbnRhaW5pbmcgaGlzdG9yeSBvcmRlcnMgZm91bmRcbiAgICovXG4gIGFzeW5jIGdldEhpc3RvcnlPcmRlcnNCeVRpY2tldChhY2NvdW50SWQsIHRpY2tldCkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoYWNjb3VudElkLCB7YXBwbGljYXRpb246ICdSUEMnLCB0eXBlOiAnZ2V0SGlzdG9yeU9yZGVyc0J5VGlja2V0JywgdGlja2V0fSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhpc3RvcnlPcmRlcnM6IHJlc3BvbnNlLmhpc3RvcnlPcmRlcnMsXG4gICAgICBzeW5jaHJvbml6aW5nOiByZXNwb25zZS5zeW5jaHJvbml6aW5nXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoaXN0b3J5IG9mIGNvbXBsZXRlZCBvcmRlcnMgZm9yIGEgc3BlY2lmaWMgcG9zaXRpb24gaWQgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZXRyaWV2ZUhpc3RvcmljYWxEYXRhL3JlYWRIaXN0b3J5T3JkZXJzQnlQb3NpdGlvbi8pXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXR1cm4gaW5mb3JtYXRpb24gZm9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwb3NpdGlvbklkIHBvc2l0aW9uIGlkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJIaXN0b3J5T3JkZXJzPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCByZXF1ZXN0IHJlc3VsdHMgY29udGFpbmluZyBoaXN0b3J5IG9yZGVycyBmb3VuZFxuICAgKi9cbiAgYXN5bmMgZ2V0SGlzdG9yeU9yZGVyc0J5UG9zaXRpb24oYWNjb3VudElkLCBwb3NpdGlvbklkKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRIaXN0b3J5T3JkZXJzQnlQb3NpdGlvbicsXG4gICAgICBwb3NpdGlvbklkfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhpc3RvcnlPcmRlcnM6IHJlc3BvbnNlLmhpc3RvcnlPcmRlcnMsXG4gICAgICBzeW5jaHJvbml6aW5nOiByZXNwb25zZS5zeW5jaHJvbml6aW5nXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoaXN0b3J5IG9mIGNvbXBsZXRlZCBvcmRlcnMgZm9yIGEgc3BlY2lmaWMgdGltZSByYW5nZSAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlSGlzdG9yaWNhbERhdGEvcmVhZEhpc3RvcnlPcmRlcnNCeVRpbWVSYW5nZS8pXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXR1cm4gaW5mb3JtYXRpb24gZm9yXG4gICAqIEBwYXJhbSB7RGF0ZX0gc3RhcnRUaW1lIHN0YXJ0IG9mIHRpbWUgcmFuZ2UsIGluY2x1c2l2ZVxuICAgKiBAcGFyYW0ge0RhdGV9IGVuZFRpbWUgZW5kIG9mIHRpbWUgcmFuZ2UsIGV4Y2x1c2l2ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IHBhZ2luYXRpb24gb2Zmc2V0LCBkZWZhdWx0IGlzIDBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbWl0IHBhZ2luYXRpb24gbGltaXQsIGRlZmF1bHQgaXMgMTAwMFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVySGlzdG9yeU9yZGVycz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcmVxdWVzdCByZXN1bHRzIGNvbnRhaW5pbmcgaGlzdG9yeSBvcmRlcnMgZm91bmRcbiAgICovXG4gIGFzeW5jIGdldEhpc3RvcnlPcmRlcnNCeVRpbWVSYW5nZShhY2NvdW50SWQsIHN0YXJ0VGltZSwgZW5kVGltZSwgb2Zmc2V0ID0gMCwgbGltaXQgPSAxMDAwKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRIaXN0b3J5T3JkZXJzQnlUaW1lUmFuZ2UnLFxuICAgICAgc3RhcnRUaW1lLCBlbmRUaW1lLCBvZmZzZXQsIGxpbWl0fSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhpc3RvcnlPcmRlcnM6IHJlc3BvbnNlLmhpc3RvcnlPcmRlcnMsXG4gICAgICBzeW5jaHJvbml6aW5nOiByZXNwb25zZS5zeW5jaHJvbml6aW5nXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRhVHJhZGVyIGhpc3RvcnkgZGVhbHMgc2VhcmNoIHF1ZXJ5IHJlc3BvbnNlXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJEZWFsc1xuICAgKiBAcHJvcGVydHkge0FycmF5PE1ldGF0cmFkZXJEZWFsPn0gZGVhbHMgYXJyYXkgb2YgaGlzdG9yeSBkZWFscyByZXR1cm5lZFxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHN5bmNocm9uaXppbmcgZmxhZyBpbmRpY2F0aW5nIHRoYXQgZGVhbCBpbml0aWFsIHN5bmNocm9uaXphdGlvbiBpcyBzdGlsbCBpbiBwcm9ncmVzc1xuICAgKiBhbmQgdGh1cyBzZWFyY2ggcmVzdWx0cyBtYXkgYmUgaW5jb21wbGV0ZVxuICAgKi9cblxuICAvKipcbiAgICogTWV0YVRyYWRlciBkZWFsXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJEZWFsXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBpZCBkZWFsIGlkICh0aWNrZXQgbnVtYmVyKVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gdHlwZSBkZWFsIHR5cGUgKG9uZSBvZiBERUFMX1RZUEVfQlVZLCBERUFMX1RZUEVfU0VMTCwgREVBTF9UWVBFX0JBTEFOQ0UsIERFQUxfVFlQRV9DUkVESVQsXG4gICAqIERFQUxfVFlQRV9DSEFSR0UsIERFQUxfVFlQRV9DT1JSRUNUSU9OLCBERUFMX1RZUEVfQk9OVVMsIERFQUxfVFlQRV9DT01NSVNTSU9OLCBERUFMX1RZUEVfQ09NTUlTU0lPTl9EQUlMWSxcbiAgICogREVBTF9UWVBFX0NPTU1JU1NJT05fTU9OVEhMWSwgREVBTF9UWVBFX0NPTU1JU1NJT05fQUdFTlRfREFJTFksIERFQUxfVFlQRV9DT01NSVNTSU9OX0FHRU5UX01PTlRITFksXG4gICAqIERFQUxfVFlQRV9JTlRFUkVTVCwgREVBTF9UWVBFX0JVWV9DQU5DRUxFRCwgREVBTF9UWVBFX1NFTExfQ0FOQ0VMRUQsIERFQUxfRElWSURFTkQsIERFQUxfRElWSURFTkRfRlJBTktFRCxcbiAgICogREVBTF9UQVgpLiBTZWUgaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvdHJhZGluZ2NvbnN0YW50cy9kZWFscHJvcGVydGllcyNlbnVtX2RlYWxfdHlwZVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gZW50cnlUeXBlIGRlYWwgZW50cnkgdHlwZSAob25lIG9mIERFQUxfRU5UUllfSU4sIERFQUxfRU5UUllfT1VULCBERUFMX0VOVFJZX0lOT1VULFxuICAgKiBERUFMX0VOVFJZX09VVF9CWSkuIFNlZSBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy90cmFkaW5nY29uc3RhbnRzL2RlYWxwcm9wZXJ0aWVzI2VudW1fZGVhbF9lbnRyeVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3N5bWJvbF0gc3ltYm9sIGRlYWwgcmVsYXRlcyB0b1xuICAgKiBAcHJvcGVydHkge051bWJlcn0gW21hZ2ljXSBkZWFsIG1hZ2ljIG51bWJlciwgaWRlbnRpZmllcyB0aGUgRUEgd2hpY2ggaW5pdGlhdGVkIHRoZSBkZWFsXG4gICAqIEBwcm9wZXJ0eSB7RGF0ZX0gdGltZSB0aW1lIHRoZSBkZWFsIHdhcyBjb25kdWN0ZWQgYXRcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGJyb2tlclRpbWUgdGltZSB0aW1lIHRoZSBkZWFsIHdhcyBjb25kdWN0ZWQgYXQsIGluIGJyb2tlciB0aW1lem9uZSwgWVlZWS1NTS1ERCBISDptbTpzcy5TU1MgZm9ybWF0XG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdm9sdW1lXSBkZWFsIHZvbHVtZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW3ByaWNlXSB0aGUgcHJpY2UgdGhlIGRlYWwgd2FzIGNvbmR1Y3RlZCBhdFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW2NvbW1pc3Npb25dIGRlYWwgY29tbWlzc2lvblxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW3N3YXBdIGRlYWwgc3dhcFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gcHJvZml0IGRlYWwgcHJvZml0XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbcG9zaXRpb25JZF0gaWQgb2YgcG9zaXRpb24gdGhlIGRlYWwgcmVsYXRlcyB0b1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW29yZGVySWRdIGlkIG9mIG9yZGVyIHRoZSBkZWFsIHJlbGF0ZXMgdG9cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtjb21tZW50XSBkZWFsIGNvbW1lbnQuIFRoZSBzdW0gb2YgdGhlIGxpbmUgbGVuZ3RocyBvZiB0aGUgY29tbWVudCBhbmQgdGhlIGNsaWVudElkXG4gICAqIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDI2LiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L2NsaWVudElkVXNhZ2UvXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbb3JpZ2luYWxDb21tZW50XSBkZWFsIG9yaWdpbmFsIGNvbW1lbnQgKHByZXNlbnQgaWYgcG9zc2libGUgdG8gcmVzdG9yZSBvcmlnaW5hbCBjb21tZW50XG4gICAqIGZyb20gaGlzdG9yeSlcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtjbGllbnRJZF0gY2xpZW50LWFzc2lnbmVkIGlkLiBUaGUgaWQgdmFsdWUgY2FuIGJlIGFzc2lnbmVkIHdoZW4gc3VibWl0dGluZyBhIHRyYWRlIGFuZFxuICAgKiB3aWxsIGJlIHByZXNlbnQgb24gcG9zaXRpb24sIGhpc3Rvcnkgb3JkZXJzIGFuZCBoaXN0b3J5IGRlYWxzIHJlbGF0ZWQgdG8gdGhlIHRyYWRlLiBZb3UgY2FuIHVzZSB0aGlzIGZpZWxkIHRvIGJpbmRcbiAgICogeW91ciB0cmFkZXMgdG8gb2JqZWN0cyBpbiB5b3VyIGFwcGxpY2F0aW9uIGFuZCB0aGVuIHRyYWNrIHRyYWRlIHByb2dyZXNzLiBUaGUgc3VtIG9mIHRoZSBsaW5lIGxlbmd0aHMgb2YgdGhlXG4gICAqIGNvbW1lbnQgYW5kIHRoZSBjbGllbnRJZCBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAyNi4gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9jbGllbnRJZFVzYWdlL1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gcGxhdGZvcm0gcGxhdGZvcm0gaWQgKG10NCBvciBtdDUpXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3VwZGF0ZVBlbmRpbmddIGZsYWcgaW5kaWNhdGluZyB0aGF0IGRlYWwgY2xpZW50IGlkIGFuZCBvcmlnaW5hbCBjb21tZW50IHdhcyBub3RcbiAgICogaWRlbnRpZmllZCB5ZXQgYW5kIHdpbGwgYmUgdXBkYXRlZCBpbiBhIGZ1dHVyZSBzeW5jaHJvbml6YXRpb24gcGFja2V0XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbcmVhc29uXSBvcHRpb25hbCBkZWFsIGV4ZWN1dGlvbiByZWFzb24uIE9uZSBvZiBERUFMX1JFQVNPTl9DTElFTlQsIERFQUxfUkVBU09OX01PQklMRSxcbiAgICogREVBTF9SRUFTT05fV0VCLCBERUFMX1JFQVNPTl9FWFBFUlQsIERFQUxfUkVBU09OX1NMLCBERUFMX1JFQVNPTl9UUCwgREVBTF9SRUFTT05fU08sIERFQUxfUkVBU09OX1JPTExPVkVSLFxuICAgKiBERUFMX1JFQVNPTl9WTUFSR0lOLCBERUFMX1JFQVNPTl9TUExJVCwgREVBTF9SRUFTT05fVU5LTk9XTi4gU2VlXG4gICAqIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL3RyYWRpbmdjb25zdGFudHMvZGVhbHByb3BlcnRpZXMjZW51bV9kZWFsX3JlYXNvbi5cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFthY2NvdW50Q3VycmVuY3lFeGNoYW5nZVJhdGVdIGN1cnJlbnQgZXhjaGFuZ2UgcmF0ZSBvZiBhY2NvdW50IGN1cnJlbmN5IGludG8gYWNjb3VudCBiYXNlXG4gICAqIGN1cnJlbmN5IChVU0QgaWYgeW91IGRpZCBub3Qgb3ZlcnJpZGUgaXQpXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGhpc3RvcnkgZGVhbHMgd2l0aCBhIHNwZWNpZmljIHRpY2tldCBudW1iZXIgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZXRyaWV2ZUhpc3RvcmljYWxEYXRhL3JlYWREZWFsc0J5VGlja2V0LykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXR1cm4gaW5mb3JtYXRpb24gZm9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0aWNrZXQgdGlja2V0IG51bWJlciAoZGVhbCBpZCBmb3IgTVQ1IG9yIG9yZGVyIGlkIGZvciBNVDQpXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJEZWFscz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcmVxdWVzdCByZXN1bHRzIGNvbnRhaW5pbmcgZGVhbHMgZm91bmRcbiAgICovXG4gIGFzeW5jIGdldERlYWxzQnlUaWNrZXQoYWNjb3VudElkLCB0aWNrZXQpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldERlYWxzQnlUaWNrZXQnLCB0aWNrZXR9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZGVhbHM6IHJlc3BvbnNlLmRlYWxzLFxuICAgICAgc3luY2hyb25pemluZzogcmVzcG9uc2Uuc3luY2hyb25pemluZ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBoaXN0b3J5IGRlYWxzIGZvciBhIHNwZWNpZmljIHBvc2l0aW9uIGlkIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVIaXN0b3JpY2FsRGF0YS9yZWFkRGVhbHNCeVBvc2l0aW9uLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXR1cm4gaW5mb3JtYXRpb24gZm9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwb3NpdGlvbklkIHBvc2l0aW9uIGlkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJEZWFscz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcmVxdWVzdCByZXN1bHRzIGNvbnRhaW5pbmcgZGVhbHMgZm91bmRcbiAgICovXG4gIGFzeW5jIGdldERlYWxzQnlQb3NpdGlvbihhY2NvdW50SWQsIHBvc2l0aW9uSWQpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldERlYWxzQnlQb3NpdGlvbicsIHBvc2l0aW9uSWR9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZGVhbHM6IHJlc3BvbnNlLmRlYWxzLFxuICAgICAgc3luY2hyb25pemluZzogcmVzcG9uc2Uuc3luY2hyb25pemluZ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBoaXN0b3J5IGRlYWxzIHdpdGggZm9yIGEgc3BlY2lmaWMgdGltZSByYW5nZSAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlSGlzdG9yaWNhbERhdGEvcmVhZERlYWxzQnlUaW1lUmFuZ2UvKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHVybiBpbmZvcm1hdGlvbiBmb3JcbiAgICogQHBhcmFtIHtEYXRlfSBzdGFydFRpbWUgc3RhcnQgb2YgdGltZSByYW5nZSwgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSB7RGF0ZX0gZW5kVGltZSBlbmQgb2YgdGltZSByYW5nZSwgZXhjbHVzaXZlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgcGFnaW5hdGlvbiBvZmZzZXQsIGRlZmF1bHQgaXMgMFxuICAgKiBAcGFyYW0ge051bWJlcn0gbGltaXQgcGFnaW5hdGlvbiBsaW1pdCwgZGVmYXVsdCBpcyAxMDAwXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJEZWFscz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcmVxdWVzdCByZXN1bHRzIGNvbnRhaW5pbmcgZGVhbHMgZm91bmRcbiAgICovXG4gIGFzeW5jIGdldERlYWxzQnlUaW1lUmFuZ2UoYWNjb3VudElkLCBzdGFydFRpbWUsIGVuZFRpbWUsIG9mZnNldCA9IDAsIGxpbWl0ID0gMTAwMCkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoYWNjb3VudElkLCB7YXBwbGljYXRpb246ICdSUEMnLCB0eXBlOiAnZ2V0RGVhbHNCeVRpbWVSYW5nZScsIHN0YXJ0VGltZSxcbiAgICAgIGVuZFRpbWUsIG9mZnNldCwgbGltaXR9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZGVhbHM6IHJlc3BvbnNlLmRlYWxzLFxuICAgICAgc3luY2hyb25pemluZzogcmVzcG9uc2Uuc3luY2hyb25pemluZ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBvcmRlciBhbmQgdHJhbnNhY3Rpb24gaGlzdG9yeSBvZiBhIHNwZWNpZmllZCBhcHBsaWNhdGlvbiBzbyB0aGF0IGl0IGNhbiBiZSBzeW5jaHJvbml6ZWQgZnJvbSBzY3JhdGNoXG4gICAqIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmVtb3ZlSGlzdG9yeS8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmVtb3ZlIGhpc3RvcnkgZm9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbYXBwbGljYXRpb25dIGFwcGxpY2F0aW9uIHRvIHJlbW92ZSBoaXN0b3J5IGZvclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBoaXN0b3J5IGlzIGNsZWFyZWRcbiAgICovXG4gIHJlbW92ZUhpc3RvcnkoYWNjb3VudElkLCBhcHBsaWNhdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uLCB0eXBlOiAncmVtb3ZlSGlzdG9yeSd9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIG9yZGVyIGFuZCB0cmFuc2FjdGlvbiBoaXN0b3J5IG9mIGEgc3BlY2lmaWVkIGFwcGxpY2F0aW9uIGFuZCByZW1vdmVzIHRoZSBhcHBsaWNhdGlvbiAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JlbW92ZUFwcGxpY2F0aW9uLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZW1vdmUgaGlzdG9yeSBhbmQgYXBwbGljYXRpb24gZm9yXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGhpc3RvcnkgaXMgY2xlYXJlZFxuICAgKi9cbiAgcmVtb3ZlQXBwbGljYXRpb24oYWNjb3VudElkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoYWNjb3VudElkLCB7dHlwZTogJ3JlbW92ZUFwcGxpY2F0aW9uJ30pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGFUcmFkZXIgdHJhZGUgcmVzcG9uc2VcbiAgICogQHR5cGVkZWYge09iamVjdH0gTWV0YXRyYWRlclRyYWRlUmVzcG9uc2VcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG51bWVyaWNDb2RlIG51bWVyaWMgcmVzcG9uc2UgY29kZSwgc2VlXG4gICAqIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL2Vycm9yc3dhcm5pbmdzL2VudW1fdHJhZGVfcmV0dXJuX2NvZGVzIGFuZFxuICAgKiBodHRwczovL2Jvb2subXFsNC5jb20vYXBwZW5kaXgvZXJyb3JzLiBSZXNwb25zZSBjb2RlcyB3aGljaCBpbmRpY2F0ZSBzdWNjZXNzIGFyZSAwLCAxMDAwOC0xMDAxMCwgMTAwMjUuIFRoZSByZXN0XG4gICAqIGNvZGVzIGFyZSBlcnJvcnNcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHN0cmluZ0NvZGUgc3RyaW5nIHJlc3BvbnNlIGNvZGUsIHNlZVxuICAgKiBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy9lcnJvcnN3YXJuaW5ncy9lbnVtX3RyYWRlX3JldHVybl9jb2RlcyBhbmRcbiAgICogaHR0cHM6Ly9ib29rLm1xbDQuY29tL2FwcGVuZGl4L2Vycm9ycy4gUmVzcG9uc2UgY29kZXMgd2hpY2ggaW5kaWNhdGUgc3VjY2VzcyBhcmUgRVJSX05PX0VSUk9SLFxuICAgKiBUUkFERV9SRVRDT0RFX1BMQUNFRCwgVFJBREVfUkVUQ09ERV9ET05FLCBUUkFERV9SRVRDT0RFX0RPTkVfUEFSVElBTCwgVFJBREVfUkVUQ09ERV9OT19DSEFOR0VTLiBUaGUgcmVzdCBjb2RlcyBhcmVcbiAgICogZXJyb3JzLlxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gbWVzc2FnZSBodW1hbi1yZWFkYWJsZSByZXNwb25zZSBtZXNzYWdlXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBvcmRlcklkIG9yZGVyIGlkIHdoaWNoIHdhcyBjcmVhdGVkL21vZGlmaWVkIGR1cmluZyB0aGUgdHJhZGVcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHBvc2l0aW9uSWQgcG9zaXRpb24gaWQgd2hpY2ggd2FzIG1vZGlmaWVkIGR1cmluZyB0aGUgdHJhZGVcbiAgICovXG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSB0cmFkZSBvbiBhIGNvbm5lY3RlZCBNZXRhVHJhZGVyIGFjY291bnQgKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS90cmFkZS8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gZXhlY3V0ZSB0cmFkZSBmb3JcbiAgICogQHBhcmFtIHtNZXRhdHJhZGVyVHJhZGV9IHRyYWRlIHRyYWRlIHRvIGV4ZWN1dGUgKHNlZSBkb2NzIGZvciBwb3NzaWJsZSB0cmFkZSB0eXBlcylcbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlclRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBhc3luYyB0cmFkZShhY2NvdW50SWQsIHRyYWRlKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdChhY2NvdW50SWQsIHt0eXBlOiAndHJhZGUnLCB0cmFkZX0pO1xuICAgIHJlc3BvbnNlLnJlc3BvbnNlID0gcmVzcG9uc2UucmVzcG9uc2UgfHwge307XG4gICAgcmVzcG9uc2UucmVzcG9uc2Uuc3RyaW5nQ29kZSA9IHJlc3BvbnNlLnJlc3BvbnNlLnN0cmluZ0NvZGUgfHwgcmVzcG9uc2UucmVzcG9uc2UuZGVzY3JpcHRpb247XG4gICAgcmVzcG9uc2UucmVzcG9uc2UubnVtZXJpY0NvZGUgPSByZXNwb25zZS5yZXNwb25zZS5udW1lcmljQ29kZSAhPT0gdW5kZWZpbmVkID8gcmVzcG9uc2UucmVzcG9uc2UubnVtZXJpY0NvZGUgOlxuICAgICAgcmVzcG9uc2UucmVzcG9uc2UuZXJyb3I7XG4gICAgaWYgKFsnRVJSX05PX0VSUk9SJywgJ1RSQURFX1JFVENPREVfUExBQ0VEJywgJ1RSQURFX1JFVENPREVfRE9ORScsICdUUkFERV9SRVRDT0RFX0RPTkVfUEFSVElBTCcsXG4gICAgICAnVFJBREVfUkVUQ09ERV9OT19DSEFOR0VTJ10uaW5jbHVkZXMocmVzcG9uc2UucmVzcG9uc2Uuc3RyaW5nQ29kZSB8fCByZXNwb25zZS5yZXNwb25zZS5kZXNjcmlwdGlvbikpIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5yZXNwb25zZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFRyYWRlRXJyb3IocmVzcG9uc2UucmVzcG9uc2UubWVzc2FnZSwgcmVzcG9uc2UucmVzcG9uc2UubnVtZXJpY0NvZGUsIHJlc3BvbnNlLnJlc3BvbnNlLnN0cmluZ0NvZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdGFzayB0aGF0IGVuc3VyZXMgdGhlIGFjY291bnQgZ2V0cyBzdWJzY3JpYmVkIHRvIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkIHRvIHN1YnNjcmliZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2luc3RhbmNlTnVtYmVyXSBpbnN0YW5jZSBpbmRleCBudW1iZXJcbiAgICovXG4gIGVuc3VyZVN1YnNjcmliZShhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyKSB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uTWFuYWdlci5zdWJzY3JpYmUoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcik7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlcyB0byB0aGUgTWV0YXRyYWRlciB0ZXJtaW5hbCBldmVudHMgKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9zdWJzY3JpYmUvKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHN1YnNjcmliZSB0b1xuICAgKiBAcGFyYW0ge051bWJlcn0gW2luc3RhbmNlTnVtYmVyXSBpbnN0YW5jZSBpbmRleCBudW1iZXJcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBzdWJzY3JpcHRpb24gc3RhcnRlZFxuICAgKi9cbiAgc3Vic2NyaWJlKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdChhY2NvdW50SWQsIHt0eXBlOiAnc3Vic2NyaWJlJywgaW5zdGFuY2VJbmRleDogaW5zdGFuY2VOdW1iZXJ9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvbm5lY3RzIHRvIHRoZSBNZXRhdHJhZGVyIHRlcm1pbmFsIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmVjb25uZWN0LykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZWNvbm5lY3RcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiByZWNvbm5lY3Rpb24gc3RhcnRlZFxuICAgKi9cbiAgcmVjb25uZWN0KGFjY291bnRJZCkge1xuICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KGFjY291bnRJZCwge3R5cGU6ICdyZWNvbm5lY3QnfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdHMgdGhlIHRlcm1pbmFsIHRvIHN0YXJ0IHN5bmNocm9uaXphdGlvbiBwcm9jZXNzXG4gICAqIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9zeW5jaHJvbml6aW5nL3N5bmNocm9uaXplLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byBzeW5jaHJvbml6ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VJbmRleCBpbnN0YW5jZSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaG9zdCBuYW1lIG9mIGhvc3QgdG8gc3luY2hyb25pemUgd2l0aFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3luY2hyb25pemF0aW9uSWQgc3luY2hyb25pemF0aW9uIHJlcXVlc3QgaWRcbiAgICogQHBhcmFtIHtEYXRlfSBzdGFydGluZ0hpc3RvcnlPcmRlclRpbWUgZnJvbSB3aGF0IGRhdGUgdG8gc3RhcnQgc3luY2hyb25pemluZyBoaXN0b3J5IG9yZGVycyBmcm9tLiBJZiBub3Qgc3BlY2lmaWVkLFxuICAgKiB0aGUgZW50aXJlIG9yZGVyIGhpc3Rvcnkgd2lsbCBiZSBkb3dubG9hZGVkLlxuICAgKiBAcGFyYW0ge0RhdGV9IHN0YXJ0aW5nRGVhbFRpbWUgZnJvbSB3aGF0IGRhdGUgdG8gc3RhcnQgZGVhbCBzeW5jaHJvbml6YXRpb24gZnJvbS4gSWYgbm90IHNwZWNpZmllZCwgdGhlbiBhbGxcbiAgICogaGlzdG9yeSBkZWFscyB3aWxsIGJlIGRvd25sb2FkZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHN0YXJ0ZWRcbiAgICovXG4gIHN5bmNocm9uaXplKGFjY291bnRJZCwgaW5zdGFuY2VJbmRleCwgaG9zdCwgc3luY2hyb25pemF0aW9uSWQsIHN0YXJ0aW5nSGlzdG9yeU9yZGVyVGltZSwgc3RhcnRpbmdEZWFsVGltZSkge1xuICAgIGNvbnN0IHN5bmNUaHJvdHRsZXIgPSB0aGlzLl9zb2NrZXRJbnN0YW5jZXNbdGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1thY2NvdW50SWRdXS5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXI7XG4gICAgcmV0dXJuIHN5bmNUaHJvdHRsZXIuc2NoZWR1bGVTeW5jaHJvbml6ZShhY2NvdW50SWQsIHtyZXF1ZXN0SWQ6IHN5bmNocm9uaXphdGlvbklkLCBcbiAgICAgIHR5cGU6ICdzeW5jaHJvbml6ZScsIHN0YXJ0aW5nSGlzdG9yeU9yZGVyVGltZSwgc3RhcnRpbmdEZWFsVGltZSwgaW5zdGFuY2VJbmRleCwgaG9zdH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhaXRzIGZvciBzZXJ2ZXItc2lkZSB0ZXJtaW5hbCBzdGF0ZSBzeW5jaHJvbml6YXRpb24gdG8gY29tcGxldGUuXG4gICAqIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9zeW5jaHJvbml6aW5nL3dhaXRTeW5jaHJvbml6ZWQvKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHN5bmNocm9uaXplXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnN0YW5jZU51bWJlciBpbnN0YW5jZSBpbmRleCBudW1iZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFwcGxpY2F0aW9uUGF0dGVybiBNZXRhQXBpIGFwcGxpY2F0aW9uIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuLCBkZWZhdWx0IGlzIC4qXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0SW5TZWNvbmRzIHRpbWVvdXQgaW4gc2Vjb25kcywgZGVmYXVsdCBpcyAzMDAgc2Vjb25kc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN5bmNocm9uaXphdGlvbiBzdGFydGVkXG4gICAqL1xuICB3YWl0U3luY2hyb25pemVkKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsIGFwcGxpY2F0aW9uUGF0dGVybiwgdGltZW91dEluU2Vjb25kcykge1xuICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KGFjY291bnRJZCwge3R5cGU6ICd3YWl0U3luY2hyb25pemVkJywgYXBwbGljYXRpb25QYXR0ZXJuLCB0aW1lb3V0SW5TZWNvbmRzLFxuICAgICAgaW5zdGFuY2VJbmRleDogaW5zdGFuY2VOdW1iZXJ9LFxuICAgIHRpbWVvdXRJblNlY29uZHMgKyAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrZXQgZGF0YSBzdWJzY3JpcHRpb25cbiAgICogQHR5cGVkZWYge09iamVjdH0gTWFya2V0RGF0YVN1YnNjcmlwdGlvblxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSBzdWJzY3JpcHRpb24gdHlwZSwgb25lIG9mIHF1b3RlcywgY2FuZGxlcywgdGlja3MsIG9yIG1hcmtldERlcHRoXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGltZWZyYW1lXSB3aGVuIHN1YnNjcmlwdGlvbiB0eXBlIGlzIGNhbmRsZXMsIGRlZmluZXMgdGhlIHRpbWVmcmFtZSBhY2NvcmRpbmcgdG8gd2hpY2ggdGhlXG4gICAqIGNhbmRsZXMgbXVzdCBiZSBnZW5lcmF0ZWQuIEFsbG93ZWQgdmFsdWVzIGZvciBNVDUgYXJlIDFtLCAybSwgM20sIDRtLCA1bSwgNm0sIDEwbSwgMTJtLCAxNW0sIDIwbSwgMzBtLCAxaCwgMmgsIDNoLFxuICAgKiA0aCwgNmgsIDhoLCAxMmgsIDFkLCAxdywgMW1uLiBBbGxvd2VkIHZhbHVlcyBmb3IgTVQ0IGFyZSAxbSwgNW0sIDE1bSAzMG0sIDFoLCA0aCwgMWQsIDF3LCAxbW5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtpbnRlcnZhbEluTWlsbGlzZWNvbmRzXSBkZWZpbmVzIGhvdyBmcmVxdWVudGx5IHRoZSB0ZXJtaW5hbCB3aWxsIHN0cmVhbSBkYXRhIHRvIGNsaWVudC4gSWYgbm90XG4gICAqIHNldCwgdGhlbiB0aGUgdmFsdWUgY29uZmlndXJlZCBpbiBhY2NvdW50IHdpbGwgYmUgdXNlZFxuICAgKi9cblxuICAvKipcbiAgICogU3Vic2NyaWJlcyBvbiBtYXJrZXQgZGF0YSBvZiBzcGVjaWZpZWQgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9tYXJrZXREYXRhU3RyZWFtaW5nL3N1YnNjcmliZVRvTWFya2V0RGF0YS8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3ltYm9sIHN5bWJvbCAoZS5nLiBjdXJyZW5jeSBwYWlyIG9yIGFuIGluZGV4KVxuICAgKiBAcGFyYW0ge0FycmF5PE1hcmtldERhdGFTdWJzY3JpcHRpb24+fSBzdWJzY3JpcHRpb25zIGFycmF5IG9mIG1hcmtldCBkYXRhIHN1YnNjcmlwdGlvbiB0byBjcmVhdGUgb3IgdXBkYXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gc3Vic2NyaXB0aW9uIHJlcXVlc3Qgd2FzIHByb2Nlc3NlZFxuICAgKi9cbiAgc3Vic2NyaWJlVG9NYXJrZXREYXRhKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsIHN5bWJvbCwgc3Vic2NyaXB0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KGFjY291bnRJZCwge3R5cGU6ICdzdWJzY3JpYmVUb01hcmtldERhdGEnLCBzeW1ib2wsIHN1YnNjcmlwdGlvbnMsXG4gICAgICBpbnN0YW5jZUluZGV4OiBpbnN0YW5jZU51bWJlcn0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcmtldCBkYXRhIHVuc3Vic2NyaXB0aW9uXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1hcmtldERhdGFVbnN1YnNjcmlwdGlvblxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSBzdWJzY3JpcHRpb24gdHlwZSwgb25lIG9mIHF1b3RlcywgY2FuZGxlcywgdGlja3MsIG9yIG1hcmtldERlcHRoXG4gICAqL1xuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZXMgZnJvbSBtYXJrZXQgZGF0YSBvZiBzcGVjaWZpZWQgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9tYXJrZXREYXRhU3RyZWFtaW5nL3Vuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEvKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnN0YW5jZU51bWJlciBpbnN0YW5jZSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3ltYm9sIHN5bWJvbCAoZS5nLiBjdXJyZW5jeSBwYWlyIG9yIGFuIGluZGV4KVxuICAgKiBAcGFyYW0ge0FycmF5PE1hcmtldERhdGFVbnN1YnNjcmlwdGlvbj59IHN1YnNjcmlwdGlvbnMgYXJyYXkgb2Ygc3Vic2NyaXB0aW9ucyB0byBjYW5jZWxcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB1bnN1YnNjcmlwdGlvbiByZXF1ZXN0IHdhcyBwcm9jZXNzZWRcbiAgICovXG4gIHVuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlciwgc3ltYm9sLCBzdWJzY3JpcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoYWNjb3VudElkLCB7dHlwZTogJ3Vuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEnLCBzeW1ib2wsIHN1YnNjcmlwdGlvbnMsXG4gICAgICBpbnN0YW5jZUluZGV4OiBpbnN0YW5jZU51bWJlcn0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBzeW1ib2xzIGF2YWlsYWJsZSBvbiBhbiBhY2NvdW50IChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVNYXJrZXREYXRhL3JlYWRTeW1ib2xzLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXRyaWV2ZSBzeW1ib2xzIGZvclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxzdHJpbmc+Pn0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN5bWJvbHMgYXJlIHJldHJpZXZlZFxuICAgKi9cbiAgYXN5bmMgZ2V0U3ltYm9scyhhY2NvdW50SWQpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldFN5bWJvbHMnfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnN5bWJvbHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHNwZWNpZmljYXRpb24gZm9yIGEgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVNYXJrZXREYXRhL3JlYWRTeW1ib2xTcGVjaWZpY2F0aW9uLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXRyaWV2ZSBzeW1ib2wgc3BlY2lmaWNhdGlvbiBmb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gcmV0cmlldmUgc3BlY2lmaWNhdGlvbiBmb3JcbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlclN5bWJvbFNwZWNpZmljYXRpb24+fSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gc3BlY2lmaWNhdGlvbiBpcyByZXRyaWV2ZWRcbiAgICovXG4gIGFzeW5jIGdldFN5bWJvbFNwZWNpZmljYXRpb24oYWNjb3VudElkLCBzeW1ib2wpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldFN5bWJvbFNwZWNpZmljYXRpb24nLCBzeW1ib2x9KTtcbiAgICByZXR1cm4gcmVzcG9uc2Uuc3BlY2lmaWNhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgcHJpY2UgZm9yIGEgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVNYXJrZXREYXRhL3JlYWRTeW1ib2xQcmljZS8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0cmlldmUgc3ltYm9sIHByaWNlIGZvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byByZXRyaWV2ZSBwcmljZSBmb3JcbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlclN5bWJvbFByaWNlPn0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHByaWNlIGlzIHJldHJpZXZlZFxuICAgKi9cbiAgYXN5bmMgZ2V0U3ltYm9sUHJpY2UoYWNjb3VudElkLCBzeW1ib2wpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldFN5bWJvbFByaWNlJywgc3ltYm9sfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnByaWNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBwcmljZSBmb3IgYSBzeW1ib2wgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZXRyaWV2ZU1hcmtldERhdGEvcmVhZENhbmRsZS8pLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0cmlldmUgY2FuZGxlIGZvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byByZXRyaWV2ZSBjYW5kbGUgZm9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0aW1lZnJhbWUgZGVmaW5lcyB0aGUgdGltZWZyYW1lIGFjY29yZGluZyB0byB3aGljaCB0aGUgY2FuZGxlIG11c3QgYmUgZ2VuZXJhdGVkLiBBbGxvd2VkIHZhbHVlcyBmb3JcbiAgICogTVQ1IGFyZSAxbSwgMm0sIDNtLCA0bSwgNW0sIDZtLCAxMG0sIDEybSwgMTVtLCAyMG0sIDMwbSwgMWgsIDJoLCAzaCwgNGgsIDZoLCA4aCwgMTJoLCAxZCwgMXcsIDFtbi4gQWxsb3dlZCB2YWx1ZXNcbiAgICogZm9yIE1UNCBhcmUgMW0sIDVtLCAxNW0gMzBtLCAxaCwgNGgsIDFkLCAxdywgMW1uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJDYW5kbGU+fSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gY2FuZGxlIGlzIHJldHJpZXZlZFxuICAgKi9cbiAgYXN5bmMgZ2V0Q2FuZGxlKGFjY291bnRJZCwgc3ltYm9sLCB0aW1lZnJhbWUpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldENhbmRsZScsIHN5bWJvbCwgdGltZWZyYW1lfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmNhbmRsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgbGF0ZXN0IHRpY2sgZm9yIGEgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVNYXJrZXREYXRhL3JlYWRUaWNrLykuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXRyaWV2ZSBzeW1ib2wgdGljayBmb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gcmV0cmlldmUgdGljayBmb3JcbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlclRpY2s+fSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGljayBpcyByZXRyaWV2ZWRcbiAgICovXG4gIGFzeW5jIGdldFRpY2soYWNjb3VudElkLCBzeW1ib2wpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldFRpY2snLCBzeW1ib2x9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UudGljaztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgbGF0ZXN0IG9yZGVyIGJvb2sgZm9yIGEgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVNYXJrZXREYXRhL3JlYWRCb29rLykuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXRyaWV2ZSBzeW1ib2wgb3JkZXIgYm9vayBmb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gcmV0cmlldmUgb3JkZXIgYm9vayBmb3JcbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlckJvb2s+fSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gb3JkZXIgYm9vayBpcyByZXRyaWV2ZWRcbiAgICovXG4gIGFzeW5jIGdldEJvb2soYWNjb3VudElkLCBzeW1ib2wpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldEJvb2snLCBzeW1ib2x9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuYm9vaztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBjbGllbnQgdXB0aW1lIHN0YXRzIHRvIHRoZSBzZXJ2ZXIuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXRyaWV2ZSBzeW1ib2wgcHJpY2UgZm9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1cHRpbWUgdXB0aW1lIHN0YXRpc3RpY3MgdG8gc2VuZCB0byB0aGUgc2VydmVyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdXB0aW1lIHN0YXRpc3RpY3MgaXMgc3VibWl0dGVkXG4gICAqL1xuICBzYXZlVXB0aW1lKGFjY291bnRJZCwgdXB0aW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoYWNjb3VudElkLCB7dHlwZTogJ3NhdmVVcHRpbWUnLCB1cHRpbWV9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZSBmcm9tIGFjY291bnQgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9zeW5jaHJvbml6aW5nL3Vuc3Vic2NyaWJlKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHJpZXZlIHN5bWJvbCBwcmljZSBmb3JcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBzb2NrZXQgdW5zdWJzY3JpYmVkXG4gICAqL1xuICBhc3luYyB1bnN1YnNjcmliZShhY2NvdW50SWQpIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyLmNhbmNlbEFjY291bnQoYWNjb3VudElkKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5fcnBjUmVxdWVzdChhY2NvdW50SWQsIHt0eXBlOiAndW5zdWJzY3JpYmUnfSk7XG4gICAgICBkZWxldGUgdGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1thY2NvdW50SWRdO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYoIShlcnIgaW5zdGFuY2VvZiBOb3RGb3VuZEVycm9yKSkge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgc3luY2hyb25pemF0aW9uIGxpc3RlbmVyIGZvciBzcGVjaWZpYyBhY2NvdW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZFxuICAgKiBAcGFyYW0ge1N5bmNocm9uaXphdGlvbkxpc3RlbmVyfSBsaXN0ZW5lciBzeW5jaHJvbml6YXRpb24gbGlzdGVuZXIgdG8gYWRkXG4gICAqL1xuICBhZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcihhY2NvdW50SWQsIGxpc3RlbmVyKSB7XG4gICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1thY2NvdW50SWRdO1xuICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1thY2NvdW50SWRdID0gbGlzdGVuZXJzO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBzeW5jaHJvbml6YXRpb24gbGlzdGVuZXIgZm9yIHNwZWNpZmljIGFjY291bnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkXG4gICAqIEBwYXJhbSB7U3luY2hyb25pemF0aW9uTGlzdGVuZXJ9IGxpc3RlbmVyIHN5bmNocm9uaXphdGlvbiBsaXN0ZW5lciB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZVN5bmNocm9uaXphdGlvbkxpc3RlbmVyKGFjY291bnRJZCwgbGlzdGVuZXIpIHtcbiAgICBsZXQgbGlzdGVuZXJzID0gdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW2FjY291bnRJZF07XG4gICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgIGxpc3RlbmVycyA9IFtdO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKGwgPT4gbCAhPT0gbGlzdGVuZXIpO1xuICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1thY2NvdW50SWRdID0gbGlzdGVuZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgbGF0ZW5jeSBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge0xhdGVuY3lMaXN0ZW5lcn0gbGlzdGVuZXIgbGF0ZW5jeSBsaXN0ZW5lciB0byBhZGRcbiAgICovXG4gIGFkZExhdGVuY3lMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuX2xhdGVuY3lMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBsYXRlbmN5IGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7TGF0ZW5jeUxpc3RlbmVyfSBsaXN0ZW5lciBsYXRlbmN5IGxpc3RlbmVyIHRvIHJlbW92ZVxuICAgKi9cbiAgcmVtb3ZlTGF0ZW5jeUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fbGF0ZW5jeUxpc3RlbmVycyA9IHRoaXMuX2xhdGVuY3lMaXN0ZW5lcnMuZmlsdGVyKGwgPT4gbCAhPT0gbGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgcmVjb25uZWN0IGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7UmVjb25uZWN0TGlzdGVuZXJ9IGxpc3RlbmVyIHJlY29ubmVjdCBsaXN0ZW5lciB0byBhZGRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkIG9mIGxpc3RlbmVyXG4gICAqL1xuICBhZGRSZWNvbm5lY3RMaXN0ZW5lcihsaXN0ZW5lciwgYWNjb3VudElkKSB7XG4gICAgdGhpcy5fcmVjb25uZWN0TGlzdGVuZXJzLnB1c2goe2FjY291bnRJZCwgbGlzdGVuZXJ9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHJlY29ubmVjdCBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge1JlY29ubmVjdExpc3RlbmVyfSBsaXN0ZW5lciBsaXN0ZW5lciB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZVJlY29ubmVjdExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcmVjb25uZWN0TGlzdGVuZXJzID0gdGhpcy5fcmVjb25uZWN0TGlzdGVuZXJzLmZpbHRlcihsID0+IGwubGlzdGVuZXIgIT09IGxpc3RlbmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMuIEludGVuZGVkIGZvciB1c2UgaW4gdW5pdCB0ZXN0cy5cbiAgICovXG4gIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLl9yZWNvbm5lY3RMaXN0ZW5lcnMgPSBbXTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFF1ZXVlcyBhbiBhY2NvdW50IHBhY2tldCBmb3IgcHJvY2Vzc2luZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IHBhY2tldCB0byBwcm9jZXNzXG4gICAqL1xuICBxdWV1ZVBhY2tldChwYWNrZXQpIHtcbiAgICBjb25zdCBhY2NvdW50SWQgPSBwYWNrZXQuYWNjb3VudElkO1xuICAgIGNvbnN0IHBhY2tldHMgPSB0aGlzLl9wYWNrZXRPcmRlcmVyLnJlc3RvcmVPcmRlcihwYWNrZXQpLmZpbHRlcihwID0+IHAudHlwZSAhPT0gJ25vb3AnKTtcbiAgICBpZih0aGlzLl9zZXF1ZW50aWFsRXZlbnRQcm9jZXNzaW5nICYmIHBhY2tldC5zZXF1ZW5jZU51bWJlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBldmVudHMgPSBwYWNrZXRzLm1hcChwYWNrZXRJdGVtID0+ICgpID0+IFxuICAgICAgICBQcm9taXNlLnJlc29sdmUodGhpcy5fcHJvY2Vzc1N5bmNocm9uaXphdGlvblBhY2tldChwYWNrZXRJdGVtKSkpO1xuICAgICAgaWYgKCF0aGlzLl9ldmVudFF1ZXVlc1thY2NvdW50SWRdKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50UXVldWVzW2FjY291bnRJZF0gPSBldmVudHM7XG4gICAgICAgIHRoaXMuX2NhbGxBY2NvdW50RXZlbnRzKGFjY291bnRJZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ldmVudFF1ZXVlc1thY2NvdW50SWRdID0gdGhpcy5fZXZlbnRRdWV1ZXNbYWNjb3VudElkXS5jb25jYXQoZXZlbnRzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFja2V0cy5mb3JFYWNoKHBhY2tldEl0ZW0gPT4gdGhpcy5fcHJvY2Vzc1N5bmNocm9uaXphdGlvblBhY2tldChwYWNrZXRJdGVtKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXVlcyBhY2NvdW50IGV2ZW50IGZvciBwcm9jZXNzaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZFxuICAgKiBAcGFyYW0ge1Byb21pc2V9IGV2ZW50IGV2ZW50IHRvIGV4ZWN1dGVcbiAgICovXG4gIHF1ZXVlRXZlbnQoYWNjb3VudElkLCBldmVudCkge1xuICAgIGlmKHRoaXMuX3NlcXVlbnRpYWxFdmVudFByb2Nlc3NpbmcpIHtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRRdWV1ZXNbYWNjb3VudElkXSkgeyBcbiAgICAgICAgdGhpcy5fZXZlbnRRdWV1ZXNbYWNjb3VudElkXSA9IFtldmVudF07XG4gICAgICAgIHRoaXMuX2NhbGxBY2NvdW50RXZlbnRzKGFjY291bnRJZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ldmVudFF1ZXVlc1thY2NvdW50SWRdLnB1c2goZXZlbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBldmVudCgpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIF9jYWxsQWNjb3VudEV2ZW50cyhhY2NvdW50SWQpIHtcbiAgICBpZih0aGlzLl9ldmVudFF1ZXVlc1thY2NvdW50SWRdKSB7XG4gICAgICB3aGlsZSh0aGlzLl9ldmVudFF1ZXVlc1thY2NvdW50SWRdLmxlbmd0aCkge1xuICAgICAgICBhd2FpdCB0aGlzLl9ldmVudFF1ZXVlc1thY2NvdW50SWRdWzBdKCk7XG4gICAgICAgIHRoaXMuX2V2ZW50UXVldWVzW2FjY291bnRJZF0uc2hpZnQoKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudFF1ZXVlc1thY2NvdW50SWRdO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIF9yZWNvbm5lY3Qoc29ja2V0SW5zdGFuY2VJbmRleCkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5zb2NrZXRJbnN0YW5jZXNbc29ja2V0SW5zdGFuY2VJbmRleF07XG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICB3aGlsZSAoIWluc3RhbmNlLnNvY2tldC5jb25uZWN0ZWQgJiYgIWluc3RhbmNlLmlzUmVjb25uZWN0aW5nICYmIGluc3RhbmNlLmNvbm5lY3RlZCkge1xuICAgICAgICBhd2FpdCB0aGlzLl90cnlSZWNvbm5lY3Qoc29ja2V0SW5zdGFuY2VJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3RyeVJlY29ubmVjdChzb2NrZXRJbnN0YW5jZUluZGV4KSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLnNvY2tldEluc3RhbmNlc1tzb2NrZXRJbnN0YW5jZUluZGV4XTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCFpbnN0YW5jZS5zb2NrZXQuY29ubmVjdGVkICYmICFpbnN0YW5jZS5pc1JlY29ubmVjdGluZyAmJiBpbnN0YW5jZS5jb25uZWN0ZWQpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2Vzc2lvbklkID0gcmFuZG9tc3RyaW5nLmdlbmVyYXRlKDMyKTtcbiAgICAgICAgY29uc3QgY2xpZW50SWQgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICBpbnN0YW5jZS5zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgaW5zdGFuY2Uuc29ja2V0LmlvLm9wdHMuZXh0cmFIZWFkZXJzWydDbGllbnQtSWQnXSA9IGNsaWVudElkO1xuICAgICAgICBpbnN0YW5jZS5zb2NrZXQuaW8ub3B0cy5xdWVyeS5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgICAgICBpbnN0YW5jZS5pc1JlY29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgIGluc3RhbmNlLnNvY2tldC5pby51cmkgPSBhd2FpdCB0aGlzLl9nZXRTZXJ2ZXJVcmwoKTtcbiAgICAgICAgaW5zdGFuY2Uuc29ja2V0LmNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoKTtcbiAgICB9LCAxMDAwKSk7XG4gIH1cblxuICAvL2VzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5LCBtYXgtc3RhdGVtZW50c1xuICBhc3luYyBfcnBjUmVxdWVzdChhY2NvdW50SWQsIHJlcXVlc3QsIHRpbWVvdXRJblNlY29uZHMpIHtcbiAgICBsZXQgc29ja2V0SW5zdGFuY2VJbmRleCA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbYWNjb3VudElkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzb2NrZXRJbnN0YW5jZUluZGV4ID0gdGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1thY2NvdW50SWRdO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAodGhpcy5fc3Vic2NyaWJlTG9jayAmJiAoKG5ldyBEYXRlKHRoaXMuX3N1YnNjcmliZUxvY2sucmVjb21tZW5kZWRSZXRyeVRpbWUpLmdldFRpbWUoKSA+IERhdGUubm93KCkgJiYgXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlZEFjY291bnRJZHMoKS5sZW5ndGggPCB0aGlzLl9zdWJzY3JpYmVMb2NrLmxvY2tlZEF0QWNjb3VudHMpIHx8IFxuICAgICAgICAobmV3IERhdGUodGhpcy5fc3Vic2NyaWJlTG9jay5sb2NrZWRBdFRpbWUpLmdldFRpbWUoKSArIHRoaXMuX3N1YnNjcmliZUNvb2xkb3duSW5TZWNvbmRzICogMTAwMCA+IFxuICAgICAgICBEYXRlLm5vdygpICYmIHRoaXMuc3Vic2NyaWJlZEFjY291bnRJZHMoKS5sZW5ndGggPj0gdGhpcy5fc3Vic2NyaWJlTG9jay5sb2NrZWRBdEFjY291bnRzKSkpIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCAxMDAwKSk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fc29ja2V0SW5zdGFuY2VzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBhY2NvdW50Q291bnRlciA9IHRoaXMuZ2V0QXNzaWduZWRBY2NvdW50cyhpbmRleCkubGVuZ3RoO1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuc29ja2V0SW5zdGFuY2VzW2luZGV4XTtcbiAgICAgICAgaWYgKGluc3RhbmNlLnN1YnNjcmliZUxvY2spIHtcbiAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3Vic2NyaWJlTG9jay50eXBlID09PSAnTElNSVRfQUNDT1VOVF9TVUJTQ1JJUFRJT05TX1BFUl9VU0VSX1BFUl9TRVJWRVInICYmIFxuICAgICAgICAgIChuZXcgRGF0ZShpbnN0YW5jZS5zdWJzY3JpYmVMb2NrLnJlY29tbWVuZGVkUmV0cnlUaW1lKS5nZXRUaW1lKCkgPiBEYXRlLm5vdygpIHx8IFxuICAgICAgICAgIHRoaXMuc3Vic2NyaWJlZEFjY291bnRJZHMoaW5kZXgpLmxlbmd0aCA+PSBpbnN0YW5jZS5zdWJzY3JpYmVMb2NrLmxvY2tlZEF0QWNjb3VudHMpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluc3RhbmNlLnN1YnNjcmliZUxvY2sudHlwZSA9PT0gJ0xJTUlUX0FDQ09VTlRfU1VCU0NSSVBUSU9OU19QRVJfU0VSVkVSJyAmJiBcbiAgICAgICAgICBuZXcgRGF0ZShpbnN0YW5jZS5zdWJzY3JpYmVMb2NrLnJlY29tbWVuZGVkUmV0cnlUaW1lKS5nZXRUaW1lKCkgPiBEYXRlLm5vdygpICYmXG4gICAgICAgICAgdGhpcy5zdWJzY3JpYmVkQWNjb3VudElkcyhpbmRleCkubGVuZ3RoID49IGluc3RhbmNlLnN1YnNjcmliZUxvY2subG9ja2VkQXRBY2NvdW50cykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGFjY291bnRDb3VudGVyIDwgdGhpcy5fbWF4QWNjb3VudHNQZXJJbnN0YW5jZSkge1xuICAgICAgICAgIHNvY2tldEluc3RhbmNlSW5kZXggPSBpbmRleDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoc29ja2V0SW5zdGFuY2VJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICBzb2NrZXRJbnN0YW5jZUluZGV4ID0gdGhpcy5fc29ja2V0SW5zdGFuY2VzLmxlbmd0aDtcbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2FjY291bnRJZF0gPSBzb2NrZXRJbnN0YW5jZUluZGV4O1xuICAgIH1cbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuX3NvY2tldEluc3RhbmNlc1tzb2NrZXRJbnN0YW5jZUluZGV4XTtcbiAgICBpZiAoIWluc3RhbmNlLmNvbm5lY3RlZCkge1xuICAgICAgYXdhaXQgdGhpcy5jb25uZWN0KCk7XG4gICAgfSBlbHNlIGlmKCF0aGlzLmNvbm5lY3RlZChzb2NrZXRJbnN0YW5jZUluZGV4KSkge1xuICAgICAgYXdhaXQgaW5zdGFuY2UuY29ubmVjdFJlc3VsdDtcbiAgICB9XG4gICAgaWYocmVxdWVzdC50eXBlID09PSAnc3Vic2NyaWJlJykge1xuICAgICAgcmVxdWVzdC5zZXNzaW9uSWQgPSBpbnN0YW5jZS5zZXNzaW9uSWQ7XG4gICAgfVxuICAgIGlmKFsndHJhZGUnLCAnc3Vic2NyaWJlJ10uaW5jbHVkZXMocmVxdWVzdC50eXBlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX21ha2VSZXF1ZXN0KGFjY291bnRJZCwgcmVxdWVzdCwgdGltZW91dEluU2Vjb25kcyk7XG4gICAgfVxuICAgIGxldCByZXRyeUNvdW50ZXIgPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7IC8vZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9tYWtlUmVxdWVzdChhY2NvdW50SWQsIHJlcXVlc3QsIHRpbWVvdXRJblNlY29uZHMpO1xuICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgaWYoZXJyLm5hbWUgPT09ICdUb29NYW55UmVxdWVzdHNFcnJvcicpIHtcbiAgICAgICAgICBsZXQgY2FsY1JldHJ5Q291bnRlciA9IHJldHJ5Q291bnRlcjtcbiAgICAgICAgICBsZXQgY2FsY1JlcXVlc3RUaW1lID0gMDtcbiAgICAgICAgICB3aGlsZShjYWxjUmV0cnlDb3VudGVyIDwgdGhpcy5fcmV0cmllcykge1xuICAgICAgICAgICAgY2FsY1JldHJ5Q291bnRlcisrO1xuICAgICAgICAgICAgY2FsY1JlcXVlc3RUaW1lICs9IE1hdGgubWluKE1hdGgucG93KDIsIGNhbGNSZXRyeUNvdW50ZXIpICogdGhpcy5fbWluUmV0cnlEZWxheUluU2Vjb25kcyxcbiAgICAgICAgICAgICAgdGhpcy5fbWF4UmV0cnlEZWxheUluU2Vjb25kcykgKiAxMDAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByZXRyeVRpbWUgPSBuZXcgRGF0ZShlcnIubWV0YWRhdGEucmVjb21tZW5kZWRSZXRyeVRpbWUpLmdldFRpbWUoKTtcbiAgICAgICAgICBpZiAoRGF0ZS5ub3coKSArIGNhbGNSZXF1ZXN0VGltZSA+IHJldHJ5VGltZSAmJiByZXRyeUNvdW50ZXIgPCB0aGlzLl9yZXRyaWVzKSB7XG4gICAgICAgICAgICBpZihEYXRlLm5vdygpIDwgcmV0cnlUaW1lKSB7XG4gICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgcmV0cnlUaW1lIC0gRGF0ZS5ub3coKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0cnlDb3VudGVyKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihbJ05vdFN5bmNocm9uaXplZEVycm9yJywgJ1RpbWVvdXRFcnJvcicsICdOb3RBdXRoZW50aWNhdGVkRXJyb3InLFxuICAgICAgICAgICdJbnRlcm5hbEVycm9yJ10uaW5jbHVkZXMoZXJyLm5hbWUpICYmIFxuICAgICAgICAgIHJldHJ5Q291bnRlciA8IHRoaXMuX3JldHJpZXMpIHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIE1hdGgubWluKE1hdGgucG93KDIsIHJldHJ5Q291bnRlcikgKiBcbiAgICAgICAgICAgIHRoaXMuX21pblJldHJ5RGVsYXlJblNlY29uZHMsIHRoaXMuX21heFJldHJ5RGVsYXlJblNlY29uZHMpICogMTAwMCkpO1xuICAgICAgICAgIHJldHJ5Q291bnRlcisrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2FjY291bnRJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9tYWtlUmVxdWVzdChhY2NvdW50SWQsIHJlcXVlc3QsIHRpbWVvdXRJblNlY29uZHMpIHtcbiAgICBjb25zdCBzb2NrZXRJbnN0YW5jZSA9IHRoaXMuX3NvY2tldEluc3RhbmNlc1t0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2FjY291bnRJZF1dO1xuICAgIGxldCByZXF1ZXN0SWQgPSByZXF1ZXN0LnJlcXVlc3RJZCB8fCByYW5kb21zdHJpbmcuZ2VuZXJhdGUoMzIpO1xuICAgIHJlcXVlc3QudGltZXN0YW1wcyA9IHtjbGllbnRQcm9jZXNzaW5nU3RhcnRlZDogbmV3IERhdGUoKX07XG4gICAgbGV0IHJlc3VsdCA9IFByb21pc2UucmFjZShbXG4gICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBzb2NrZXRJbnN0YW5jZS5yZXF1ZXN0UmVzb2x2ZXNbcmVxdWVzdElkXSA9IFxuICAgICAgICB7cmVzb2x2ZSwgcmVqZWN0LCB0eXBlOiByZXF1ZXN0LnR5cGV9KSxcbiAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBUaW1lb3V0RXJyb3IoJ01ldGFBcGkgd2Vic29ja2V0IGNsaWVudCAnICsgXG4gICAgICAgIGByZXF1ZXN0ICR7cmVxdWVzdC5yZXF1ZXN0SWR9IG9mIHR5cGUgJHtyZXF1ZXN0LnR5cGV9IHRpbWVkIG91dC4gUGxlYXNlIG1ha2Ugc3VyZSB5b3VyIGFjY291bnQgaXMgY29ubmVjdGVkIGAgK1xuICAgICAgICAgICd0byBicm9rZXIgYmVmb3JlIHJldHJ5aW5nIHlvdXIgcmVxdWVzdC4nKSksICh0aW1lb3V0SW5TZWNvbmRzICogMTAwMCkgfHwgdGhpcy5fcmVxdWVzdFRpbWVvdXQpKVxuICAgIF0pO1xuICAgIHJlcXVlc3QuYWNjb3VudElkID0gYWNjb3VudElkO1xuICAgIHJlcXVlc3QuYXBwbGljYXRpb24gPSByZXF1ZXN0LmFwcGxpY2F0aW9uIHx8IHRoaXMuX2FwcGxpY2F0aW9uO1xuICAgIGlmICghcmVxdWVzdC5yZXF1ZXN0SWQpIHtcbiAgICAgIHJlcXVlc3QucmVxdWVzdElkID0gcmVxdWVzdElkO1xuICAgIH1cbiAgICBzb2NrZXRJbnN0YW5jZS5zb2NrZXQuZW1pdCgncmVxdWVzdCcsIHJlcXVlc3QpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBfY29udmVydEVycm9yKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5lcnJvciA9PT0gJ1ZhbGlkYXRpb25FcnJvcicpIHtcbiAgICAgIHJldHVybiBuZXcgVmFsaWRhdGlvbkVycm9yKGRhdGEubWVzc2FnZSwgZGF0YS5kZXRhaWxzKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdOb3RGb3VuZEVycm9yJykge1xuICAgICAgcmV0dXJuIG5ldyBOb3RGb3VuZEVycm9yKGRhdGEubWVzc2FnZSk7XG4gICAgfSBlbHNlIGlmIChkYXRhLmVycm9yID09PSAnTm90U3luY2hyb25pemVkRXJyb3InKSB7XG4gICAgICByZXR1cm4gbmV3IE5vdFN5bmNocm9uaXplZEVycm9yKGRhdGEubWVzc2FnZSk7XG4gICAgfSBlbHNlIGlmIChkYXRhLmVycm9yID09PSAnVGltZW91dEVycm9yJykge1xuICAgICAgcmV0dXJuIG5ldyBUaW1lb3V0RXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdOb3RBdXRoZW50aWNhdGVkRXJyb3InKSB7XG4gICAgICByZXR1cm4gbmV3IE5vdENvbm5lY3RlZEVycm9yKGRhdGEubWVzc2FnZSk7XG4gICAgfSBlbHNlIGlmIChkYXRhLmVycm9yID09PSAnVHJhZGVFcnJvcicpIHtcbiAgICAgIHJldHVybiBuZXcgVHJhZGVFcnJvcihkYXRhLm1lc3NhZ2UsIGRhdGEubnVtZXJpY0NvZGUsIGRhdGEuc3RyaW5nQ29kZSk7XG4gICAgfSBlbHNlIGlmIChkYXRhLmVycm9yID09PSAnVW5hdXRob3JpemVkRXJyb3InKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICByZXR1cm4gbmV3IFVuYXV0aG9yaXplZEVycm9yKGRhdGEubWVzc2FnZSk7XG4gICAgfSBlbHNlIGlmIChkYXRhLmVycm9yID09PSAnVG9vTWFueVJlcXVlc3RzRXJyb3InKSB7XG4gICAgICByZXR1cm4gbmV3IFRvb01hbnlSZXF1ZXN0c0Vycm9yKGRhdGEubWVzc2FnZSwgZGF0YS5tZXRhZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgSW50ZXJuYWxFcnJvcihkYXRhLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIF9jb252ZXJ0SXNvVGltZVRvRGF0ZShwYWNrZXQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXG4gICAgZm9yIChsZXQgZmllbGQgaW4gcGFja2V0KSB7XG4gICAgICBsZXQgdmFsdWUgPSBwYWNrZXRbZmllbGRdO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgZmllbGQubWF0Y2goL3RpbWUkfFRpbWUkLykgJiYgXG4gICAgICAgICFmaWVsZC5tYXRjaCgvYnJva2VyVGltZSR8QnJva2VyVGltZSR8dGltZWZyYW1lJC8pKSB7XG4gICAgICAgIHBhY2tldFtmaWVsZF0gPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuX2NvbnZlcnRJc29UaW1lVG9EYXRlKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0aGlzLl9jb252ZXJ0SXNvVGltZVRvRGF0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYWNrZXQgJiYgcGFja2V0LnRpbWVzdGFtcHMpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cbiAgICAgIGZvciAobGV0IGZpZWxkIGluIHBhY2tldC50aW1lc3RhbXBzKSB7XG4gICAgICAgIHBhY2tldC50aW1lc3RhbXBzW2ZpZWxkXSA9IG5ldyBEYXRlKHBhY2tldC50aW1lc3RhbXBzW2ZpZWxkXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYWNrZXQgJiYgcGFja2V0LnR5cGUgPT09ICdwcmljZXMnKSB7XG4gICAgICBmb3IgKGxldCBwcmljZSBvZiBwYWNrZXQucHJpY2VzIHx8IFtdKSB7XG4gICAgICAgIGlmIChwcmljZS50aW1lc3RhbXBzKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgICAgICAgIGZvciAobGV0IGZpZWxkIGluIHByaWNlLnRpbWVzdGFtcHMpIHtcbiAgICAgICAgICAgIHByaWNlLnRpbWVzdGFtcHNbZmllbGRdID0gbmV3IERhdGUocHJpY2UudGltZXN0YW1wc1tmaWVsZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRhVHJhZGVyIHN5bWJvbCBzcGVjaWZpY2F0aW9uLiBDb250YWlucyBzeW1ib2wgc3BlY2lmaWNhdGlvbiAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9tb2RlbHMvbWV0YXRyYWRlclN5bWJvbFNwZWNpZmljYXRpb24vKVxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhdHJhZGVyU3ltYm9sU3BlY2lmaWNhdGlvblxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gc3ltYm9sIHN5bWJvbCAoZS5nLiBhIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0aWNrU2l6ZSB0aWNrIHNpemVcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG1pblZvbHVtZSBtaW5pbXVtIG9yZGVyIHZvbHVtZSBmb3IgdGhlIHN5bWJvbFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gbWF4Vm9sdW1lIG1heGltdW0gb3JkZXIgdm9sdW1lIGZvciB0aGUgc3ltYm9sXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB2b2x1bWVTdGVwIG9yZGVyIHZvbHVtZSBzdGVwIGZvciB0aGUgc3ltYm9sXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8U3RyaW5nPn0gbGlzdCBvZiBhbGxvd2VkIG9yZGVyIGZpbGxpbmcgbW9kZXMuIENhbiBjb250YWluIE9SREVSX0ZJTExJTkdfRk9LLCBPUkRFUl9GSUxMSU5HX0lPQyBvclxuICAgKiBib3RoLiBTZWUgaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZW52aXJvbm1lbnRfc3RhdGUvbWFya2V0aW5mb2NvbnN0YW50cyNzeW1ib2xfZmlsbGluZ19tb2RlIGZvciBtb3JlXG4gICAqIGRldGFpbHMuXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkZWFsIGV4ZWN1dGlvbiBtb2RlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIFNZTUJPTF9UUkFERV9FWEVDVVRJT05fUkVRVUVTVCxcbiAgICogU1lNQk9MX1RSQURFX0VYRUNVVElPTl9JTlNUQU5ULCBTWU1CT0xfVFJBREVfRVhFQ1VUSU9OX01BUktFVCwgU1lNQk9MX1RSQURFX0VYRUNVVElPTl9FWENIQU5HRS4gU2VlXG4gICAqIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL2Vudmlyb25tZW50X3N0YXRlL21hcmtldGluZm9jb25zdGFudHMjZW51bV9zeW1ib2xfdHJhZGVfZXhlY3V0aW9uIGZvciBtb3JlXG4gICAqIGRldGFpbHMuXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb250cmFjdFNpemUgdHJhZGUgY29udHJhY3Qgc2l6ZVxuICAgKiBAcHJvcGVydHkge01ldGF0cmFkZXJTZXNzaW9uc30gcXVvdGVTZXNzaW9ucyBxdW90ZSBzZXNzaW9ucywgaW5kZXhlZCBieSBkYXkgb2Ygd2Vla1xuICAgKiBAcHJvcGVydHkge01ldGF0cmFkZXJTZXNzaW9uc30gdHJhZGVTZXNzaW9ucyB0cmFkZSBzZXNzaW9ucywgaW5kZXhlZCBieSBkYXkgb2Ygd2Vla1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3RyYWRlTW9kZV0gb3JkZXIgZXhlY3V0aW9uIHR5cGUuIFBvc3NpYmxlIHZhbHVlcyBhcmUgU1lNQk9MX1RSQURFX01PREVfRElTQUJMRUQsXG4gICAqIFNZTUJPTF9UUkFERV9NT0RFX0xPTkdPTkxZLCBTWU1CT0xfVFJBREVfTU9ERV9TSE9SVE9OTFksIFNZTUJPTF9UUkFERV9NT0RFX0NMT1NFT05MWSwgU1lNQk9MX1RSQURFX01PREVfRlVMTC4gU2VlXG4gICAqIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL2Vudmlyb25tZW50X3N0YXRlL21hcmtldGluZm9jb25zdGFudHMjZW51bV9zeW1ib2xfdHJhZGVfbW9kZSBmb3IgbW9yZVxuICAgKiBkZXRhaWxzXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYm9uZEFjY3J1ZWRJbnRlcmVzdF0gYWNjcnVlZCBpbnRlcmVzdCDigJMgYWNjdW11bGF0ZWQgY291cG9uIGludGVyZXN0LCBpLmUuIHBhcnQgb2YgdGhlIGNvdXBvblxuICAgKiBpbnRlcmVzdCBjYWxjdWxhdGVkIGluIHByb3BvcnRpb24gdG8gdGhlIG51bWJlciBvZiBkYXlzIHNpbmNlIHRoZSBjb3Vwb24gYm9uZCBpc3N1YW5jZSBvciB0aGUgbGFzdCBjb3Vwb24gaW50ZXJlc3RcbiAgICogcGF5bWVudFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW2JvbmRGYWNlVmFsdWVdIGZhY2UgdmFsdWUg4oCTIGluaXRpYWwgYm9uZCB2YWx1ZSBzZXQgYnkgdGhlIGlzc3VlclxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW29wdGlvblN0cmlrZV0gdGhlIHN0cmlrZSBwcmljZSBvZiBhbiBvcHRpb24uIFRoZSBwcmljZSBhdCB3aGljaCBhbiBvcHRpb24gYnV5ZXIgY2FuIGJ1eSAoaW4gYVxuICAgKiBDYWxsIG9wdGlvbikgb3Igc2VsbCAoaW4gYSBQdXQgb3B0aW9uKSB0aGUgdW5kZXJseWluZyBhc3NldCwgYW5kIHRoZSBvcHRpb24gc2VsbGVyIGlzIG9ibGlnZWQgdG8gc2VsbCBvciBidXkgdGhlXG4gICAqIGFwcHJvcHJpYXRlIGFtb3VudCBvZiB0aGUgdW5kZXJseWluZyBhc3NldC5cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtvcHRpb25QcmljZVNlbnNpdml0eV0gb3B0aW9uL3dhcnJhbnQgc2Vuc2l0aXZpdHkgc2hvd3MgYnkgaG93IG1hbnkgcG9pbnRzIHRoZSBwcmljZSBvZiB0aGVcbiAgICogb3B0aW9uJ3MgdW5kZXJseWluZyBhc3NldCBzaG91bGQgY2hhbmdlIHNvIHRoYXQgdGhlIHByaWNlIG9mIHRoZSBvcHRpb24gY2hhbmdlcyBieSBvbmUgcG9pbnRcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtsaXF1aWRpdHlSYXRlXSBsaXF1aWRpdHkgUmF0ZSBpcyB0aGUgc2hhcmUgb2YgdGhlIGFzc2V0IHRoYXQgY2FuIGJlIHVzZWQgZm9yIHRoZSBtYXJnaW5cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGluaXRpYWxNYXJnaW4gaW5pdGlhbCBtYXJnaW4gbWVhbnMgdGhlIGFtb3VudCBpbiB0aGUgbWFyZ2luIGN1cnJlbmN5IHJlcXVpcmVkIGZvciBvcGVuaW5nIGFcbiAgICogcG9zaXRpb24gd2l0aCB0aGUgdm9sdW1lIG9mIG9uZSBsb3QuIEl0IGlzIHVzZWQgZm9yIGNoZWNraW5nIGEgY2xpZW50J3MgYXNzZXRzIHdoZW4gaGUgb3Igc2hlIGVudGVycyB0aGUgbWFya2V0XG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtYWludGVuYW5jZU1hcmdpbiB0aGUgbWFpbnRlbmFuY2UgbWFyZ2luLiBJZiBpdCBpcyBzZXQsIGl0IHNldHMgdGhlIG1hcmdpbiBhbW91bnQgaW4gdGhlIG1hcmdpblxuICAgKiBjdXJyZW5jeSBvZiB0aGUgc3ltYm9sLCBjaGFyZ2VkIGZyb20gb25lIGxvdC4gSXQgaXMgdXNlZCBmb3IgY2hlY2tpbmcgYSBjbGllbnQncyBhc3NldHMgd2hlbiBoaXMvaGVyIGFjY291bnQgc3RhdGVcbiAgICogY2hhbmdlcy4gSWYgdGhlIG1haW50ZW5hbmNlIG1hcmdpbiBpcyBlcXVhbCB0byAwLCB0aGUgaW5pdGlhbCBtYXJnaW4gaXMgdXNlZFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gaGVkZ2VkTWFyZ2luIGNvbnRyYWN0IHNpemUgb3IgbWFyZ2luIHZhbHVlIHBlciBvbmUgbG90IG9mIGhlZGdlZCBwb3NpdGlvbnMgKG9wcG9zaXRlbHkgZGlyZWN0ZWRcbiAgICogcG9zaXRpb25zIG9mIG9uZSBzeW1ib2wpLiBUd28gbWFyZ2luIGNhbGN1bGF0aW9uIG1ldGhvZHMgYXJlIHBvc3NpYmxlIGZvciBoZWRnZWQgcG9zaXRpb25zLiBUaGUgY2FsY3VsYXRpb24gbWV0aG9kXG4gICAqIGlzIGRlZmluZWQgYnkgdGhlIGJyb2tlclxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtoZWRnZWRNYXJnaW5Vc2VzTGFyZ2VyTGVnXSBjYWxjdWxhdGluZyBoZWRnaW5nIG1hcmdpbiB1c2luZyB0aGUgbGFyZ2VyIGxlZyAoQnV5IG9yIFNlbGwpXG4gICAqIEBwcm9wZXJ0aWVzIHtTdHJpbmd9IG1hcmdpbkN1cnJlbmN5IG1hcmdpbiBjdXJyZW5jeVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gcHJpY2VDYWxjdWxhdGlvbk1vZGUgY29udHJhY3QgcHJpY2UgY2FsY3VsYXRpb24gbW9kZS4gT25lIG9mIFNZTUJPTF9DQUxDX01PREVfVU5LTk9XTixcbiAgICogU1lNQk9MX0NBTENfTU9ERV9GT1JFWCwgU1lNQk9MX0NBTENfTU9ERV9GT1JFWF9OT19MRVZFUkFHRSwgU1lNQk9MX0NBTENfTU9ERV9GVVRVUkVTLCBTWU1CT0xfQ0FMQ19NT0RFX0NGRCxcbiAgICogU1lNQk9MX0NBTENfTU9ERV9DRkRJTkRFWCwgU1lNQk9MX0NBTENfTU9ERV9DRkRMRVZFUkFHRSwgU1lNQk9MX0NBTENfTU9ERV9FWENIX1NUT0NLUyxcbiAgICogU1lNQk9MX0NBTENfTU9ERV9FWENIX0ZVVFVSRVMsIFNZTUJPTF9DQUxDX01PREVfRVhDSF9GVVRVUkVTX0ZPUlRTLCBTWU1CT0xfQ0FMQ19NT0RFX0VYQ0hfQk9ORFMsXG4gICAqIFNZTUJPTF9DQUxDX01PREVfRVhDSF9TVE9DS1NfTU9FWCwgU1lNQk9MX0NBTENfTU9ERV9FWENIX0JPTkRTX01PRVgsIFNZTUJPTF9DQUxDX01PREVfU0VSVl9DT0xMQVRFUkFMLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZW52aXJvbm1lbnRfc3RhdGUvbWFya2V0aW5mb2NvbnN0YW50cyNlbnVtX3N5bWJvbF9jYWxjX21vZGUgZm9yIG1vcmUgZGV0YWlsc1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gYmFzZUN1cnJlbmN5IGJhc2UgY3VycmVuY3lcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtwcm9maXRDdXJyZW5jeV0gcHJvZml0IGN1cnJlbmN5XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzd2FwTW9kZSBzd2FwIGNhbGN1bGF0aW9uIG1vZGVsLiBBbGxvd2VkIHZhbHVlcyBhcmUgU1lNQk9MX1NXQVBfTU9ERV9ESVNBQkxFRCxcbiAgICogU1lNQk9MX1NXQVBfTU9ERV9QT0lOVFMsIFNZTUJPTF9TV0FQX01PREVfQ1VSUkVOQ1lfU1lNQk9MLCBTWU1CT0xfU1dBUF9NT0RFX0NVUlJFTkNZX01BUkdJTixcbiAgICogU1lNQk9MX1NXQVBfTU9ERV9DVVJSRU5DWV9ERVBPU0lULCBTWU1CT0xfU1dBUF9NT0RFX0lOVEVSRVNUX0NVUlJFTlQsIFNZTUJPTF9TV0FQX01PREVfSU5URVJFU1RfT1BFTixcbiAgICogU1lNQk9MX1NXQVBfTU9ERV9SRU9QRU5fQ1VSUkVOVCwgU1lNQk9MX1NXQVBfTU9ERV9SRU9QRU5fQklELiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZW52aXJvbm1lbnRfc3RhdGUvbWFya2V0aW5mb2NvbnN0YW50cyNlbnVtX3N5bWJvbF9zd2FwX21vZGUgZm9yIG1vcmUgZGV0YWlsc1xuICAgKiBAcHJvcGVydHkge051bWJlcn0gW3N3YXBMb25nXSBsb25nIHN3YXAgdmFsdWVcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzd2FwU2hvcnRdIHNob3J0IHN3YXAgdmFsdWVcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtzd2FwUm9sbG92ZXIzRGF5c10gZGF5IG9mIHdlZWsgdG8gY2hhcmdlIDMgZGF5cyBzd2FwIHJvbGxvdmVyLiBBbGxvd2VkIHZhbHVlcyBhcmUgU1VOREFZLFxuICAgKiBNT05EQVksIFRVRVNEQVksIFdFRE5FU0RBWSwgVEhVUkRBWSwgRlJJREFZLCBTQVRVUkRBWSwgTk9ORVxuICAgKiBAcHJvcGVydHkge0FycmF5PFN0cmluZz59IGFsbG93ZWRFeHBpcmF0aW9uTW9kZXMgYWxsb3dlZCBvcmRlciBleHBpcmF0aW9uIG1vZGVzLiBBbGxvd2VkIHZhbHVlcyBhcmVcbiAgICogU1lNQk9MX0VYUElSQVRJT05fR1RDLCBTWU1CT0xfRVhQSVJBVElPTl9EQVksIFNZTUJPTF9FWFBJUkFUSU9OX1NQRUNJRklFRCwgU1lNQk9MX0VYUElSQVRJT05fU1BFQ0lGSUVEX0RBWS5cbiAgICogU2VlIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL2Vudmlyb25tZW50X3N0YXRlL21hcmtldGluZm9jb25zdGFudHMjc3ltYm9sX2V4cGlyYXRpb25fbW9kZSBmb3IgbW9yZVxuICAgKiBkZXRhaWxzXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8U3RyaW5nPn0gYWxsb3dlZE9yZGVyVHlwZXMgYWxsb3dlZCBvcmRlciB0eXBlcy4gQWxsb3dlZCB2YWx1ZXMgYXJlIFNZTUJPTF9PUkRFUl9NQVJLRVQsXG4gICAqIFNZTUJPTF9PUkRFUl9MSU1JVCwgU1lNQk9MX09SREVSX1NUT1AsIFNZTUJPTF9PUkRFUl9TVE9QX0xJTUlULCBTWU1CT0xfT1JERVJfU0wsIFNZTUJPTF9PUkRFUl9UUCxcbiAgICogU1lNQk9MX09SREVSX0NMT1NFQlkuIFNlZVxuICAgKiBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy9lbnZpcm9ubWVudF9zdGF0ZS9tYXJrZXRpbmZvY29uc3RhbnRzI3N5bWJvbF9vcmRlcl9tb2RlIGZvciBtb3JlIGRldGFpbHNcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IG9yZGVyR1RDTW9kZSBpZiB0aGUgZXhwaXJhdGlvbk1vZGUgcHJvcGVydHkgaXMgc2V0IHRvIFNZTUJPTF9FWFBJUkFUSU9OX0dUQyAoZ29vZCB0aWxsXG4gICAqIGNhbmNlbGVkKSwgdGhlIGV4cGlyYXRpb24gb2YgcGVuZGluZyBvcmRlcnMsIGFzIHdlbGwgYXMgb2YgU3RvcCBMb3NzL1Rha2UgUHJvZml0IG9yZGVycyBzaG91bGQgYmUgYWRkaXRpb25hbGx5IHNldFxuICAgKiB1c2luZyB0aGlzIGVudW1lcmF0aW9uLiBBbGxvd2VkIHZhbHVlcyBhcmUgU1lNQk9MX09SREVSU19HVEMsIFNZTUJPTF9PUkRFUlNfREFJTFksXG4gICAqIFNZTUJPTF9PUkRFUlNfREFJTFlfRVhDTFVESU5HX1NUT1BTLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZW52aXJvbm1lbnRfc3RhdGUvbWFya2V0aW5mb2NvbnN0YW50cyNlbnVtX3N5bWJvbF9vcmRlcl9ndGNfbW9kZSBmb3IgbW9yZVxuICAgKiBkZXRhaWxzXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkaWdpdHMgZGlnaXRzIGFmdGVyIGEgZGVjaW1hbCBwb2ludFxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3BhdGhdIHBhdGggaW4gdGhlIHN5bWJvbCB0cmVlXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkZXNjcmlwdGlvbiBzeW1ib2wgZGVzY3JpcHRpb25cbiAgICogQHByb3BlcnR5IHtEYXRlfSBbc3RhcnRUaW1lXSBkYXRlIG9mIHRoZSBzeW1ib2wgdHJhZGUgYmVnaW5uaW5nICh1c3VhbGx5IHVzZWQgZm9yIGZ1dHVyZXMpXG4gICAqIEBwcm9wZXJ0eSB7RGF0ZX0gW2V4cGlyYXRpb25UaW1lXSBkYXRlIG9mIHRoZSBzeW1ib2wgdHJhZGUgZW5kICh1c3VhbGx5IHVzZWQgZm9yIGZ1dHVyZXMpXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNZXRhdHJhZGVyIHRyYWRlIG9yIHF1b3RlIHNlc3Npb24gY29udGFpbmVyLCBpbmRleGVkIGJ5IHdlZWtkYXlcbiAgICogQHR5cGVkZWYge09iamVjdH0gTWV0YXRyYWRlclNlc3Npb25zXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8TWV0YXRyYWRlclNlc3Npb24+fSBbU1VOREFZXSBhcnJheSBvZiBzZXNzaW9ucyBmb3IgU1VOREFZXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8TWV0YXRyYWRlclNlc3Npb24+fSBbTU9OREFZXSBhcnJheSBvZiBzZXNzaW9ucyBmb3IgTU9OREFZXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8TWV0YXRyYWRlclNlc3Npb24+fSBbVFVFU0RBWV0gYXJyYXkgb2Ygc2Vzc2lvbnMgZm9yIFRVRVNEQVlcbiAgICogQHByb3BlcnR5IHtBcnJheTxNZXRhdHJhZGVyU2Vzc2lvbj59IFtXRURORVNEQVldIGFycmF5IG9mIHNlc3Npb25zIGZvciBXRURORVNEQVlcbiAgICogQHByb3BlcnR5IHtBcnJheTxNZXRhdHJhZGVyU2Vzc2lvbj59IFtUSFVSU0RBWV0gYXJyYXkgb2Ygc2Vzc2lvbnMgZm9yIFRIVVJTREFZXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8TWV0YXRyYWRlclNlc3Npb24+fSBbRlJJREFZXSBhcnJheSBvZiBzZXNzaW9ucyBmb3IgRlJJREFZXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8TWV0YXRyYWRlclNlc3Npb24+fSBbU0FUVVJEQVldIGFycmF5IG9mIHNlc3Npb25zIGZvciBTQVRVUkRBWVxuICAgKi9cblxuICAvKipcbiAgICogTWV0YXRyYWRlciB0cmFkZSBvciBxdW90ZSBzZXNzaW9uXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJTZXNzaW9uXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBmcm9tIHNlc3Npb24gc3RhcnQgdGltZSwgaW4gaGgubW0uc3MuU1NTIGZvcm1hdFxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gdG8gc2Vzc2lvbiBlbmQgdGltZSwgaW4gaGgubW0uc3MuU1NTIGZvcm1hdFxuICAgKi9cblxuICAvKipcbiAgICogTWV0YVRyYWRlciBzeW1ib2wgcHJpY2UuIENvbnRhaW5zIGN1cnJlbnQgcHJpY2UgZm9yIGEgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L21vZGVscy9tZXRhdHJhZGVyU3ltYm9sUHJpY2UvKVxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhdHJhZGVyU3ltYm9sUHJpY2VcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gYSBjdXJyZW5jeSBwYWlyIG9yIGFuIGluZGV4KVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gYmlkIGJpZCBwcmljZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gYXNrIGFzayBwcmljZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gcHJvZml0VGlja1ZhbHVlIHRpY2sgdmFsdWUgZm9yIGEgcHJvZml0YWJsZSBwb3NpdGlvblxuICAgKiBAcHJvcGVydHkge051bWJlcn0gbG9zc1RpY2tWYWx1ZSB0aWNrIHZhbHVlIGZvciBhIGxvc2luZyBwb3NpdGlvblxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW2FjY291bnRDdXJyZW5jeUV4Y2hhbmdlUmF0ZV0gY3VycmVudCBleGNoYW5nZSByYXRlIG9mIGFjY291bnQgY3VycmVuY3kgaW50byBhY2NvdW50IGJhc2VcbiAgICogY3VycmVuY3kgKFVTRCBpZiB5b3UgZGlkIG5vdCBvdmVycmlkZSBpdClcbiAgICogQHByb3BlcnR5IHtEYXRlfSB0aW1lIHF1b3RlIHRpbWUsIGluIElTTyBmb3JtYXRcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGJyb2tlclRpbWUgdGltZSBxdW90ZSB0aW1lLCBpbiBicm9rZXIgdGltZXpvbmUsIFlZWVktTU0tREQgSEg6bW06c3MuU1NTIGZvcm1hdFxuICAgKi9cblxuICAvKipcbiAgICogTWV0YVRyYWRlciBjYW5kbGVcbiAgICogQHR5cGVkZWYge09iamVjdH0gTWV0YXRyYWRlckNhbmRsZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gc3ltYm9sIHN5bWJvbCAoZS5nLiBjdXJyZW5jeSBwYWlyIG9yIGFuIGluZGV4KVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdGltZWZyYW1lIHRpbWVmcmFtZSBjYW5kbGUgd2FzIGdlbmVyYXRlZCBmb3IsIGUuZy4gMWguIE9uZSBvZiAxbSwgMm0sIDNtLCA0bSwgNW0sIDZtLCAxMG0sIDEybSxcbiAgICogMTVtLCAyMG0sIDMwbSwgMWgsIDJoLCAzaCwgNGgsIDZoLCA4aCwgMTJoLCAxZCwgMXcsIDFtblxuICAgKiBAcHJvcGVydHkge0RhdGV9IHRpbWUgY2FuZGxlIG9wZW5pbmcgdGltZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gYnJva2VyVGltZSBjYW5kbGUgb3BlbmluZyB0aW1lLCBpbiBicm9rZXIgdGltZXpvbmUsIFlZWVktTU0tREQgSEg6bW06c3MuU1NTIGZvcm1hdFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gb3BlbiBvcGVuIHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoaWdoIGhpZ2ggcHJpY2VcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGxvdyBsb3cgcHJpY2VcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNsb3NlIGNsb3NlIHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aWNrVm9sdW1lIHRpY2sgdm9sdW1lLCBpLmUuIG51bWJlciBvZiB0aWNrcyBpbnNpZGUgdGhlIGNhbmRsZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gc3ByZWFkIHNwcmVhZCBpbiBwb2ludHNcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHZvbHVtZSB0cmFkZSB2b2x1bWVcbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGFUcmFkZXIgdGljayBkYXRhXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJUaWNrXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIChlLmcuIGEgY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHByb3BlcnR5IHtEYXRlfSB0aW1lIHRpbWVcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGJyb2tlclRpbWUgdGltZSwgaW4gYnJva2VyIHRpbWV6b25lLCBZWVlZLU1NLUREIEhIOm1tOnNzLlNTUyBmb3JtYXRcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtiaWRdIGJpZCBwcmljZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW2Fza10gYXNrIHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGFzdF0gbGFzdCBkZWFsIHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdm9sdW1lXSB2b2x1bWUgZm9yIHRoZSBjdXJyZW50IGxhc3QgZGVhbCBwcmljZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gc2lkZSBpcyB0aWNrIGEgcmVzdWx0IG9mIGJ1eSBvciBzZWxsIGRlYWwsIG9uZSBvZiBidXkgb3Igc2VsbFxuICAgKi9cblxuICAvKipcbiAgICogTWV0YVRyYWRlciBvcmRlciBib29rXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJCb29rXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIChlLmcuIGEgY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHByb3BlcnR5IHtEYXRlfSB0aW1lIHRpbWVcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGJyb2tlclRpbWUgdGltZSwgaW4gYnJva2VyIHRpbWV6b25lLCBZWVlZLU1NLUREIEhIOm1tOnNzLlNTUyBmb3JtYXRcbiAgICogQHByb3BlcnR5IHtBcnJheTxNZXRhdHJhZGVyQm9va0VudHJ5Pn0gYm9vayBsaXN0IG9mIG9yZGVyIGJvb2sgZW50cmllc1xuICAgKi9cblxuICAvKipcbiAgICogTWV0YVRyYWRlciBvcmRlciBib29rIGVudHJ5XG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJCb29rRW50cnlcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgZW50cnkgdHlwZSwgb25lIG9mIEJPT0tfVFlQRV9TRUxMLCBCT09LX1RZUEVfQlVZLCBCT09LX1RZUEVfU0VMTF9NQVJLRVQsXG4gICAqIEJPT0tfVFlQRV9CVVlfTUFSS0VUXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwcmljZSBwcmljZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gdm9sdW1lIHZvbHVtZVxuICAgKi9cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eSxtYXgtc3RhdGVtZW50c1xuICBhc3luYyBfcHJvY2Vzc1N5bmNocm9uaXphdGlvblBhY2tldChkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNvY2tldEluc3RhbmNlID0gdGhpcy5fc29ja2V0SW5zdGFuY2VzW3RoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbZGF0YS5hY2NvdW50SWRdXTtcbiAgICAgIGlmIChkYXRhLnN5bmNocm9uaXphdGlvbklkICYmIHNvY2tldEluc3RhbmNlKSB7XG4gICAgICAgIHNvY2tldEluc3RhbmNlLnN5bmNocm9uaXphdGlvblRocm90dGxlci51cGRhdGVTeW5jaHJvbml6YXRpb25JZChkYXRhLnN5bmNocm9uaXphdGlvbklkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluc3RhbmNlTnVtYmVyID0gZGF0YS5pbnN0YW5jZUluZGV4IHx8IDA7XG4gICAgICBsZXQgaW5zdGFuY2VJZCA9IGRhdGEuYWNjb3VudElkICsgJzonICsgaW5zdGFuY2VOdW1iZXIgKyAnOicgKyAoZGF0YS5ob3N0IHx8IDApO1xuICAgICAgbGV0IGluc3RhbmNlSW5kZXggPSBpbnN0YW5jZU51bWJlciArICc6JyArIChkYXRhLmhvc3QgfHwgMCk7XG5cbiAgICAgIGNvbnN0IGlzT25seUFjdGl2ZUluc3RhbmNlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBhY3RpdmVJbnN0YW5jZUlkcyA9IE9iamVjdC5rZXlzKHRoaXMuX2Nvbm5lY3RlZEhvc3RzKS5maWx0ZXIoaW5zdGFuY2UgPT4gXG4gICAgICAgICAgaW5zdGFuY2Uuc3RhcnRzV2l0aChkYXRhLmFjY291bnRJZCArICc6JyArIGluc3RhbmNlTnVtYmVyKSk7XG4gICAgICAgIHJldHVybiAhYWN0aXZlSW5zdGFuY2VJZHMubGVuZ3RoIHx8IGFjdGl2ZUluc3RhbmNlSWRzLmxlbmd0aCA9PT0gMSAmJiBhY3RpdmVJbnN0YW5jZUlkc1swXSA9PT0gaW5zdGFuY2VJZDtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGNhbmNlbERpc2Nvbm5lY3RUaW1lciA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXR1c1RpbWVyc1tpbnN0YW5jZUlkXSkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zdGF0dXNUaW1lcnNbaW5zdGFuY2VJZF0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXNldERpc2Nvbm5lY3RUaW1lciA9ICgpID0+IHtcbiAgICAgICAgY2FuY2VsRGlzY29ubmVjdFRpbWVyKCk7XG4gICAgICAgIHRoaXMuX3N0YXR1c1RpbWVyc1tpbnN0YW5jZUlkXSA9IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGlmKGlzT25seUFjdGl2ZUluc3RhbmNlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIub25UaW1lb3V0KGRhdGEuYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucXVldWVFdmVudChkYXRhLmFjY291bnRJZCwgKCkgPT4gUHJvbWlzZS5yZXNvbHZlKG9uRGlzY29ubmVjdGVkKHRydWUpKSk7XG4gICAgICAgIH0sIDYwMDAwKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG9uRGlzY29ubmVjdGVkID0gYXN5bmMgKGlzVGltZW91dCA9IGZhbHNlKSA9PiB7IFxuICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkSG9zdHNbaW5zdGFuY2VJZF0pIHtcbiAgICAgICAgICBpZihpc09ubHlBY3RpdmVJbnN0YW5jZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBvbkRpc2Nvbm5lY3RlZFByb21pc2VzID0gW107XG4gICAgICAgICAgICBpZighaXNUaW1lb3V0KSB7XG4gICAgICAgICAgICAgIG9uRGlzY29ubmVjdGVkUHJvbWlzZXMucHVzaCh0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyLm9uRGlzY29ubmVjdGVkKGRhdGEuYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW2RhdGEuYWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgICBvbkRpc2Nvbm5lY3RlZFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uRGlzY29ubmVjdGVkKGluc3RhbmNlSW5kZXgpKVxuICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5lcnJvcihgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICtcbiAgICAgICAgICAgICAgICAgICAgJ2Fib3V0IGRpc2Nvbm5lY3RlZCBldmVudCcsIGVycikpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvbkRpc2Nvbm5lY3RlZFByb21pc2VzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgb25TdHJlYW1DbG9zZWRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fcGFja2V0T3JkZXJlci5vblN0cmVhbUNsb3NlZChpbnN0YW5jZUlkKTtcbiAgICAgICAgICAgIHNvY2tldEluc3RhbmNlLnN5bmNocm9uaXphdGlvblRocm90dGxlci5yZW1vdmVJZEJ5UGFyYW1ldGVycyhkYXRhLmFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsIGRhdGEuaG9zdCk7XG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICAgIG9uU3RyZWFtQ2xvc2VkUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobGlzdGVuZXIub25TdHJlYW1DbG9zZWQoaW5zdGFuY2VJbmRleCkpXG4gICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGAgK1xuICAgICAgICAgICAgICAgICAgICAnYWJvdXQgc3RyZWFtIGNsb3NlZCBldmVudCcsIGVycikpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvblN0cmVhbUNsb3NlZFByb21pc2VzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2Nvbm5lY3RlZEhvc3RzW2luc3RhbmNlSWRdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ2F1dGhlbnRpY2F0ZWQnKSB7XG4gICAgICAgIHJlc2V0RGlzY29ubmVjdFRpbWVyKCk7XG4gICAgICAgIGlmKCghZGF0YS5zZXNzaW9uSWQpIHx8IChkYXRhLnNlc3Npb25JZCA9PT0gc29ja2V0SW5zdGFuY2Uuc2Vzc2lvbklkKSkge1xuICAgICAgICAgIHRoaXMuX2Nvbm5lY3RlZEhvc3RzW2luc3RhbmNlSWRdID0gZGF0YS5ob3N0O1xuICAgICAgICAgIGNvbnN0IG9uQ29ubmVjdGVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBvbkNvbm5lY3RlZFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5vbkNvbm5lY3RlZChpbnN0YW5jZUluZGV4LCBkYXRhLnJlcGxpY2FzKSlcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5lcnJvcihgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICsgXG4gICAgICAgICAgICAgICAgICAnYWJvdXQgY29ubmVjdGVkIGV2ZW50JywgZXJyKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIuY2FuY2VsU3Vic2NyaWJlKGRhdGEuYWNjb3VudElkICsgJzonICsgaW5zdGFuY2VOdW1iZXIpO1xuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9uQ29ubmVjdGVkUHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgY2FuY2VsRGlzY29ubmVjdFRpbWVyKCk7XG4gICAgICAgIGF3YWl0IG9uRGlzY29ubmVjdGVkKCk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ3N5bmNocm9uaXphdGlvblN0YXJ0ZWQnKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1tkYXRhLmFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uU3luY2hyb25pemF0aW9uU3RhcnRlZChpbnN0YW5jZUluZGV4KSlcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGAgK1xuICAgICAgICAgICAgICAgICdhYm91dCBzeW5jaHJvbml6YXRpb24gc3RhcnRlZCBldmVudCcsIGVycikpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ2FjY291bnRJbmZvcm1hdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEuYWNjb3VudEluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgY29uc3Qgb25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBvbkFjY291bnRJbmZvcm1hdGlvblVwZGF0ZWRQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobGlzdGVuZXIub25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkKGluc3RhbmNlSW5kZXgsIGRhdGEuYWNjb3VudEluZm9ybWF0aW9uKSlcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5lcnJvcihgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICtcbiAgICAgICAgICAgICAgICAgICdhYm91dCBhY2NvdW50SW5mb3JtYXRpb24gZXZlbnQnLCBlcnIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkUHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ2RlYWxzJykge1xuICAgICAgICBmb3IgKGxldCBkZWFsIG9mIChkYXRhLmRlYWxzIHx8IFtdKSkge1xuICAgICAgICAgIGNvbnN0IG9uRGVhbEFkZGVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBvbkRlYWxBZGRlZFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5vbkRlYWxBZGRlZChpbnN0YW5jZUluZGV4LCBkZWFsKSlcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5lcnJvcihgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICtcbiAgICAgICAgICAgICAgICAgICdhYm91dCBkZWFscyBldmVudCcsIGVycikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvbkRlYWxBZGRlZFByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdvcmRlcnMnKSB7XG4gICAgICAgIGNvbnN0IG9uT3JkZXJVcGRhdGVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW2RhdGEuYWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgIG9uT3JkZXJVcGRhdGVkUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5vbk9yZGVyc1JlcGxhY2VkKGluc3RhbmNlSW5kZXgsIGRhdGEub3JkZXJzIHx8IFtdKSlcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGAgK1xuICAgICAgICAgICAgICAgICdhYm91dCBvcmRlcnMgZXZlbnQnLCBlcnIpKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25PcmRlclVwZGF0ZWRQcm9taXNlcyk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ2hpc3RvcnlPcmRlcnMnKSB7XG4gICAgICAgIGZvciAobGV0IGhpc3RvcnlPcmRlciBvZiAoZGF0YS5oaXN0b3J5T3JkZXJzIHx8IFtdKSkge1xuICAgICAgICAgIGNvbnN0IG9uSGlzdG9yeU9yZGVyQWRkZWRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1tkYXRhLmFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIG9uSGlzdG9yeU9yZGVyQWRkZWRQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobGlzdGVuZXIub25IaXN0b3J5T3JkZXJBZGRlZChpbnN0YW5jZUluZGV4LCBoaXN0b3J5T3JkZXIpKVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGAgK1xuICAgICAgICAgICAgICAgICAgJ2Fib3V0IGhpc3RvcnlPcmRlcnMgZXZlbnQnLCBlcnIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25IaXN0b3J5T3JkZXJBZGRlZFByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdwb3NpdGlvbnMnKSB7XG4gICAgICAgIGNvbnN0IG9uUG9zaXRpb25VcGRhdGVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW2RhdGEuYWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgIG9uUG9zaXRpb25VcGRhdGVkUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5vblBvc2l0aW9uc1JlcGxhY2VkKGluc3RhbmNlSW5kZXgsIGRhdGEucG9zaXRpb25zIHx8IFtdKSlcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGAgK1xuICAgICAgICAgICAgICAgICdhYm91dCBwb3NpdGlvbnMgZXZlbnQnLCBlcnIpKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25Qb3NpdGlvblVwZGF0ZWRQcm9taXNlcyk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ3VwZGF0ZScpIHtcbiAgICAgICAgaWYgKGRhdGEuYWNjb3VudEluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgY29uc3Qgb25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBvbkFjY291bnRJbmZvcm1hdGlvblVwZGF0ZWRQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobGlzdGVuZXIub25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkKGluc3RhbmNlSW5kZXgsIGRhdGEuYWNjb3VudEluZm9ybWF0aW9uKSlcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5lcnJvcihgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICtcbiAgICAgICAgICAgICAgICAgICdhYm91dCB1cGRhdGUgZXZlbnQnLCBlcnIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkUHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHBvc2l0aW9uIG9mIChkYXRhLnVwZGF0ZWRQb3NpdGlvbnMgfHwgW10pKSB7XG4gICAgICAgICAgY29uc3Qgb25Qb3NpdGlvblVwZGF0ZWRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1tkYXRhLmFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIG9uUG9zaXRpb25VcGRhdGVkUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uUG9zaXRpb25VcGRhdGVkKGluc3RhbmNlSW5kZXgsIHBvc2l0aW9uKSlcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5lcnJvcihgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICtcbiAgICAgICAgICAgICAgICAgICdhYm91dCB1cGRhdGUgZXZlbnQnLCBlcnIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25Qb3NpdGlvblVwZGF0ZWRQcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcG9zaXRpb25JZCBvZiAoZGF0YS5yZW1vdmVkUG9zaXRpb25JZHMgfHwgW10pKSB7XG4gICAgICAgICAgY29uc3Qgb25Qb3NpdGlvblJlbW92ZWRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1tkYXRhLmFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIG9uUG9zaXRpb25SZW1vdmVkUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uUG9zaXRpb25SZW1vdmVkKGluc3RhbmNlSW5kZXgsIHBvc2l0aW9uSWQpKVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGAgK1xuICAgICAgICAgICAgICAgICAgJ2Fib3V0IHVwZGF0ZSBldmVudCcsIGVycikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvblBvc2l0aW9uUmVtb3ZlZFByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBvcmRlciBvZiAoZGF0YS51cGRhdGVkT3JkZXJzIHx8IFtdKSkge1xuICAgICAgICAgIGNvbnN0IG9uT3JkZXJVcGRhdGVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBvbk9yZGVyVXBkYXRlZFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5vbk9yZGVyVXBkYXRlZChpbnN0YW5jZUluZGV4LCBvcmRlcikpXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoYCR7ZGF0YS5hY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06IEZhaWxlZCB0byBub3RpZnkgbGlzdGVuZXIgYCArXG4gICAgICAgICAgICAgICAgICAnYWJvdXQgdXBkYXRlIGV2ZW50JywgZXJyKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9uT3JkZXJVcGRhdGVkUHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG9yZGVySWQgb2YgKGRhdGEuY29tcGxldGVkT3JkZXJJZHMgfHwgW10pKSB7XG4gICAgICAgICAgY29uc3Qgb25PcmRlckNvbXBsZXRlZFByb21pc2VzID0gW107XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW2RhdGEuYWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgb25PcmRlckNvbXBsZXRlZFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5vbk9yZGVyQ29tcGxldGVkKGluc3RhbmNlSW5kZXgsIG9yZGVySWQpKVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGAgK1xuICAgICAgICAgICAgICAgICAgJ2Fib3V0IHVwZGF0ZSBldmVudCcsIGVycikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvbk9yZGVyQ29tcGxldGVkUHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGhpc3RvcnlPcmRlciBvZiAoZGF0YS5oaXN0b3J5T3JkZXJzIHx8IFtdKSkge1xuICAgICAgICAgIGNvbnN0IG9uSGlzdG9yeU9yZGVyQWRkZWRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1tkYXRhLmFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIG9uSGlzdG9yeU9yZGVyQWRkZWRQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobGlzdGVuZXIub25IaXN0b3J5T3JkZXJBZGRlZChpbnN0YW5jZUluZGV4LCBoaXN0b3J5T3JkZXIpKVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGAgK1xuICAgICAgICAgICAgICAgICAgJ2Fib3V0IHVwZGF0ZSBldmVudCcsIGVycikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvbkhpc3RvcnlPcmRlckFkZGVkUHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGRlYWwgb2YgKGRhdGEuZGVhbHMgfHwgW10pKSB7XG4gICAgICAgICAgY29uc3Qgb25EZWFsQWRkZWRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1tkYXRhLmFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIG9uRGVhbEFkZGVkUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uRGVhbEFkZGVkKGluc3RhbmNlSW5kZXgsIGRlYWwpKVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGAgK1xuICAgICAgICAgICAgICAgICAgJ2Fib3V0IHVwZGF0ZSBldmVudCcsIGVycikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvbkRlYWxBZGRlZFByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS50aW1lc3RhbXBzKSB7XG4gICAgICAgICAgZGF0YS50aW1lc3RhbXBzLmNsaWVudFByb2Nlc3NpbmdGaW5pc2hlZCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgY29uc3Qgb25VcGRhdGVQcm9taXNlcyA9IFtdO1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9sYXRlbmN5TGlzdGVuZXJzIHx8IFtdKSB7XG4gICAgICAgICAgICBvblVwZGF0ZVByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5vblVwZGF0ZShkYXRhLmFjY291bnRJZCwgZGF0YS50aW1lc3RhbXBzKSlcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5lcnJvcihgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsYXRlbmN5IGAgK1xuICAgICAgICAgICAgICAgICAgJ2xpc3RlbmVyIGFib3V0IHVwZGF0ZSBldmVudCcsIGVycikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvblVwZGF0ZVByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdkZWFsU3luY2hyb25pemF0aW9uRmluaXNoZWQnKSB7XG4gICAgICAgIGNvbnN0IG9uRGVhbFN5bmNocm9uaXphdGlvbkZpbmlzaGVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW2RhdGEuYWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgIGlmKHNvY2tldEluc3RhbmNlKSB7XG4gICAgICAgICAgICBzb2NrZXRJbnN0YW5jZS5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIucmVtb3ZlU3luY2hyb25pemF0aW9uSWQoZGF0YS5zeW5jaHJvbml6YXRpb25JZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9uRGVhbFN5bmNocm9uaXphdGlvbkZpbmlzaGVkUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5vbkRlYWxTeW5jaHJvbml6YXRpb25GaW5pc2hlZChpbnN0YW5jZUluZGV4LCBkYXRhLnN5bmNocm9uaXphdGlvbklkKSlcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGFib3V0IGAgK1xuICAgICAgICAgICAgICAgICAgJ2RlYWxTeW5jaHJvbml6YXRpb25GaW5pc2hlZCBldmVudCcsIGVycikpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvbkRlYWxTeW5jaHJvbml6YXRpb25GaW5pc2hlZFByb21pc2VzKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnb3JkZXJTeW5jaHJvbml6YXRpb25GaW5pc2hlZCcpIHtcbiAgICAgICAgY29uc3Qgb25PcmRlclN5bmNocm9uaXphdGlvbkZpbmlzaGVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW2RhdGEuYWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgIG9uT3JkZXJTeW5jaHJvbml6YXRpb25GaW5pc2hlZFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobGlzdGVuZXIub25PcmRlclN5bmNocm9uaXphdGlvbkZpbmlzaGVkKGluc3RhbmNlSW5kZXgsIGRhdGEuc3luY2hyb25pemF0aW9uSWQpKVxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoYCR7ZGF0YS5hY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06IEZhaWxlZCB0byBub3RpZnkgbGlzdGVuZXIgYWJvdXQgYCArXG4gICAgICAgICAgICAgICAgICAnb3JkZXJTeW5jaHJvbml6YXRpb25GaW5pc2hlZCBldmVudCcsIGVycikpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvbk9yZGVyU3luY2hyb25pemF0aW9uRmluaXNoZWRQcm9taXNlcyk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ3N0YXR1cycpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb25uZWN0ZWRIb3N0c1tpbnN0YW5jZUlkXSkge1xuICAgICAgICAgIGlmKHRoaXMuX3N0YXR1c1RpbWVyc1tpbnN0YW5jZUlkXSAmJiBkYXRhLmF1dGhlbnRpY2F0ZWQgJiYgXG4gICAgICAgICAgICAgICh0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyLmlzRGlzY29ubmVjdGVkUmV0cnlNb2RlKGRhdGEuYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcikgfHwgXG4gICAgICAgICAgICAgICF0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyLmlzQWNjb3VudFN1YnNjcmliaW5nKGRhdGEuYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcikpKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyLmNhbmNlbFN1YnNjcmliZShkYXRhLmFjY291bnRJZCArICc6JyArIGluc3RhbmNlTnVtYmVyKTtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgMTApKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnWycgKyAobmV3IERhdGUoKSkudG9JU09TdHJpbmcoKSArICddIGl0IHNlZW1zIGxpa2Ugd2UgYXJlIG5vdCBjb25uZWN0ZWQgdG8gYSBydW5uaW5nIEFQSSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdzZXJ2ZXIgeWV0LCByZXRyeWluZyBzdWJzY3JpcHRpb24gZm9yIGFjY291bnQgJyArIGluc3RhbmNlSWQpO1xuICAgICAgICAgICAgdGhpcy5lbnN1cmVTdWJzY3JpYmUoZGF0YS5hY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzZXREaXNjb25uZWN0VGltZXIoKTtcbiAgICAgICAgICBjb25zdCBvbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBvbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uQnJva2VyQ29ubmVjdGlvblN0YXR1c0NoYW5nZWQoaW5zdGFuY2VJbmRleCwgISFkYXRhLmNvbm5lY3RlZCkpXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoYCR7ZGF0YS5hY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06IEZhaWxlZCB0byBub3RpZnkgbGlzdGVuZXIgYWJvdXQgYCArXG4gICAgICAgICAgICAgICAgICAgICdicm9rZXJDb25uZWN0aW9uU3RhdHVzQ2hhbmdlZCBldmVudCcsIGVycikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkUHJvbWlzZXMpO1xuICAgICAgICAgIGlmIChkYXRhLmhlYWx0aFN0YXR1cykge1xuICAgICAgICAgICAgY29uc3Qgb25IZWFsdGhTdGF0dXNQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuICAgICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW2RhdGEuYWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgICBvbkhlYWx0aFN0YXR1c1Byb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uSGVhbHRoU3RhdHVzKGluc3RhbmNlSW5kZXgsIGRhdGEuaGVhbHRoU3RhdHVzKSlcbiAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoYCR7ZGF0YS5hY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06IEZhaWxlZCB0byBub3RpZnkgbGlzdGVuZXIgYWJvdXQgYCArXG4gICAgICAgICAgICAgICAgICAgICAgJ3NlcnZlci1zaWRlIGhlYWx0aFN0YXR1cyBldmVudCcsIGVycikpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvbkhlYWx0aFN0YXR1c1Byb21pc2VzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnZG93bmdyYWRlU3Vic2NyaXB0aW9uJykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmxvZyhgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogTWFya2V0IGRhdGEgc3Vic2NyaXB0aW9ucyBmb3Igc3ltYm9sICR7ZGF0YS5zeW1ib2x9IHdlcmUgYCArXG4gICAgICAgICAgICBgZG93bmdyYWRlZCBieSB0aGUgc2VydmVyIGR1ZSB0byByYXRlIGxpbWl0cy4gVXBkYXRlZCBzdWJzY3JpcHRpb25zOiAke0pTT04uc3RyaW5naWZ5KGRhdGEudXBkYXRlcyl9LCBgICtcbiAgICAgICAgICAgIGByZW1vdmVkIHN1YnNjcmlwdGlvbnM6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YS51bnN1YnNjcmlwdGlvbnMpfS4gUGxlYXNlIHJlYWQgYCArXG4gICAgICAgICAgICAnaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3JhdGVMaW1pdGluZy8gZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgICAgICAgY29uc3Qgb25TdWJzY3JpcHRpb25Eb3duZ3JhZGVQcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgb25TdWJzY3JpcHRpb25Eb3duZ3JhZGVQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uU3Vic2NyaXB0aW9uRG93bmdyYWRlZChpbnN0YW5jZUluZGV4LCBkYXRhLnN5bWJvbCwgZGF0YS51cGRhdGVzLFxuICAgICAgICAgICAgICBkYXRhLnVuc3Vic2NyaXB0aW9ucykpXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5lcnJvcihgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICtcbiAgICAgICAgICAgICAgICAnYWJvdXQgc3Vic2NyaXB0aW9uIGRvd25ncmFkZSBldmVudCcsIGVycikpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvblN1YnNjcmlwdGlvbkRvd25ncmFkZVByb21pc2VzKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnc3BlY2lmaWNhdGlvbnMnKSB7XG4gICAgICAgIGNvbnN0IG9uU3ltYm9sU3BlY2lmaWNhdGlvbnNVcGRhdGVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW2RhdGEuYWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgIG9uU3ltYm9sU3BlY2lmaWNhdGlvbnNVcGRhdGVkUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5vblN5bWJvbFNwZWNpZmljYXRpb25zVXBkYXRlZChpbnN0YW5jZUluZGV4LCBkYXRhLnNwZWNpZmljYXRpb25zIHx8IFtdLFxuICAgICAgICAgICAgICBkYXRhLnJlbW92ZWRTeW1ib2xzIHx8IFtdKSlcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5lcnJvcihgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICtcbiAgICAgICAgICAgICAgICAnYWJvdXQgc3BlY2lmaWNhdGlvbnMgdXBkYXRlZCBldmVudCcsIGVycikpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvblN5bWJvbFNwZWNpZmljYXRpb25zVXBkYXRlZFByb21pc2VzKTtcbiAgICAgICAgZm9yIChsZXQgc3BlY2lmaWNhdGlvbiBvZiAoZGF0YS5zcGVjaWZpY2F0aW9ucyB8fCBbXSkpIHtcbiAgICAgICAgICBjb25zdCBvblN5bWJvbFNwZWNpZmljYXRpb25VcGRhdGVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBvblN5bWJvbFNwZWNpZmljYXRpb25VcGRhdGVkUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uU3ltYm9sU3BlY2lmaWNhdGlvblVwZGF0ZWQoaW5zdGFuY2VJbmRleCwgc3BlY2lmaWNhdGlvbikpXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoYCR7ZGF0YS5hY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06IEZhaWxlZCB0byBub3RpZnkgbGlzdGVuZXIgYCArXG4gICAgICAgICAgICAgICAgICAnYWJvdXQgc3BlY2lmaWNhdGlvbiB1cGRhdGVkIGV2ZW50JywgZXJyKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9uU3ltYm9sU3BlY2lmaWNhdGlvblVwZGF0ZWRQcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcmVtb3ZlZFN5bWJvbCBvZiAoZGF0YS5yZW1vdmVkU3ltYm9scyB8fCBbXSkpIHtcbiAgICAgICAgICBjb25zdCBvblN5bWJvbFNwZWNpZmljYXRpb25SZW1vdmVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBvblN5bWJvbFNwZWNpZmljYXRpb25SZW1vdmVkUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uU3ltYm9sU3BlY2lmaWNhdGlvblJlbW92ZWQoaW5zdGFuY2VJbmRleCwgcmVtb3ZlZFN5bWJvbCkpXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoYCR7ZGF0YS5hY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06IEZhaWxlZCB0byBub3RpZnkgbGlzdGVuZXIgYCArXG4gICAgICAgICAgICAgICAgICAnYWJvdXQgc3BlY2lmaWNhdGlvbnMgcmVtb3ZlZCBldmVudCcsIGVycikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvblN5bWJvbFNwZWNpZmljYXRpb25SZW1vdmVkUHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ3ByaWNlcycpIHtcbiAgICAgICAgbGV0IHByaWNlcyA9IGRhdGEucHJpY2VzIHx8IFtdO1xuICAgICAgICBsZXQgY2FuZGxlcyA9IGRhdGEuY2FuZGxlcyB8fCBbXTtcbiAgICAgICAgbGV0IHRpY2tzID0gZGF0YS50aWNrcyB8fCBbXTtcbiAgICAgICAgbGV0IGJvb2tzID0gZGF0YS5ib29rcyB8fCBbXTtcbiAgICAgICAgY29uc3Qgb25TeW1ib2xQcmljZXNVcGRhdGVkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW2RhdGEuYWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgIGlmIChwcmljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvblN5bWJvbFByaWNlc1VwZGF0ZWRQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobGlzdGVuZXIub25TeW1ib2xQcmljZXNVcGRhdGVkKGluc3RhbmNlSW5kZXgsIHByaWNlcywgZGF0YS5lcXVpdHksIGRhdGEubWFyZ2luLFxuICAgICAgICAgICAgICAgIGRhdGEuZnJlZU1hcmdpbiwgZGF0YS5tYXJnaW5MZXZlbCwgZGF0YS5hY2NvdW50Q3VycmVuY3lFeGNoYW5nZVJhdGUpKVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGAgK1xuICAgICAgICAgICAgICAgICAgJ2Fib3V0IHByaWNlcyBldmVudCcsIGVycikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FuZGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9uU3ltYm9sUHJpY2VzVXBkYXRlZFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5vbkNhbmRsZXNVcGRhdGVkKGluc3RhbmNlSW5kZXgsIGNhbmRsZXMsIGRhdGEuZXF1aXR5LCBkYXRhLm1hcmdpbixcbiAgICAgICAgICAgICAgICBkYXRhLmZyZWVNYXJnaW4sIGRhdGEubWFyZ2luTGV2ZWwsIGRhdGEuYWNjb3VudEN1cnJlbmN5RXhjaGFuZ2VSYXRlKSlcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5lcnJvcihgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICtcbiAgICAgICAgICAgICAgICAgICdhYm91dCBjYW5kbGVzIGV2ZW50JywgZXJyKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9uU3ltYm9sUHJpY2VzVXBkYXRlZFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5vblRpY2tzVXBkYXRlZChpbnN0YW5jZUluZGV4LCB0aWNrcywgZGF0YS5lcXVpdHksIGRhdGEubWFyZ2luLFxuICAgICAgICAgICAgICAgIGRhdGEuZnJlZU1hcmdpbiwgZGF0YS5tYXJnaW5MZXZlbCwgZGF0YS5hY2NvdW50Q3VycmVuY3lFeGNoYW5nZVJhdGUpKVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGAgK1xuICAgICAgICAgICAgICAgICAgJ2Fib3V0IHRpY2tzIGV2ZW50JywgZXJyKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChib29rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9uU3ltYm9sUHJpY2VzVXBkYXRlZFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5vbkJvb2tzVXBkYXRlZChpbnN0YW5jZUluZGV4LCBib29rcywgZGF0YS5lcXVpdHksIGRhdGEubWFyZ2luLFxuICAgICAgICAgICAgICAgIGRhdGEuZnJlZU1hcmdpbiwgZGF0YS5tYXJnaW5MZXZlbCwgZGF0YS5hY2NvdW50Q3VycmVuY3lFeGNoYW5nZVJhdGUpKVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGAgK1xuICAgICAgICAgICAgICAgICAgJ2Fib3V0IGJvb2tzIGV2ZW50JywgZXJyKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9uU3ltYm9sUHJpY2VzVXBkYXRlZFByb21pc2VzKTtcbiAgICAgICAgZm9yIChsZXQgcHJpY2Ugb2YgcHJpY2VzKSB7XG4gICAgICAgICAgY29uc3Qgb25TeW1ib2xQcmljZVVwZGF0ZWRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1tkYXRhLmFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIG9uU3ltYm9sUHJpY2VVcGRhdGVkUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLm9uU3ltYm9sUHJpY2VVcGRhdGVkKGluc3RhbmNlSW5kZXgsIHByaWNlKSlcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5lcnJvcihgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICtcbiAgICAgICAgICAgICAgICAgICdhYm91dCBwcmljZSBldmVudCcsIGVycikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvblN5bWJvbFByaWNlVXBkYXRlZFByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwcmljZSBvZiBwcmljZXMpIHtcbiAgICAgICAgICBpZiAocHJpY2UudGltZXN0YW1wcykge1xuICAgICAgICAgICAgcHJpY2UudGltZXN0YW1wcy5jbGllbnRQcm9jZXNzaW5nRmluaXNoZWQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgY29uc3Qgb25TeW1ib2xQcmljZVByb21pc2VzID0gW107XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9sYXRlbmN5TGlzdGVuZXJzIHx8IFtdKSB7XG4gICAgICAgICAgICAgIG9uU3ltYm9sUHJpY2VQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5vblN5bWJvbFByaWNlKGRhdGEuYWNjb3VudElkLCBwcmljZS5zeW1ib2wsIHByaWNlLnRpbWVzdGFtcHMpKVxuICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5lcnJvcihgJHtkYXRhLmFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsYXRlbmN5IGAgK1xuICAgICAgICAgICAgICAgICAgICAnbGlzdGVuZXIgYWJvdXQgcHJpY2UgZXZlbnQnLCBlcnIpKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob25TeW1ib2xQcmljZVByb21pc2VzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcHJvY2VzcyBpbmNvbWluZyBzeW5jaHJvbml6YXRpb24gcGFja2V0JywgZXJyKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBfZmlyZVJlY29ubmVjdGVkKHNvY2tldEluc3RhbmNlSW5kZXgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVjb25uZWN0TGlzdGVuZXJzID0gW107XG4gICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9yZWNvbm5lY3RMaXN0ZW5lcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbbGlzdGVuZXIuYWNjb3VudElkXSA9PT0gc29ja2V0SW5zdGFuY2VJbmRleCkge1xuICAgICAgICAgIHJlY29ubmVjdExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcmVjb25uZWN0QWNjb3VudElkcyA9IHJlY29ubmVjdExpc3RlbmVycy5tYXAobGlzdGVuZXIgPT4gbGlzdGVuZXIuYWNjb3VudElkKTtcbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIub25SZWNvbm5lY3RlZChzb2NrZXRJbnN0YW5jZUluZGV4LCByZWNvbm5lY3RBY2NvdW50SWRzKTtcbiAgICAgIHRoaXMuX3BhY2tldE9yZGVyZXIub25SZWNvbm5lY3RlZChyZWNvbm5lY3RBY2NvdW50SWRzKTtcblxuICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgcmVjb25uZWN0TGlzdGVuZXJzKSB7XG4gICAgICAgIHRoaXMucXVldWVFdmVudChsaXN0ZW5lci5hY2NvdW50SWQsICgpID0+IFByb21pc2UucmVzb2x2ZShsaXN0ZW5lci5saXN0ZW5lci5vblJlY29ubmVjdGVkKCkpXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAuY2F0Y2goZXJyID0+IFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignWycgKyAobmV3IERhdGUoKSkudG9JU09TdHJpbmcoKSArICddIEZhaWxlZCB0byBub3RpZnkgcmVjb25uZWN0IGxpc3RlbmVyJywgZXJyKSkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1snICsgKG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCkgKyAnXSBGYWlsZWQgdG8gcHJvY2VzcyByZWNvbm5lY3RlZCBldmVudCcsIGVycik7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX2dldFNlcnZlclVybCgpIHtcbiAgICBpZih0aGlzLl91c2VTaGFyZWRDbGllbnRBcGkpIHtcbiAgICAgIHJldHVybiB0aGlzLl91cmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIHVybDogYGh0dHBzOi8vbXQtcHJvdmlzaW9uaW5nLWFwaS12MS4ke3RoaXMuX2RvbWFpbn0vdXNlcnMvY3VycmVudC9zZXJ2ZXJzL210LWNsaWVudC1hcGlgLFxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ2F1dGgtdG9rZW4nOiB0aGlzLl90b2tlblxuICAgICAgICB9LFxuICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5faHR0cENsaWVudC5yZXF1ZXN0KG9wdHMpO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLnVybDtcbiAgICB9XG4gIH1cblxufVxuIl19
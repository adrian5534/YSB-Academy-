'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _synchronizationListener = require('../clients/metaApi/synchronizationListener');

var _synchronizationListener2 = _interopRequireDefault(_synchronizationListener);

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _reservoir = require('./reservoir/reservoir');

var _reservoir2 = _interopRequireDefault(_reservoir);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Tracks connection health status
 */
class ConnectionHealthMonitor extends _synchronizationListener2.default {

  /**
   * Constructs the listener
   * @param {MetaApiConnection} connection MetaApi connection instance
   */
  constructor(connection) {
    super();
    this._connection = connection;
    const updateQuoteHealthStatusInterval = () => {
      this._updateQuoteHealthStatus();
      this._updateQuoteHealthStatusInterval = setTimeout(updateQuoteHealthStatusInterval.bind(this), this._getRandomTimeout());
    };
    this._updateQuoteHealthStatusInterval = setTimeout(updateQuoteHealthStatusInterval.bind(this), this._getRandomTimeout());
    const measureUptimeInterval = () => {
      this._measureUptime();
      this._measureUptimeInterval = setTimeout(measureUptimeInterval.bind(this), this._getRandomTimeout());
    };
    this._measureUptimeInterval = setTimeout(measureUptimeInterval.bind(this), this._getRandomTimeout());
    this._minQuoteInterval = 60000;
    this._serverHealthStatus = {};
    this._uptimeReservoirs = {
      '5m': new _reservoir2.default(300, 5 * 60 * 1000),
      '1h': new _reservoir2.default(600, 60 * 60 * 1000),
      '1d': new _reservoir2.default(24 * 60, 24 * 60 * 60 * 1000),
      '1w': new _reservoir2.default(24 * 7, 7 * 24 * 60 * 60 * 1000)
    };
  }

  /**
   * Stops health monitor
   */
  stop() {
    clearTimeout(this._updateQuoteHealthStatusInterval);
    clearTimeout(this._measureUptimeInterval);
  }

  /**
   * Invoked when a symbol price was updated
   * @param {String} instanceIndex index of an account instance connected
   * @param {MetatraderSymbolPrice} price updated MetaTrader symbol price
   */
  onSymbolPriceUpdated(instanceIndex, price) {
    try {
      let brokerTimestamp = (0, _moment2.default)(price.brokerTime).toDate().getTime();
      this._priceUpdatedAt = new Date();
      this._offset = this._priceUpdatedAt.getTime() - brokerTimestamp;
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error('[' + new Date().toISOString() + '] failed to update quote streaming health status on price ' + 'update for account ' + this._connection.account.id, err);
    }
  }

  /**
   * Invoked when a server-side application health status is received from MetaApi
   * @param {String} instanceIndex index of an account instance connected
   * @param {HealthStatus} status server-side application health status
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  onHealthStatus(instanceIndex, status) {
    this._serverHealthStatus['' + instanceIndex] = status;
  }

  /**
   * Invoked when connection to MetaTrader terminal terminated
   * @param {String} instanceIndex index of an account instance connected
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  onDisconnected(instanceIndex) {
    delete this._serverHealthStatus['' + instanceIndex];
  }

  /**
   * Returns server-side application health status
   * @return {HealthStatus} server-side application health status
   */
  get serverHealthStatus() {
    let result;
    for (let s of (0, _values2.default)(this._serverHealthStatus)) {
      if (!result) {
        result = s;
      } else {
        for (let field of (0, _keys2.default)(s)) {
          result[field] = result[field] || s[field];
        }
      }
    }
    return result || {};
  }

  /**
   * Connection health status
   * @typedef {Object} ConnectionHealthStatus
   * @property {Boolean} connected flag indicating successful connection to API server
   * @property {Boolean} connectedToBroker flag indicating successful connection to broker
   * @property {Boolean} quoteStreamingHealthy flag indicating that quotes are being streamed successfully from the
   * broker
   * @property {Boolean} synchronized flag indicating a successful synchronization
   * @property {Boolean} healthy flag indicating overall connection health status
   * @property {String} message health status message
   */

  /**
   * Returns health status
   * @returns {ConnectionHealthStatus} connection health status
   */
  // eslint-disable-next-line complexity
  get healthStatus() {
    let status = {
      connected: this._connection.terminalState.connected,
      connectedToBroker: this._connection.terminalState.connectedToBroker,
      quoteStreamingHealthy: this._quotesHealthy,
      synchronized: this._connection.synchronized
    };
    status.healthy = status.connected && status.connectedToBroker && status.quoteStreamingHealthy && status.synchronized;
    let message;
    if (status.healthy) {
      message = 'Connection to broker is stable. No health issues detected.';
    } else {
      message = 'Connection is not healthy because ';
      let reasons = [];
      if (!status.connected) {
        reasons.push('connection to API server is not established or lost');
      }
      if (!status.connectedToBroker) {
        reasons.push('connection to broker is not established or lost');
      }
      if (!status.synchronized) {
        reasons.push('local terminal state is not synchronized to broker');
      }
      if (!status.quoteStreamingHealthy) {
        reasons.push('quotes are not streamed from the broker properly');
      }
      message = message + reasons.join(' and ') + '.';
    }
    status.message = message;
    return status;
  }

  /**
   * Returns uptime in percents measured over specific periods of time
   * @returns {Object} uptime in percents measured over specific periods of time
   */
  get uptime() {
    let uptime = {};
    for (let e of (0, _entries2.default)(this._uptimeReservoirs)) {
      uptime[e[0]] = e[1].getStatistics().average;
    }
    return uptime;
  }

  _measureUptime() {
    try {
      (0, _values2.default)(this._uptimeReservoirs).forEach(r => r.pushMeasurement(this._connection.terminalState.connected && this._connection.terminalState.connectedToBroker && this._connection.synchronized && this._quotesHealthy ? 100 : 0));
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error('[' + new Date().toISOString() + '] failed to measure uptime for account ' + this._connection.account.id, err);
    }
  }

  // eslint-disable-next-line complexity
  _updateQuoteHealthStatus() {
    try {
      let serverDateTime = (0, _moment2.default)(new Date(Date.now() - this._offset));
      let serverTime = serverDateTime.format('HH:mm:ss.SSS');
      let dayOfWeek = serverDateTime.day();
      let daysOfWeek = {
        0: 'SUNDAY',
        1: 'MONDAY',
        2: 'TUESDAY',
        3: 'WEDNESDAY',
        4: 'THURSDAY',
        5: 'FRIDAY',
        6: 'SATURDAY'
      };
      let inQuoteSession = false;
      if (!this._priceUpdatedAt) {
        this._priceUpdatedAt = new Date();
      }
      if (!(this._connection.subscribedSymbols || []).length) {
        this._priceUpdatedAt = new Date();
      }
      for (let symbol of this._connection.subscribedSymbols || []) {
        let specification = this._connection.terminalState.specification(symbol) || {};
        let quoteSessions = (specification.quoteSessions || [])[daysOfWeek[dayOfWeek]] || [];
        for (let session of quoteSessions) {
          if (session.from <= serverTime && session.to >= serverTime) {
            inQuoteSession = true;
          }
        }
      }
      this._quotesHealthy = !this._connection.subscribedSymbols.length || !inQuoteSession || Date.now() - this._priceUpdatedAt.getTime() < this._minQuoteInterval;
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error('[' + new Date().toISOString() + '] failed to update quote streaming health status for account ' + this._connection.account.id, err);
    }
  }

  _getRandomTimeout() {
    return (Math.random() * 59 + 1) * 1000;
  }

}
exports.default = ConnectionHealthMonitor;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9tZXRhQXBpL2Nvbm5lY3Rpb25IZWFsdGhNb25pdG9yLmVzNiJdLCJuYW1lcyI6WyJDb25uZWN0aW9uSGVhbHRoTW9uaXRvciIsIlN5bmNocm9uaXphdGlvbkxpc3RlbmVyIiwiY29uc3RydWN0b3IiLCJjb25uZWN0aW9uIiwiX2Nvbm5lY3Rpb24iLCJ1cGRhdGVRdW90ZUhlYWx0aFN0YXR1c0ludGVydmFsIiwiX3VwZGF0ZVF1b3RlSGVhbHRoU3RhdHVzIiwiX3VwZGF0ZVF1b3RlSGVhbHRoU3RhdHVzSW50ZXJ2YWwiLCJzZXRUaW1lb3V0IiwiYmluZCIsIl9nZXRSYW5kb21UaW1lb3V0IiwibWVhc3VyZVVwdGltZUludGVydmFsIiwiX21lYXN1cmVVcHRpbWUiLCJfbWVhc3VyZVVwdGltZUludGVydmFsIiwiX21pblF1b3RlSW50ZXJ2YWwiLCJfc2VydmVySGVhbHRoU3RhdHVzIiwiX3VwdGltZVJlc2Vydm9pcnMiLCJSZXNlcnZvaXIiLCJzdG9wIiwiY2xlYXJUaW1lb3V0Iiwib25TeW1ib2xQcmljZVVwZGF0ZWQiLCJpbnN0YW5jZUluZGV4IiwicHJpY2UiLCJicm9rZXJUaW1lc3RhbXAiLCJicm9rZXJUaW1lIiwidG9EYXRlIiwiZ2V0VGltZSIsIl9wcmljZVVwZGF0ZWRBdCIsIkRhdGUiLCJfb2Zmc2V0IiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwidG9JU09TdHJpbmciLCJhY2NvdW50IiwiaWQiLCJvbkhlYWx0aFN0YXR1cyIsInN0YXR1cyIsIm9uRGlzY29ubmVjdGVkIiwic2VydmVySGVhbHRoU3RhdHVzIiwicmVzdWx0IiwicyIsImZpZWxkIiwiaGVhbHRoU3RhdHVzIiwiY29ubmVjdGVkIiwidGVybWluYWxTdGF0ZSIsImNvbm5lY3RlZFRvQnJva2VyIiwicXVvdGVTdHJlYW1pbmdIZWFsdGh5IiwiX3F1b3Rlc0hlYWx0aHkiLCJzeW5jaHJvbml6ZWQiLCJoZWFsdGh5IiwibWVzc2FnZSIsInJlYXNvbnMiLCJwdXNoIiwiam9pbiIsInVwdGltZSIsImUiLCJnZXRTdGF0aXN0aWNzIiwiYXZlcmFnZSIsImZvckVhY2giLCJyIiwicHVzaE1lYXN1cmVtZW50Iiwic2VydmVyRGF0ZVRpbWUiLCJub3ciLCJzZXJ2ZXJUaW1lIiwiZm9ybWF0IiwiZGF5T2ZXZWVrIiwiZGF5IiwiZGF5c09mV2VlayIsImluUXVvdGVTZXNzaW9uIiwic3Vic2NyaWJlZFN5bWJvbHMiLCJsZW5ndGgiLCJzeW1ib2wiLCJzcGVjaWZpY2F0aW9uIiwicXVvdGVTZXNzaW9ucyIsInNlc3Npb24iLCJmcm9tIiwidG8iLCJNYXRoIiwicmFuZG9tIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQTs7O0FBR2UsTUFBTUEsdUJBQU4sU0FBc0NDLGlDQUF0QyxDQUE4RDs7QUFFM0U7Ozs7QUFJQUMsY0FBWUMsVUFBWixFQUF3QjtBQUN0QjtBQUNBLFNBQUtDLFdBQUwsR0FBbUJELFVBQW5CO0FBQ0EsVUFBTUUsa0NBQWtDLE1BQU07QUFDNUMsV0FBS0Msd0JBQUw7QUFDQSxXQUFLQyxnQ0FBTCxHQUF3Q0MsV0FBV0gsZ0NBQWdDSSxJQUFoQyxDQUFxQyxJQUFyQyxDQUFYLEVBQ3RDLEtBQUtDLGlCQUFMLEVBRHNDLENBQXhDO0FBRUQsS0FKRDtBQUtBLFNBQUtILGdDQUFMLEdBQXdDQyxXQUFXSCxnQ0FBZ0NJLElBQWhDLENBQXFDLElBQXJDLENBQVgsRUFDdEMsS0FBS0MsaUJBQUwsRUFEc0MsQ0FBeEM7QUFFQSxVQUFNQyx3QkFBd0IsTUFBTTtBQUNsQyxXQUFLQyxjQUFMO0FBQ0EsV0FBS0Msc0JBQUwsR0FBOEJMLFdBQVdHLHNCQUFzQkYsSUFBdEIsQ0FBMkIsSUFBM0IsQ0FBWCxFQUM1QixLQUFLQyxpQkFBTCxFQUQ0QixDQUE5QjtBQUVELEtBSkQ7QUFLQSxTQUFLRyxzQkFBTCxHQUE4QkwsV0FBV0csc0JBQXNCRixJQUF0QixDQUEyQixJQUEzQixDQUFYLEVBQzVCLEtBQUtDLGlC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LFlBQUlFLGdCQUFnQixDQUFDRCxjQUFjQyxhQUFkLElBQStCLEVBQWhDLEVBQW9DTixXQUFXRixTQUFYLENBQXBDLEtBQThELEVBQWxGO0FBQ0EsYUFBSyxJQUFJUyxPQUFULElBQW9CRCxhQUFwQixFQUFtQztBQUNqQyxjQUFJQyxRQUFRQyxJQUFSLElBQWdCWixVQUFoQixJQUE4QlcsUUFBUUUsRUFBUixJQUFjYixVQUFoRCxFQUE0RDtBQUMxREssNkJBQWlCLElBQWpCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsV0FBS3JCLGNBQUwsR0FBc0IsQ0FBQyxLQUFLNUMsV0FBTCxDQUFpQmtFLGlCQUFqQixDQUFtQ0MsTUFBcEMsSUFBOEMsQ0FBQ0YsY0FBL0MsSUFDbkJ6QyxLQUFLbUMsR0FBTCxLQUFhLEtBQUtwQyxlQUFMLENBQXFCRCxPQUFyQixFQUFiLEdBQThDLEtBQUtaLGlCQUR0RDtBQUVELEtBL0JELENBK0JFLE9BQU9nQixHQUFQLEVBQVk7QUFDWjtBQUNBQyxjQUFRQyxLQUFSLENBQWMsTUFBTyxJQUFJSixJQUFKLEVBQUQsQ0FBYUssV0FBYixFQUFOLEdBQW1DLCtEQUFuQyxHQUNaLEtBQUs3QixXQUFMLENBQWlCOEIsT0FBakIsQ0FBeUJDLEVBRDNCLEVBQytCTCxHQUQvQjtBQUVEO0FBQ0Y7O0FBRURwQixzQkFBb0I7QUFDbEIsV0FBTyxDQUFDb0UsS0FBS0MsTUFBTCxLQUFnQixFQUFoQixHQUFzQixDQUF2QixJQUE0QixJQUFuQztBQUNEOztBQW5OMEU7a0JBQXhEL0UsdUIiLCJmaWxlIjoiY29ubmVjdGlvbkhlYWx0aE1vbml0b3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBTeW5jaHJvbml6YXRpb25MaXN0ZW5lciBmcm9tICcuLi9jbGllbnRzL21ldGFBcGkvc3luY2hyb25pemF0aW9uTGlzdGVuZXInO1xuaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IFJlc2Vydm9pciBmcm9tICcuL3Jlc2Vydm9pci9yZXNlcnZvaXInO1xuXG4vKipcbiAqIFRyYWNrcyBjb25uZWN0aW9uIGhlYWx0aCBzdGF0dXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29ubmVjdGlvbkhlYWx0aE1vbml0b3IgZXh0ZW5kcyBTeW5jaHJvbml6YXRpb25MaXN0ZW5lciB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgdGhlIGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7TWV0YUFwaUNvbm5lY3Rpb259IGNvbm5lY3Rpb24gTWV0YUFwaSBjb25uZWN0aW9uIGluc3RhbmNlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICBjb25zdCB1cGRhdGVRdW90ZUhlYWx0aFN0YXR1c0ludGVydmFsID0gKCkgPT4ge1xuICAgICAgdGhpcy5fdXBkYXRlUXVvdGVIZWFsdGhTdGF0dXMoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVF1b3RlSGVhbHRoU3RhdHVzSW50ZXJ2YWwgPSBzZXRUaW1lb3V0KHVwZGF0ZVF1b3RlSGVhbHRoU3RhdHVzSW50ZXJ2YWwuYmluZCh0aGlzKSxcbiAgICAgICAgdGhpcy5fZ2V0UmFuZG9tVGltZW91dCgpKTtcbiAgICB9O1xuICAgIHRoaXMuX3VwZGF0ZVF1b3RlSGVhbHRoU3RhdHVzSW50ZXJ2YWwgPSBzZXRUaW1lb3V0KHVwZGF0ZVF1b3RlSGVhbHRoU3RhdHVzSW50ZXJ2YWwuYmluZCh0aGlzKSxcbiAgICAgIHRoaXMuX2dldFJhbmRvbVRpbWVvdXQoKSk7XG4gICAgY29uc3QgbWVhc3VyZVVwdGltZUludGVydmFsID0gKCkgPT4ge1xuICAgICAgdGhpcy5fbWVhc3VyZVVwdGltZSgpO1xuICAgICAgdGhpcy5fbWVhc3VyZVVwdGltZUludGVydmFsID0gc2V0VGltZW91dChtZWFzdXJlVXB0aW1lSW50ZXJ2YWwuYmluZCh0aGlzKSxcbiAgICAgICAgdGhpcy5fZ2V0UmFuZG9tVGltZW91dCgpKTtcbiAgICB9O1xuICAgIHRoaXMuX21lYXN1cmVVcHRpbWVJbnRlcnZhbCA9IHNldFRpbWVvdXQobWVhc3VyZVVwdGltZUludGVydmFsLmJpbmQodGhpcyksXG4gICAgICB0aGlzLl9nZXRSYW5kb21UaW1lb3V0KCkpO1xuICAgIHRoaXMuX21pblF1b3RlSW50ZXJ2YWwgPSA2MDAwMDtcbiAgICB0aGlzLl9zZXJ2ZXJIZWFsdGhTdGF0dXMgPSB7fTtcbiAgICB0aGlzLl91cHRpbWVSZXNlcnZvaXJzID0ge1xuICAgICAgJzVtJzogbmV3IFJlc2Vydm9pcigzMDAsIDUgKiA2MCAqIDEwMDApLFxuICAgICAgJzFoJzogbmV3IFJlc2Vydm9pcig2MDAsIDYwICogNjAgKiAxMDAwKSxcbiAgICAgICcxZCc6IG5ldyBSZXNlcnZvaXIoMjQgKiA2MCwgMjQgKiA2MCAqIDYwICogMTAwMCksXG4gICAgICAnMXcnOiBuZXcgUmVzZXJ2b2lyKDI0ICogNywgNyAqIDI0ICogNjAgKiA2MCAqIDEwMDApLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgaGVhbHRoIG1vbml0b3JcbiAgICovXG4gIHN0b3AoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3VwZGF0ZVF1b3RlSGVhbHRoU3RhdHVzSW50ZXJ2YWwpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9tZWFzdXJlVXB0aW1lSW50ZXJ2YWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBhIHN5bWJvbCBwcmljZSB3YXMgdXBkYXRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge01ldGF0cmFkZXJTeW1ib2xQcmljZX0gcHJpY2UgdXBkYXRlZCBNZXRhVHJhZGVyIHN5bWJvbCBwcmljZVxuICAgKi9cbiAgb25TeW1ib2xQcmljZVVwZGF0ZWQoaW5zdGFuY2VJbmRleCwgcHJpY2UpIHtcbiAgICB0cnkge1xuICAgICAgbGV0IGJyb2tlclRpbWVzdGFtcCA9IG1vbWVudChwcmljZS5icm9rZXJUaW1lKS50b0RhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB0aGlzLl9wcmljZVVwZGF0ZWRBdCA9IG5ldyBEYXRlKCk7XG4gICAgICB0aGlzLl9vZmZzZXQgPSB0aGlzLl9wcmljZVVwZGF0ZWRBdC5nZXRUaW1lKCkgLSBicm9rZXJUaW1lc3RhbXA7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5lcnJvcignWycgKyAobmV3IERhdGUoKSkudG9JU09TdHJpbmcoKSArICddIGZhaWxlZCB0byB1cGRhdGUgcXVvdGUgc3RyZWFtaW5nIGhlYWx0aCBzdGF0dXMgb24gcHJpY2UgJyArXG4gICAgICAgICd1cGRhdGUgZm9yIGFjY291bnQgJyArIHRoaXMuX2Nvbm5lY3Rpb24uYWNjb3VudC5pZCwgZXJyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGEgc2VydmVyLXNpZGUgYXBwbGljYXRpb24gaGVhbHRoIHN0YXR1cyBpcyByZWNlaXZlZCBmcm9tIE1ldGFBcGlcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtIZWFsdGhTdGF0dXN9IHN0YXR1cyBzZXJ2ZXItc2lkZSBhcHBsaWNhdGlvbiBoZWFsdGggc3RhdHVzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgb25IZWFsdGhTdGF0dXMoaW5zdGFuY2VJbmRleCwgc3RhdHVzKSB7XG4gICAgdGhpcy5fc2VydmVySGVhbHRoU3RhdHVzWycnICsgaW5zdGFuY2VJbmRleF0gPSBzdGF0dXM7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGNvbm5lY3Rpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCB0ZXJtaW5hdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgb25EaXNjb25uZWN0ZWQoaW5zdGFuY2VJbmRleCkge1xuICAgIGRlbGV0ZSB0aGlzLl9zZXJ2ZXJIZWFsdGhTdGF0dXNbJycgKyBpbnN0YW5jZUluZGV4XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHNlcnZlci1zaWRlIGFwcGxpY2F0aW9uIGhlYWx0aCBzdGF0dXNcbiAgICogQHJldHVybiB7SGVhbHRoU3RhdHVzfSBzZXJ2ZXItc2lkZSBhcHBsaWNhdGlvbiBoZWFsdGggc3RhdHVzXG4gICAqL1xuICBnZXQgc2VydmVySGVhbHRoU3RhdHVzKCkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgZm9yIChsZXQgcyBvZiBPYmplY3QudmFsdWVzKHRoaXMuX3NlcnZlckhlYWx0aFN0YXR1cykpIHtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdCA9IHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBmaWVsZCBvZiBPYmplY3Qua2V5cyhzKSkge1xuICAgICAgICAgIHJlc3VsdFtmaWVsZF0gPSByZXN1bHRbZmllbGRdIHx8IHNbZmllbGRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgfHwge307XG4gIH1cblxuICAvKipcbiAgICogQ29ubmVjdGlvbiBoZWFsdGggc3RhdHVzXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IENvbm5lY3Rpb25IZWFsdGhTdGF0dXNcbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBjb25uZWN0ZWQgZmxhZyBpbmRpY2F0aW5nIHN1Y2Nlc3NmdWwgY29ubmVjdGlvbiB0byBBUEkgc2VydmVyXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gY29ubmVjdGVkVG9Ccm9rZXIgZmxhZyBpbmRpY2F0aW5nIHN1Y2Nlc3NmdWwgY29ubmVjdGlvbiB0byBicm9rZXJcbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBxdW90ZVN0cmVhbWluZ0hlYWx0aHkgZmxhZyBpbmRpY2F0aW5nIHRoYXQgcXVvdGVzIGFyZSBiZWluZyBzdHJlYW1lZCBzdWNjZXNzZnVsbHkgZnJvbSB0aGVcbiAgICogYnJva2VyXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc3luY2hyb25pemVkIGZsYWcgaW5kaWNhdGluZyBhIHN1Y2Nlc3NmdWwgc3luY2hyb25pemF0aW9uXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaGVhbHRoeSBmbGFnIGluZGljYXRpbmcgb3ZlcmFsbCBjb25uZWN0aW9uIGhlYWx0aCBzdGF0dXNcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IG1lc3NhZ2UgaGVhbHRoIHN0YXR1cyBtZXNzYWdlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGhlYWx0aCBzdGF0dXNcbiAgICogQHJldHVybnMge0Nvbm5lY3Rpb25IZWFsdGhTdGF0dXN9IGNvbm5lY3Rpb24gaGVhbHRoIHN0YXR1c1xuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgZ2V0IGhlYWx0aFN0YXR1cygpIHtcbiAgICBsZXQgc3RhdHVzID0ge1xuICAgICAgY29ubmVjdGVkOiB0aGlzLl9jb25uZWN0aW9uLnRlcm1pbmFsU3RhdGUuY29ubmVjdGVkLFxuICAgICAgY29ubmVjdGVkVG9Ccm9rZXI6IHRoaXMuX2Nvbm5lY3Rpb24udGVybWluYWxTdGF0ZS5jb25uZWN0ZWRUb0Jyb2tlcixcbiAgICAgIHF1b3RlU3RyZWFtaW5nSGVhbHRoeTogdGhpcy5fcXVvdGVzSGVhbHRoeSxcbiAgICAgIHN5bmNocm9uaXplZDogdGhpcy5fY29ubmVjdGlvbi5zeW5jaHJvbml6ZWRcbiAgICB9O1xuICAgIHN0YXR1cy5oZWFsdGh5ID0gc3RhdHVzLmNvbm5lY3RlZCAmJiBzdGF0dXMuY29ubmVjdGVkVG9Ccm9rZXIgJiYgc3RhdHVzLnF1b3RlU3RyZWFtaW5nSGVhbHRoeSAmJlxuICAgICAgc3RhdHVzLnN5bmNocm9uaXplZDtcbiAgICBsZXQgbWVzc2FnZTtcbiAgICBpZiAoc3RhdHVzLmhlYWx0aHkpIHtcbiAgICAgIG1lc3NhZ2UgPSAnQ29ubmVjdGlvbiB0byBicm9rZXIgaXMgc3RhYmxlLiBObyBoZWFsdGggaXNzdWVzIGRldGVjdGVkLic7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UgPSAnQ29ubmVjdGlvbiBpcyBub3QgaGVhbHRoeSBiZWNhdXNlICc7XG4gICAgICBsZXQgcmVhc29ucyA9IFtdO1xuICAgICAgaWYgKCFzdGF0dXMuY29ubmVjdGVkKSB7XG4gICAgICAgIHJlYXNvbnMucHVzaCgnY29ubmVjdGlvbiB0byBBUEkgc2VydmVyIGlzIG5vdCBlc3RhYmxpc2hlZCBvciBsb3N0Jyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0YXR1cy5jb25uZWN0ZWRUb0Jyb2tlcikge1xuICAgICAgICByZWFzb25zLnB1c2goJ2Nvbm5lY3Rpb24gdG8gYnJva2VyIGlzIG5vdCBlc3RhYmxpc2hlZCBvciBsb3N0Jyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0YXR1cy5zeW5jaHJvbml6ZWQpIHtcbiAgICAgICAgcmVhc29ucy5wdXNoKCdsb2NhbCB0ZXJtaW5hbCBzdGF0ZSBpcyBub3Qgc3luY2hyb25pemVkIHRvIGJyb2tlcicpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdGF0dXMucXVvdGVTdHJlYW1pbmdIZWFsdGh5KSB7XG4gICAgICAgIHJlYXNvbnMucHVzaCgncXVvdGVzIGFyZSBub3Qgc3RyZWFtZWQgZnJvbSB0aGUgYnJva2VyIHByb3Blcmx5Jyk7XG4gICAgICB9XG4gICAgICBtZXNzYWdlID0gbWVzc2FnZSArIHJlYXNvbnMuam9pbignIGFuZCAnKSArICcuJztcbiAgICB9XG4gICAgc3RhdHVzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHJldHVybiBzdGF0dXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB1cHRpbWUgaW4gcGVyY2VudHMgbWVhc3VyZWQgb3ZlciBzcGVjaWZpYyBwZXJpb2RzIG9mIHRpbWVcbiAgICogQHJldHVybnMge09iamVjdH0gdXB0aW1lIGluIHBlcmNlbnRzIG1lYXN1cmVkIG92ZXIgc3BlY2lmaWMgcGVyaW9kcyBvZiB0aW1lXG4gICAqL1xuICBnZXQgdXB0aW1lKCkge1xuICAgIGxldCB1cHRpbWUgPSB7fTtcbiAgICBmb3IgKGxldCBlIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuX3VwdGltZVJlc2Vydm9pcnMpKSB7XG4gICAgICB1cHRpbWVbZVswXV0gPSBlWzFdLmdldFN0YXRpc3RpY3MoKS5hdmVyYWdlO1xuICAgIH1cbiAgICByZXR1cm4gdXB0aW1lO1xuICB9XG5cbiAgX21lYXN1cmVVcHRpbWUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIE9iamVjdC52YWx1ZXModGhpcy5fdXB0aW1lUmVzZXJ2b2lycykuZm9yRWFjaChyID0+IHIucHVzaE1lYXN1cmVtZW50KHRoaXMuX2Nvbm5lY3Rpb24udGVybWluYWxTdGF0ZS5jb25uZWN0ZWQgJiZcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbi50ZXJtaW5hbFN0YXRlLmNvbm5lY3RlZFRvQnJva2VyICYmIHRoaXMuX2Nvbm5lY3Rpb24uc3luY2hyb25pemVkICYmXG4gICAgICAgIHRoaXMuX3F1b3Rlc0hlYWx0aHkgPyAxMDAgOiAwKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5lcnJvcignWycgKyAobmV3IERhdGUoKSkudG9JU09TdHJpbmcoKSArICddIGZhaWxlZCB0byBtZWFzdXJlIHVwdGltZSBmb3IgYWNjb3VudCAnICtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5hY2NvdW50LmlkLCBlcnIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIF91cGRhdGVRdW90ZUhlYWx0aFN0YXR1cygpIHtcbiAgICB0cnkge1xuICAgICAgbGV0IHNlcnZlckRhdGVUaW1lID0gbW9tZW50KG5ldyBEYXRlKERhdGUubm93KCkgLSB0aGlzLl9vZmZzZXQpKTtcbiAgICAgIGxldCBzZXJ2ZXJUaW1lID0gc2VydmVyRGF0ZVRpbWUuZm9ybWF0KCdISDptbTpzcy5TU1MnKTtcbiAgICAgIGxldCBkYXlPZldlZWsgPSBzZXJ2ZXJEYXRlVGltZS5kYXkoKTtcbiAgICAgIGxldCBkYXlzT2ZXZWVrID0ge1xuICAgICAgICAwOiAnU1VOREFZJyxcbiAgICAgICAgMTogJ01PTkRBWScsXG4gICAgICAgIDI6ICdUVUVTREFZJyxcbiAgICAgICAgMzogJ1dFRE5FU0RBWScsXG4gICAgICAgIDQ6ICdUSFVSU0RBWScsXG4gICAgICAgIDU6ICdGUklEQVknLFxuICAgICAgICA2OiAnU0FUVVJEQVknXG4gICAgICB9O1xuICAgICAgbGV0IGluUXVvdGVTZXNzaW9uID0gZmFsc2U7XG4gICAgICBpZiAoIXRoaXMuX3ByaWNlVXBkYXRlZEF0KSB7XG4gICAgICAgIHRoaXMuX3ByaWNlVXBkYXRlZEF0ID0gbmV3IERhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHRoaXMuX2Nvbm5lY3Rpb24uc3Vic2NyaWJlZFN5bWJvbHMgfHwgW10pLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9wcmljZVVwZGF0ZWRBdCA9IG5ldyBEYXRlKCk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBzeW1ib2wgb2YgdGhpcy5fY29ubmVjdGlvbi5zdWJzY3JpYmVkU3ltYm9scyB8fCBbXSkge1xuICAgICAgICBsZXQgc3BlY2lmaWNhdGlvbiA9IHRoaXMuX2Nvbm5lY3Rpb24udGVybWluYWxTdGF0ZS5zcGVjaWZpY2F0aW9uKHN5bWJvbCkgfHwge307XG4gICAgICAgIGxldCBxdW90ZVNlc3Npb25zID0gKHNwZWNpZmljYXRpb24ucXVvdGVTZXNzaW9ucyB8fCBbXSlbZGF5c09mV2Vla1tkYXlPZldlZWtdXSB8fCBbXTtcbiAgICAgICAgZm9yIChsZXQgc2Vzc2lvbiBvZiBxdW90ZVNlc3Npb25zKSB7XG4gICAgICAgICAgaWYgKHNlc3Npb24uZnJvbSA8PSBzZXJ2ZXJUaW1lICYmIHNlc3Npb24udG8gPj0gc2VydmVyVGltZSkge1xuICAgICAgICAgICAgaW5RdW90ZVNlc3Npb24gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fcXVvdGVzSGVhbHRoeSA9ICF0aGlzLl9jb25uZWN0aW9uLnN1YnNjcmliZWRTeW1ib2xzLmxlbmd0aCB8fCAhaW5RdW90ZVNlc3Npb24gfHxcbiAgICAgICAgKERhdGUubm93KCkgLSB0aGlzLl9wcmljZVVwZGF0ZWRBdC5nZXRUaW1lKCkgPCB0aGlzLl9taW5RdW90ZUludGVydmFsKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmVycm9yKCdbJyArIChuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpICsgJ10gZmFpbGVkIHRvIHVwZGF0ZSBxdW90ZSBzdHJlYW1pbmcgaGVhbHRoIHN0YXR1cyBmb3IgYWNjb3VudCAnICtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5hY2NvdW50LmlkLCBlcnIpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRSYW5kb21UaW1lb3V0KCkge1xuICAgIHJldHVybiAoTWF0aC5yYW5kb20oKSAqIDU5ICArIDEpICogMTAwMDtcbiAgfVxuXG59XG4iXX0=
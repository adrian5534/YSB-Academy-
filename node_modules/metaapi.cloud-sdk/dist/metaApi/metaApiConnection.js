'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _terminalState = require('./terminalState');

var _terminalState2 = _interopRequireDefault(_terminalState);

var _memoryHistoryStorage = require('./memoryHistoryStorage');

var _memoryHistoryStorage2 = _interopRequireDefault(_memoryHistoryStorage);

var _synchronizationListener = require('../clients/metaApi/synchronizationListener');

var _synchronizationListener2 = _interopRequireDefault(_synchronizationListener);

var _timeoutError = require('../clients/timeoutError');

var _timeoutError2 = _interopRequireDefault(_timeoutError);

var _randomstring = require('randomstring');

var _randomstring2 = _interopRequireDefault(_randomstring);

var _connectionHealthMonitor = require('./connectionHealthMonitor');

var _connectionHealthMonitor2 = _interopRequireDefault(_connectionHealthMonitor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Exposes MetaApi MetaTrader API connection to consumers
 */
class MetaApiConnection extends _synchronizationListener2.default {

  /**
   * Constructs MetaApi MetaTrader Api connection
   * @param {MetaApiWebsocketClient} websocketClient MetaApi websocket client
   * @param {MetatraderAccount} account MetaTrader account id to connect to
   * @param {HistoryStorage} historyStorage terminal history storage. By default an instance of MemoryHistoryStorage
   * will be used.
   * @param {ConnectionRegistry} connectionRegistry metatrader account connection registry
   * @param {Date} [historyStartTime] history start sync time
   */
  constructor(websocketClient, account, historyStorage, connectionRegistry, historyStartTime) {
    super();
    this._websocketClient = websocketClient;
    this._account = account;
    this._connectionRegistry = connectionRegistry;
    this._historyStartTime = historyStartTime;
    this._terminalState = new _terminalState2.default();
    this._historyStorage = historyStorage || new _memoryHistoryStorage2.default(account.id, connectionRegistry.application);
    this._healthMonitor = new _connectionHealthMonitor2.default(this);
    this._websocketClient.addSynchronizationListener(account.id, this);
    this._websocketClient.addSynchronizationListener(account.id, this._terminalState);
    this._websocketClient.addSynchronizationListener(account.id, this._historyStorage);
    this._websocketClient.addSynchronizationListener(account.id, this._healthMonitor);
    this._websocketClient.addReconnectListener(this, account.id);
    this._subscriptions = {};
    this._stateByInstanceIndex = {};
    this._synchronized = false;
    this._synchronizationListeners = [];
  }

  /**
   * Returns account information (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readAccountInformation/).
   * @returns {Promise<MetatraderAccountInformation>} promise resolving with account information
   */
  getAccountInformation() {
    return this._websocketClient.getAccountInformation(this._account.id);
  }

  /**
   * Returns positions (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readPositions/).
   * @returns {Promise<Array<MetatraderPosition>} promise resolving with array of open positions
   */
  getPositions() {
    return this._websocketClient.getPositions(this._account.id);
  }

  /**
   * Returns specific position (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readPosition/).
   * @param {String} positionId position id
   * @return {Promise<MetatraderPosition>} promise resolving with MetaTrader position found
   */
  getPosition(positionId) {
    return this._websocketClient.getPosition(this._account.id, positionId);
  }

  /**
   * Returns open orders (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readOrders/).
   * @return {Promise<Array<MetatraderOrder>>} promise resolving with open MetaTrader orders
   */
  getOrders() {
    return this._websocketClient.getOrders(this._account.id);
  }

  /**
   * Returns specific open order (see
   * https://metaapi.cloud/docs/client/websocket/api/readTradingTerminalState/readOrder/).
   * @param {String} orderId order id (ticket number)
   * @return {Promise<MetatraderOrder>} promise resolving with metatrader order found
   */
  getOrder(orderId) {
    return this._websocketClient.getOrder(this._account.id, orderId);
  }

  /**
   * Returns the history of completed orders for a specific ticket number (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readHistoryOrdersByTicket/).
   * @param {String} ticket ticket number (order id)
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */
  getHistoryOrdersByTicket(ticket) {
    return this._websocketClient.getHistoryOrdersByTicket(this._account.id, ticket);
  }

  /**
   * Returns the history of completed orders for a specific position id (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readHistoryOrdersByPosition/)
   * @param {String} positionId position id
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */
  getHistoryOrdersByPosition(positionId) {
    return this._websocketClient.getHistoryOrdersByPosition(this._account.id, positionId);
  }

  /**
   * Returns the history of completed orders for a specific time range (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readHistoryOrdersByTimeRange/)
   * @param {Date} startTime start of time range, inclusive
   * @param {Date} endTime end of time range, exclusive
   * @param {Number} offset pagination offset, default is 0
   * @param {Number} limit pagination limit, default is 1000
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */
  getHistoryOrdersByTimeRange(startTime, endTime, offset = 0, limit = 1000) {
    return this._websocketClient.getHistoryOrdersByTimeRange(this._account.id, startTime, endTime, offset, limit);
  }

  /**
   * Returns history deals with a specific ticket number (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readDealsByTicket/).
   * @param {String} ticket ticket number (deal id for MT5 or order id for MT4)
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */
  getDealsByTicket(ticket) {
    return this._websocketClient.getDealsByTicket(this._account.id, ticket);
  }

  /**
   * Returns history deals for a specific position id (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readDealsByPosition/).
   * @param {String} positionId position id
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */
  getDealsByPosition(positionId) {
    return this._websocketClient.getDealsByPosition(this._account.id, positionId);
  }

  /**
   * Returns history deals with for a specific time range (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveHistoricalData/readDealsByTimeRange/).
   * @param {Date} startTime start of time range, inclusive
   * @param {Date} endTime end of time range, exclusive
   * @param {Number} offset pagination offset, default is 0
   * @param {Number} limit pagination limit, default is 1000
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */
  getDealsByTimeRange(startTime, endTime, offset = 0, limit = 1000) {
    return this._websocketClient.getDealsByTimeRange(this._account.id, startTime, endTime, offset, limit);
  }

  /**
   * Clears the order and transaction history of a specified application so that it can be synchronized from scratch
   * (see https://metaapi.cloud/docs/client/websocket/api/removeHistory/).
   * @param {String} [application] application to remove history for
   * @return {Promise} promise resolving when the history is cleared
   */
  removeHistory(application) {
    this._historyStorage.clear();
    return this._websocketClient.removeHistory(this._account.id, application);
  }

  /**
   * Clears the order and transaction history of a specified application and removes application (see
   * https://metaapi.cloud/docs/client/websocket/api/removeApplication/).
   * @return {Promise} promise resolving when the history is cleared and application is removed
   */
  removeApplication() {
    this._historyStorage.clear();
    return this._websocketClient.removeApplication(this._account.id);
  }

  /**
   * Common trade options
   * @typedef {Object} TradeOptions
   * @property {String} [comment] optional order comment. The sum of the line lengths of the comment and the
   * clientId must be less than or equal to 26. For more information see
   * https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} [clientId] optional client-assigned id. The id value can be assigned when submitting a trade and
   * will be present on position, history orders and history deals related to the trade. You can use this field to bind
   * your trades to objects in your application and then track trade progress. The sum of the line lengths of the
   * comment and the clientId must be less than or equal to 26. For more information see
   * https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {Number} [magic] optional magic (expert id) number. If not set default value specified in account entity
   * will be used.
   * @property {Number} [slippage] optional slippage in points. Should be greater or equal to zero. In not set,
   * default value specified in account entity will be used. Slippage is ignored if execution mode set to
   * SYMBOL_TRADE_EXECUTION_MARKET in symbol specification. Not used for close by orders.
   */

  /**
   * Market trade options
   * @typedef {TradeOptions} MarketTradeOptions
   * @property {Array<String>} [fillingModes] optional allowed filling modes in the order of priority. Default is to
   * allow all filling modes and prefer ORDER_FILLING_FOK over ORDER_FILLING_IOC. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_type_filling for extra
   * explanation
   */

  /**
   * Pending order trade options
   * @typedef {TradeOptions} PendingTradeOptions
   * @property {ExpirationOptions} [expiration] optional pending order expiration settings. See Pending order expiration
   * settings section
   */

  /**
   * Pending order expiration settings
   * @typedef {Object} ExpirationOptions
   * @property {String} type pending order expiration type. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_type_time for the list of
   * possible options. MetaTrader4 platform supports only ORDER_TIME_SPECIFIED expiration type. One of ORDER_TIME_GTC,
   * ORDER_TIME_DAY, ORDER_TIME_SPECIFIED, ORDER_TIME_SPECIFIED_DAY
   * @property {Date} [time] optional pending order expiration time. Ignored if expiration type is not one of
   * ORDER_TIME_DAY or ORDER_TIME_SPECIFIED
   */

  /**
   * Stop options
   * @typedef {Object} StopOptions
   * @property {number} value stop (SL or TP) value
   * @property {string} units stop units. ABSOLUTE_PRICE means the that the value of value field is a final stop value.
   * RELATIVE_* means that the value field value contains relative stop expressed either in price, points, account
   * currency or balance percentage. Default is ABSOLUTE_PRICE. Allowed values are ABSOLUTE_PRICE, RELATIVE_PRICE,
   * RELATIVE_POINTS, RELATIVE_CURRENCY, RELATIVE_BALANCE_PERCENTAGE
   */

  /**
   * Creates a market buy order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createMarketBuyOrder(symbol, volume, stopLoss, takeProfit, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'ORDER_TYPE_BUY', symbol, volume }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Creates a market sell order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createMarketSellOrder(symbol, volume, stopLoss, takeProfit, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'ORDER_TYPE_SELL', symbol, volume }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Creates a limit buy order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {String} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order limit price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createLimitBuyOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'ORDER_TYPE_BUY_LIMIT', symbol,
      volume, openPrice }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Creates a limit sell order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order limit price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createLimitSellOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'ORDER_TYPE_SELL_LIMIT', symbol,
      volume, openPrice }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Creates a stop buy order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createStopBuyOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'ORDER_TYPE_BUY_STOP', symbol,
      volume, openPrice }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Creates a stop sell order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createStopSellOrder(symbol, volume, openPrice, stopLoss, takeProfit, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'ORDER_TYPE_SELL_STOP', symbol,
      volume, openPrice }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Creates a stop limit buy order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number} stopLimitPrice the limit order price for the stop limit order
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createStopLimitBuyOrder(symbol, volume, openPrice, stopLimitPrice, stopLoss, takeProfit, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'ORDER_TYPE_BUY_STOP_LIMIT',
      symbol, volume, openPrice, stopLimitPrice }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Creates a stop limit sell order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {number} volume order volume
   * @param {number} openPrice order stop price
   * @param {number} stopLimitPrice the limit order price for the stop limit order
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @param {PendingTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  createStopLimitSellOrder(symbol, volume, openPrice, stopLimitPrice, stopLoss, takeProfit, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'ORDER_TYPE_SELL_STOP_LIMIT',
      symbol, volume, openPrice, stopLimitPrice }, this._generateStopOptions(stopLoss, takeProfit), options || {}));
  }

  /**
   * Modifies a position (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} positionId position id to modify
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  modifyPosition(positionId, stopLoss, takeProfit) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'POSITION_MODIFY', positionId }, this._generateStopOptions(stopLoss, takeProfit)));
  }

  /**
   * Partially closes a position (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} positionId position id to modify
   * @param {number} volume volume to close
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  closePositionPartially(positionId, volume, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'POSITION_PARTIAL', positionId,
      volume }, options || {}));
  }

  /**
   * Fully closes a position (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} positionId position id to modify
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  closePosition(positionId, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'POSITION_CLOSE_ID', positionId }, options || {}));
  }

  /**
   * Fully closes a position (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} positionId position id to close by opposite position
   * @param {string} oppositePositionId opposite position id to close
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  closeBy(positionId, oppositePositionId, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'POSITION_CLOSE_BY', positionId,
      closeByPositionId: oppositePositionId }, options || {}));
  }

  /**
   * Closes positions by a symbol(see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} symbol symbol to trade
   * @param {MarketTradeOptions} options optional trade options
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  closePositionsBySymbol(symbol, options = {}) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'POSITIONS_CLOSE_SYMBOL', symbol }, options || {}));
  }

  /**
   * Modifies a pending order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} orderId order id (ticket number)
   * @param {number} openPrice order stop price
   * @param {number|StopOptions} [stopLoss] stop loss price
   * @param {number|StopOptions} [takeProfit] take profit price
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  modifyOrder(orderId, openPrice, stopLoss, takeProfit) {
    return this._websocketClient.trade(this._account.id, (0, _assign2.default)({ actionType: 'ORDER_MODIFY', orderId, openPrice }, this._generateStopOptions(stopLoss, takeProfit)));
  }

  /**
   * Cancels order (see https://metaapi.cloud/docs/client/websocket/api/trade/).
   * @param {string} orderId order id (ticket number)
   * @returns {Promise<TradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */
  cancelOrder(orderId) {
    return this._websocketClient.trade(this._account.id, { actionType: 'ORDER_CANCEL', orderId });
  }

  /**
   * Reconnects to the Metatrader terminal (see https://metaapi.cloud/docs/client/websocket/api/reconnect/).
   * @returns {Promise} promise which resolves when reconnection started
   */
  reconnect() {
    return this._websocketClient.reconnect(this._account.id);
  }

  /**
   * Requests the terminal to start synchronization process
   * (see https://metaapi.cloud/docs/client/websocket/synchronizing/synchronize/)
   * @param {String} instanceIndex instance index
   * @returns {Promise} promise which resolves when synchronization started
   */
  async synchronize(instanceIndex) {
    const instance = this.getInstanceNumber(instanceIndex);
    const host = this.getHostName(instanceIndex);
    let startingHistoryOrderTime = new Date(Math.max((this._historyStartTime || new Date(0)).getTime(), (await this._historyStorage.lastHistoryOrderTime(instance)).getTime()));
    let startingDealTime = new Date(Math.max((this._historyStartTime || new Date(0)).getTime(), (await this._historyStorage.lastDealTime(instance)).getTime()));
    let synchronizationId = _randomstring2.default.generate(32);
    this._getState(instanceIndex).lastSynchronizationId = synchronizationId;
    return this._websocketClient.synchronize(this._account.id, instance, host, synchronizationId, startingHistoryOrderTime, startingDealTime);
  }

  /**
   * Initializes meta api connection
   * @return {Promise} promise which resolves when meta api connection is initialized
   */
  async initialize() {
    await this._historyStorage.initialize();
  }

  /**
   * Initiates subscription to MetaTrader terminal
   * @returns {Promise} promise which resolves when subscription is initiated
   */
  async subscribe() {
    if (!this._closed) {
      this._websocketClient.ensureSubscribe(this._account.id);
    }
  }

  /**
   * Subscribes on market data of specified symbol (see
   * https://metaapi.cloud/docs/client/websocket/marketDataStreaming/subscribeToMarketData/).
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataSubscription>} subscriptions array of market data subscription to create or update. Please
   * note that this feature is not fully implemented on server-side yet
   * @param {Number} instanceIndex instance index
   * @param {number} [timeoutInSeconds] timeout to wait for prices in seconds, default is 30
   * @returns {Promise} promise which resolves when subscription request was processed
   */
  async subscribeToMarketData(symbol, subscriptions, instanceIndex, timeoutInSeconds) {
    this._subscriptions[symbol] = { subscriptions };
    await this._websocketClient.subscribeToMarketData(this._account.id, instanceIndex, symbol, subscriptions);
    return this.terminalState.waitForPrice(symbol, timeoutInSeconds);
  }

  /**
   * Unsubscribes from market data of specified symbol (see
   * https://metaapi.cloud/docs/client/websocket/marketDataStreaming/unsubscribeFromMarketData/).
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataUnsubscription>} subscriptions array of subscriptions to cancel
   * @param {Number} instanceIndex instance index
   * @returns {Promise} promise which resolves when unsubscription request was processed
   */
  unsubscribeFromMarketData(symbol, subscriptions, instanceIndex) {
    if (!subscriptions) {
      delete this._subscriptions[symbol];
    } else if (this._subscriptions[symbol]) {
      this._subscriptions[symbol].subscriptions = this._subscriptions[symbol].subscriptions.filter(s => !subscriptions.find(s2 => s.type === s2.type));
      if (!this._subscriptions[symbol].subscriptions.length) {
        delete this._subscriptions[symbol];
      }
    }
    return this._websocketClient.unsubscribeFromMarketData(this._account.id, instanceIndex, symbol, subscriptions);
  }

  /**
   * Invoked when subscription downgrade has occurred
   * @param {String} instanceIndex index of an account instance connected
   * @param {string} symbol symbol to update subscriptions for
   * @param {Array<MarketDataSubscription>} updates array of market data subscription to update
   * @param {Array<MarketDataUnsubscription>} unsubscriptions array of subscriptions to cancel
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  // eslint-disable-next-line complexity
  async onSubscriptionDowngraded(instanceIndex, symbol, updates, unsubscriptions) {
    let subscriptions = this._subscriptions[symbol];
    if (unsubscriptions && unsubscriptions.length) {
      if (subscriptions) {
        for (let subscription of unsubscriptions) {
          subscriptions = subscriptions.filter(s => s.type === subscription.type);
        }
      }
      this.unsubscribeFromMarketData(symbol, unsubscriptions);
    }
    if (updates && updates.length) {
      if (subscriptions) {
        for (let subscription of updates) {
          subscriptions.filter(s => s.type === subscription.type).forEach(s => s.intervalInMilliiseconds = subscription.intervalInMilliseconds);
        }
      }
      this.subscribeToMarketData(symbol, updates);
    }
    if (subscriptions && !subscriptions.length) {
      delete this._subscriptions[symbol];
    }
  }

  /**
   * Returns list of the symbols connection is subscribed to
   * @returns {Array<String>} list of the symbols connection is subscribed to
   */
  get subscribedSymbols() {
    return (0, _keys2.default)(this._subscriptions);
  }

  /**
   * Returns subscriptions for a symbol
   * @param {string} symbol symbol to retrieve subscriptions for
   * @returns {Array<MarketDataSubscription>} list of market data subscriptions for the symbol
   */
  subscriptions(symbol) {
    return (this._subscriptions[symbol] || {}).subscriptions;
  }

  /**
   * Retrieves available symbols for an account (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readSymbols/).
   * @param {String} symbol symbol to retrieve symbols for
   * @returns {Promise<Array<string>>} promise which resolves when symbols are retrieved
   */
  getSymbols() {
    return this._websocketClient.getSymbols(this._account.id);
  }

  /**
   * Retrieves specification for a symbol (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readSymbolSpecification/).
   * @param {String} symbol symbol to retrieve specification for
   * @returns {Promise<MetatraderSymbolSpecification>} promise which resolves when specification is retrieved
   */
  getSymbolSpecification(symbol) {
    return this._websocketClient.getSymbolSpecification(this._account.id, symbol);
  }

  /**
   * Retrieves latest price for a symbol (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readSymbolPrice/).
   * @param {String} symbol symbol to retrieve price for
   * @returns {Promise<MetatraderSymbolPrice>} promise which resolves when price is retrieved
   */
  getSymbolPrice(symbol) {
    return this._websocketClient.getSymbolPrice(this._account.id, symbol);
  }

  /**
   * Retrieves latest candle for a symbol and timeframe (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readCandle/).
   * @param {String} symbol symbol to retrieve candle for
   * @param {string} timeframe defines the timeframe according to which the candle must be generated. Allowed values for
   * MT5 are 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, 1d, 1w, 1mn. Allowed values
   * for MT4 are 1m, 5m, 15m 30m, 1h, 4h, 1d, 1w, 1mn
   * @returns {Promise<MetatraderCandle>} promise which resolves when candle is retrieved
   */
  getCandle(symbol, timeframe) {
    return this._websocketClient.getCandle(this._account.id, symbol, timeframe);
  }

  /**
   * Retrieves latest tick for a symbol (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readTick/).
   * @param {String} symbol symbol to retrieve tick for
   * @returns {Promise<MetatraderTick>} promise which resolves when tick is retrieved
   */
  getTick(symbol) {
    return this._websocketClient.getTick(this._account.id, symbol);
  }

  /**
   * Retrieves latest order book for a symbol (see
   * https://metaapi.cloud/docs/client/websocket/api/retrieveMarketData/readBook/).
   * @param {String} symbol symbol to retrieve order book for
   * @returns {Promise<MetatraderTick>} promise which resolves when order book is retrieved
   */
  getBook(symbol) {
    return this._websocketClient.getBook(this._account.id, symbol);
  }

  /**
   * Sends client uptime stats to the server.
   * @param {Object} uptime uptime statistics to send to the server
   * @returns {Promise} promise which resolves when uptime statistics is submitted
   */
  saveUptime(uptime) {
    return this._websocketClient.saveUptime(this._account.id, uptime);
  }

  /**
   * Returns local copy of terminal state
   * @returns {TerminalState} local copy of terminal state
   */
  get terminalState() {
    return this._terminalState;
  }

  /**
   * Returns local history storage
   * @returns {HistoryStorage} local history storage
   */
  get historyStorage() {
    return this._historyStorage;
  }

  /**
   * Adds synchronization listener
   * @param {SynchronizationListener} listener synchronization listener to add
   */
  addSynchronizationListener(listener) {
    this._synchronizationListeners.push(listener);
    this._websocketClient.addSynchronizationListener(this._account.id, listener);
  }

  /**
   * Removes synchronization listener for specific account
   * @param {SynchronizationListener} listener synchronization listener to remove
   */
  removeSynchronizationListener(listener) {
    this._synchronizationListeners = this._synchronizationListeners.filter(l => l !== listener);
    this._websocketClient.removeSynchronizationListener(this._account.id, listener);
  }

  /**
   * Invoked when connection to MetaTrader terminal established
   * @param {String} instanceIndex index of an account instance connected
   * @param {Number} replicas number of account replicas launched
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  async onConnected(instanceIndex, replicas) {
    let key = _randomstring2.default.generate(32);
    let state = this._getState(instanceIndex);
    state.shouldSynchronize = key;
    state.synchronizationRetryIntervalInSeconds = 1;
    state.synchronized = false;
    this._ensureSynchronized(instanceIndex, key);
    let indices = [];
    for (let i = 0; i < replicas; i++) {
      indices.push(i);
    }
    for (let e of (0, _entries2.default)(this._stateByInstanceIndex)) {
      if (!indices.includes(this.getInstanceNumber(e[1].instanceIndex))) {
        delete this._stateByInstanceIndex[e[0]];
      }
    }
  }

  /**
   * Invoked when connection to MetaTrader terminal terminated
   * @param {String} instanceIndex index of an account instance connected
   */
  async onDisconnected(instanceIndex) {
    let state = this._getState(instanceIndex);
    state.lastDisconnectedSynchronizationId = state.lastSynchronizationId;
    state.lastSynchronizationId = undefined;
    state.shouldSynchronize = undefined;
    state.synchronized = false;
    state.disconnected = true;
  }

  /**
   * Invoked when a synchronization of history deals on a MetaTrader account have finished
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   */
  async onDealSynchronizationFinished(instanceIndex, synchronizationId) {
    let state = this._getState(instanceIndex);
    state.dealsSynchronized[synchronizationId] = true;
  }

  /**
   * Invoked when a synchronization of history orders on a MetaTrader account have finished
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   */
  async onOrderSynchronizationFinished(instanceIndex, synchronizationId) {
    let state = this._getState(instanceIndex);
    state.ordersSynchronized[synchronizationId] = true;
  }

  /**
   * Invoked when MetaTrader account information is updated
   * @param {String} instanceIndex index of an account instance connected
   * @param {MetatraderAccountInformation} accountInformation updated MetaTrader account information
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  async onAccountInformationUpdated(instanceIndex, accountInformation) {
    for (let symbol of this.subscribedSymbols) {
      if (!this._terminalState.price(symbol)) {
        const instance = this.getInstanceNumber(instanceIndex);
        _promise2.default.resolve(this.subscribeToMarketData(symbol, this._subscriptions[symbol].subscriptions, instance)).catch(err => console.error('[' + new Date().toISOString() + '] MetaApi websocket client for account ' + this._account.id + ':' + instanceIndex + ' failed to resubscribe to symbol ' + symbol, err));
      }
    }
  }

  /**
   * Invoked when connection to MetaApi websocket API restored after a disconnect
   * @return {Promise} promise which resolves when connection to MetaApi websocket API restored after a disconnect
   */
  async onReconnected() {
    this._stateByInstanceIndex = {};
  }

  /**
   * Invoked when a stream for an instance index is closed
   * @param {String} instanceIndex index of an account instance connected
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */
  async onStreamClosed(instanceIndex) {
    delete this._stateByInstanceIndex[instanceIndex];
  }

  /**
   * Returns flag indicating status of state synchronization with MetaTrader terminal
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} synchronizationId optional synchronization request id, last synchronization request id will be used
   * by default
   * @return {Promise<Boolean>} promise resolving with a flag indicating status of state synchronization with MetaTrader
   * terminal
   */
  async isSynchronized(instanceIndex, synchronizationId) {
    return (0, _values2.default)(this._stateByInstanceIndex).reduce((acc, s) => {
      if (instanceIndex !== undefined && s.instanceIndex !== instanceIndex) {
        return acc;
      }
      synchronizationId = synchronizationId || s.lastSynchronizationId;
      let synchronized = !!s.ordersSynchronized[synchronizationId] && !!s.dealsSynchronized[synchronizationId];
      return acc || synchronized;
    }, false);
  }

  /**
   * @typedef {Object} SynchronizationOptions
   * @property {String} [applicationPattern] application regular expression pattern, default is .*
   * @property {String} [synchronizationId] synchronization id, last synchronization request id will be used by
   * default
   * @property {Number} [instanceIndex] index of an account instance to ensure synchronization on, default is to wait
   * for the first instance to synchronize
   * @param {Number} [timeoutInSeconds] wait timeout in seconds, default is 5m
   * @param {Number} [intervalInMilliseconds] interval between account reloads while waiting for a change, default is 1s
   */

  /**
   * Waits until synchronization to MetaTrader terminal is completed
   * @param {SynchronizationOptions} synchronization options
   * @return {Promise} promise which resolves when synchronization to MetaTrader terminal is completed
   * @throws {TimeoutError} if application failed to synchronize with the teminal withing timeout allowed
   */
  // eslint-disable-next-line complexity
  async waitSynchronized(opts) {
    opts = opts || {};
    let instanceIndex = opts.instanceIndex;
    let synchronizationId = opts.synchronizationId;
    let timeoutInSeconds = opts.timeoutInSeconds || 300;
    let intervalInMilliseconds = opts.intervalInMilliseconds || 1000;
    let applicationPattern = opts.applicationPattern || (this._account.application === 'CopyFactory' ? 'CopyFactory.*|RPC' : 'RPC');
    let startTime = Date.now();
    let synchronized;
    while (!(synchronized = await this.isSynchronized(instanceIndex, synchronizationId)) && startTime + timeoutInSeconds * 1000 > Date.now()) {
      await new _promise2.default(res => setTimeout(res, intervalInMilliseconds));
    }
    let state;
    if (instanceIndex === undefined) {
      for (let s of (0, _values2.default)(this._stateByInstanceIndex)) {
        if (await this.isSynchronized(s.instanceIndex, synchronizationId)) {
          state = s;
          instanceIndex = s.instanceIndex;
        }
      }
    } else {
      state = (0, _values2.default)(this._stateByInstanceIndex).find(s => s.instanceIndex === instanceIndex);
    }
    if (!synchronized) {
      throw new _timeoutError2.default('Timed out waiting for MetaApi to synchronize to MetaTrader account ' + this._account.id + ', synchronization id ' + (synchronizationId || state && state.lastSynchronizationId || state && state.lastDisconnectedSynchronizationId));
    }
    let timeLeftInSeconds = Math.max(0, timeoutInSeconds - (Date.now() - startTime) / 1000);
    await this._websocketClient.waitSynchronized(this._account.id, this.getInstanceNumber(instanceIndex), applicationPattern, timeLeftInSeconds);
  }

  /**
   * Closes the connection. The instance of the class should no longer be used after this method is invoked.
   */
  async close() {
    if (!this._closed) {
      this._stateByInstanceIndex = {};
      await this._websocketClient.unsubscribe(this._account.id);
      this._websocketClient.removeSynchronizationListener(this._account.id, this);
      this._websocketClient.removeSynchronizationListener(this._account.id, this._terminalState);
      this._websocketClient.removeSynchronizationListener(this._account.id, this._historyStorage);
      this._websocketClient.removeSynchronizationListener(this._account.id, this._healthMonitor);
      for (let listener of this._synchronizationListeners) {
        this._websocketClient.removeSynchronizationListener(this._account.id, listener);
      }
      this._websocketClient.removeReconnectListener(this);
      this._connectionRegistry.remove(this._account.id);
      this._healthMonitor.stop();
      this._closed = true;
    }
  }

  /**
   * Returns synchronization status
   * @return {boolean} synchronization status
   */
  get synchronized() {
    return (0, _values2.default)(this._stateByInstanceIndex).reduce((acc, s) => acc || s.synchronized, false);
  }

  /**
   * Returns MetaApi account
   * @return {MetatraderAccount} MetaApi account
   */
  get account() {
    return this._account;
  }

  /**
   * Returns connection health monitor instance
   * @return {ConnectionHealthMonitor} connection health monitor instance
   */
  get healthMonitor() {
    return this._healthMonitor;
  }

  _generateStopOptions(stopLoss, takeProfit) {
    let trade = {};
    if (typeof stopLoss === 'number') {
      trade.stopLoss = stopLoss;
    } else if (stopLoss) {
      trade.stopLoss = stopLoss.value;
      trade.stopLossUnits = stopLoss.units;
    }
    if (typeof takeProfit === 'number') {
      trade.takeProfit = takeProfit;
    } else if (takeProfit) {
      trade.takeProfit = takeProfit.value;
      trade.takeProfitUnits = takeProfit.units;
    }
    return trade;
  }

  async _ensureSynchronized(instanceIndex, key) {
    let state = this._getState(instanceIndex);
    if (state && !this._closed) {
      try {
        const synchronizationResult = await this.synchronize(instanceIndex);
        if (synchronizationResult) {
          state.synchronized = true;
          state.synchronizationRetryIntervalInSeconds = 1;
        }
      } catch (err) {
        console.error('[' + new Date().toISOString() + '] MetaApi websocket client for account ' + this._account.id + ':' + instanceIndex + ' failed to synchronize', err);
        if (state.shouldSynchronize === key) {
          setTimeout(this._ensureSynchronized.bind(this, instanceIndex, key), state.synchronizationRetryIntervalInSeconds * 1000);
          state.synchronizationRetryIntervalInSeconds = Math.min(state.synchronizationRetryIntervalInSeconds * 2, 300);
        }
      }
    }
  }

  _getState(instanceIndex) {
    if (!this._stateByInstanceIndex['' + instanceIndex]) {
      this._stateByInstanceIndex['' + instanceIndex] = {
        instanceIndex,
        ordersSynchronized: {},
        dealsSynchronized: {},
        shouldSynchronize: undefined,
        synchronizationRetryIntervalInSeconds: 1,
        synchronized: false,
        lastDisconnectedSynchronizationId: undefined,
        lastSynchronizationId: undefined,
        disconnected: false
      };
    }
    return this._stateByInstanceIndex['' + instanceIndex];
  }

}
exports.default = MetaApiConnection;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9tZXRhQXBpL21ldGFBcGlDb25uZWN0aW9uLmVzNiJdLCJuYW1lcyI6WyJNZXRhQXBpQ29ubmVjdGlvbiIsIlN5bmNocm9uaXphdGlvbkxpc3RlbmVyIiwiY29uc3RydWN0b3IiLCJ3ZWJzb2NrZXRDbGllbnQiLCJhY2NvdW50IiwiaGlzdG9yeVN0b3JhZ2UiLCJjb25uZWN0aW9uUmVnaXN0cnkiLCJoaXN0b3J5U3RhcnRUaW1lIiwiX3dlYnNvY2tldENsaWVudCIsIl9hY2NvdW50IiwiX2Nvbm5lY3Rpb25SZWdpc3RyeSIsIl9oaXN0b3J5U3RhcnRUaW1lIiwiX3Rlcm1pbmFsU3RhdGUiLCJUZXJtaW5hbFN0YXRlIiwiX2hpc3RvcnlTdG9yYWdlIiwiTWVtb3J5SGlzdG9yeVN0b3JhZ2UiLCJpZCIsImFwcGxpY2F0aW9uIiwiX2hlYWx0aE1vbml0b3IiLCJDb25uZWN0aW9uSGVhbHRoTW9uaXRvciIsImFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyIiwiYWRkUmVjb25uZWN0TGlzdGVuZXIiLCJfc3Vic2NyaXB0aW9ucyIsIl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCIsIl9zeW5jaHJvbml6ZWQiLCJfc3luY2hyb25pemF0aW9uTGlzdGVuZXJzIiwiZ2V0QWNjb3VudEluZm9ybWF0aW9uIiwiZ2V0UG9zaXRpb25zIiwiZ2V0UG9zaXRpb24iLCJwb3NpdGlvbklkIiwiZ2V0T3JkZXJzIiwiZ2V0T3JkZXIiLCJvcmRlcklkIiwiZ2V0SGlzdG9yeU9yZGVyc0J5VGlja2V0IiwidGlja2V0IiwiZ2V0SGlzdG9yeU9yZGVyc0J5UG9zaXRpb24iLCJnZXRIaXN0b3J5T3JkZXJzQnlUaW1lUmFuZ2UiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwib2Zmc2V0IiwibGltaXQiLCJnZXREZWFsc0J5VGlja2V0IiwiZ2V0RGVhbHNCeVBvc2l0aW9uIiwiZ2V0RGVhbHNCeVRpbWVSYW5nZSIsInJlbW92ZUhpc3RvcnkiLCJjbGVhciIsInJlbW92ZUFwcGxpY2F0aW9uIiwiY3JlYXRlTWFya2V0QnV5T3JkZXIiLCJzeW1ib2wiLCJ2b2x1bWUiLCJzdG9wTG9zcyIsInRha2VQcm9maXQiLCJvcHRpb25zIiwidHJhZGUiLCJhY3Rpb25UeXBlIiwiX2dlbmVyYXRlU3RvcE9wdGlvbnMiLCJjcmVhdGVNYXJrZXRTZWxsT3JkZXIiLCJjcmVhdGVMaW1pdEJ1eU9yZGVyIiwib3BlblByaWNlIiwiY3JlYXRlTGltaXRTZWxsT3JkZXIiLCJjcmVhdGVTdG9wQnV5T3JkZXIiLCJjcmVhdGVTdG9wU2VsbE9yZGVyIiwiY3JlYXRlU3RvcExpbWl0QnV5T3JkZXIiLCJzdG9wTGltaXRQcmljZSIsImNyZWF0ZVN0b3BMaW1pdFNlbGxPcmRlciIsIm1vZGlmeVBvc2l0aW9uIiwiY2xvc2VQb3NpdGlvblBhcnRpYWxseSIsImNsb3NlUG9zaXRpb24iLCJjbG9zZUJ5Iiwib3Bwb3NpdGVQb3NpdGlvbklkIiwiY2xvc2VCeVBvc2l0aW9uSWQiLCJjbG9zZVBvc2l0aW9uc0J5U3ltYm9sIiwibW9kaWZ5T3JkZXIiLCJjYW5jZWxPcmRlciIsInJlY29ubmVjdCIsInN5bmNocm9uaXplIiwiaW5zdGFuY2VJbmRleCIsImluc3RhbmNlIiwiZ2V0SW5zdGFuY2VOdW1iZXIiLCJob3N0IiwiZ2V0SG9zdE5hbWUiLCJzdGFydGluZ0hpc3RvcnlPcmRlclRpbWUiLCJEYXRlIiwiTWF0aCIsIm1heCIsImdldFRpbWUiLCJsYXN0SGlzdG9yeU9yZGVyVGltZSIsInN0YXJ0aW5nRGVhbFRpbWUiLCJsYXN0RGVhbFRpbWUiLCJzeW5jaHJvbml6YXRpb25JZCIsInJhbmRvbXN0cmluZyIsImdlbmVyYXRlIiwiX2dldFN0YXRlIiwibGFzdFN5bmNocm9uaXphdGlvbklkIiwiaW5pdGlhbGl6ZSIsInN1YnNjcmliZSIsIl9jbG9zZWQiLCJlbnN1cmVTdWJzY3JpYmUiLCJzdWJzY3JpYmVUb01hcmtldERhdGEiLCJzdWJzY3JpcHRpb25zIiwidGltZW91dEluU2Vjb25kcyIsInRlcm1pbmFsU3RhdGUiLCJ3YWl0Rm9yUHJpY2UiLCJ1bnN1YnNjcmliZUZyb21NYXJrZXREYXRhIiwiZmlsdGVyIiwicyIsImZpbmQiLCJzMiIsInR5cGUiLCJsZW5ndGgiLCJvblN1YnNjcmlwdGlvbkRvd25ncmFkZWQiLCJ1cGRhdGVzIiwidW5zdWJzY3JpcHRpb25zIiwic3Vic2NyaXB0aW9uIiwiZm9yRWFjaCIsImludGVydmFsSW5NaWxsaWlzZWNvbmRzIiwiaW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyIsInN1YnNjcmliZWRTeW1ib2xzIiwiZ2V0U3ltYm9scyIsImdldFN5bWJvbFNwZWNpZmljYXRpb24iLCJnZXRTeW1ib2xQcmljZSIsImdldENhbmRsZSIsInRpbWVmcmFtZSIsImdldFRpY2siLCJnZXRCb29rIiwic2F2ZVVwdGltZSIsInVwdGltZSIsImxpc3RlbmVyIiwicHVzaCIsInJlbW92ZVN5bmNocm9uaXphdGlvbkxpc3RlbmVyIiwibCIsIm9uQ29ubmVjdGVkIiwicmVwbGljYXMiLCJrZXkiLCJzdGF0ZSIsInNob3VsZFN5bmNocm9uaXplIiwic3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kcyIsInN5bmNocm9uaXplZCIsIl9lbnN1cmVTeW5jaHJvbml6ZWQiLCJpbmRpY2VzIiwiaSIsImUiLCJpbmNsdWRlcyIsIm9uRGlzY29ubmVjdGVkIiwibGFzdERpc2Nvbm5lY3RlZFN5bmNocm9uaXphdGlvbklkIiwidW5kZWZpbmVkIiwiZGlzY29ubmVjdGVkIiwib25EZWFsU3luY2hyb25pemF0aW9uRmluaXNoZWQiLCJkZWFsc1N5bmNocm9uaXplZCIsIm9uT3JkZXJTeW5jaHJvbml6YXRpb25GaW5pc2hlZCIsIm9yZGVyc1N5bmNocm9uaXplZCIsIm9uQWNjb3VudEluZm9ybWF0aW9uVXBkYXRlZCIsImFjY291bnRJbmZvcm1hdGlvbiIsInByaWNlIiwicmVzb2x2ZSIsImNhdGNoIiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwidG9JU09TdHJpbmciLCJvblJlY29ubmVjdGVkIiwib25TdHJlYW1DbG9zZWQiLCJpc1N5bmNocm9uaXplZCIsInJlZHVjZSIsImFjYyIsIndhaXRTeW5jaHJvbml6ZWQiLCJvcHRzIiwiYXBwbGljYXRpb25QYXR0ZXJuIiwibm93IiwicmVzIiwic2V0VGltZW91dCIsIlRpbWVvdXRFcnJvciIsInRpbWVMZWZ0SW5TZWNvbmRzIiwiY2xvc2UiLCJ1bnN1YnNjcmliZSIsInJlbW92ZVJlY29ubmVjdExpc3RlbmVyIiwicmVtb3ZlIiwic3RvcCIsImhlYWx0aE1vbml0b3IiLCJ2YWx1ZSIsInN0b3BMb3NzVW5pdHMiLCJ1bml0cyIsInRha2VQcm9maXRVbml0cyIsInN5bmNocm9uaXphdGlvblJlc3VsdCIsImJpbmQiLCJtaW4iXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUE7OztBQUdlLE1BQU1BLGlCQUFOLFNBQWdDQyxpQ0FBaEMsQ0FBd0Q7O0FBRXJFOzs7Ozs7Ozs7QUFTQUMsY0FBWUMsZUFBWixFQUE2QkMsT0FBN0IsRUFBc0NDLGNBQXRDLEVBQXNEQyxrQkFBdEQsRUFBMEVDLGdCQUExRSxFQUE0RjtBQUMxRjtBQUNBLFNBQUtDLGdCQUFMLEdBQXdCTCxlQUF4QjtBQUNBLFNBQUtNLFFBQUwsR0FBZ0JMLE9BQWhCO0FBQ0EsU0FBS00sbUJBQUwsR0FBMkJKLGtCQUEzQjtBQUNBLFNBQUtLLGlCQUFMLEdBQXlCSixnQkFBekI7QUFDQSxTQUFLSyxjQUFMLEdBQXNCLElBQUlDLHVCQUFKLEVBQXRCO0FBQ0EsU0FBS0MsZUFBTCxHQUF1QlQsa0JBQWtCLElBQUlVLDhCQUFKLENBQXlCWCxRQUFRWSxFQUFqQyxFQUFxQ1YsbUJBQW1CVyxXQUF4RCxDQUF6QztBQUNBLFNBQUtDLGNBQUwsR0FBc0IsSUFBSUMsaUNBQUosQ0FBNEIsSUFBNUIsQ0FBdEI7QUFDQSxTQUFLWCxnQkFBTCxDQUFzQlksMEJBQXRCLENBQWlEaEIsUUFBUVksRUFBekQs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QUFpRDtBQUMvQ0EscUJBRCtDO0FBRS9DMEUsNEJBQW9CLEVBRjJCO0FBRy9DRiwyQkFBbUIsRUFINEI7QUFJL0NiLDJCQUFtQlUsU0FKNEI7QUFLL0NULCtDQUF1QyxDQUxRO0FBTS9DQyxzQkFBYyxLQU5pQztBQU8vQ08sMkNBQW1DQyxTQVBZO0FBUS9DcEQsK0JBQXVCb0QsU0FSd0I7QUFTL0NDLHNCQUFjO0FBVGlDLE9BQWpEO0FBV0Q7QUFDRCxXQUFPLEtBQUszSCxxQkFBTCxDQUEyQixLQUFLcUQsYUFBaEMsQ0FBUDtBQUNEOztBQTE2Qm9FO2tCQUFsRDVFLGlCIiwiZmlsZSI6Im1ldGFBcGlDb25uZWN0aW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVGVybWluYWxTdGF0ZSBmcm9tICcuL3Rlcm1pbmFsU3RhdGUnO1xuaW1wb3J0IE1lbW9yeUhpc3RvcnlTdG9yYWdlIGZyb20gJy4vbWVtb3J5SGlzdG9yeVN0b3JhZ2UnO1xuaW1wb3J0IFN5bmNocm9uaXphdGlvbkxpc3RlbmVyIGZyb20gJy4uL2NsaWVudHMvbWV0YUFwaS9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcic7XG5pbXBvcnQgVGltZW91dEVycm9yIGZyb20gJy4uL2NsaWVudHMvdGltZW91dEVycm9yJztcbmltcG9ydCByYW5kb21zdHJpbmcgZnJvbSAncmFuZG9tc3RyaW5nJztcbmltcG9ydCBDb25uZWN0aW9uSGVhbHRoTW9uaXRvciBmcm9tICcuL2Nvbm5lY3Rpb25IZWFsdGhNb25pdG9yJztcblxuLyoqXG4gKiBFeHBvc2VzIE1ldGFBcGkgTWV0YVRyYWRlciBBUEkgY29ubmVjdGlvbiB0byBjb25zdW1lcnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWV0YUFwaUNvbm5lY3Rpb24gZXh0ZW5kcyBTeW5jaHJvbml6YXRpb25MaXN0ZW5lciB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgTWV0YUFwaSBNZXRhVHJhZGVyIEFwaSBjb25uZWN0aW9uXG4gICAqIEBwYXJhbSB7TWV0YUFwaVdlYnNvY2tldENsaWVudH0gd2Vic29ja2V0Q2xpZW50IE1ldGFBcGkgd2Vic29ja2V0IGNsaWVudFxuICAgKiBAcGFyYW0ge01ldGF0cmFkZXJBY2NvdW50fSBhY2NvdW50IE1ldGFUcmFkZXIgYWNjb3VudCBpZCB0byBjb25uZWN0IHRvXG4gICAqIEBwYXJhbSB7SGlzdG9yeVN0b3JhZ2V9IGhpc3RvcnlTdG9yYWdlIHRlcm1pbmFsIGhpc3Rvcnkgc3RvcmFnZS4gQnkgZGVmYXVsdCBhbiBpbnN0YW5jZSBvZiBNZW1vcnlIaXN0b3J5U3RvcmFnZVxuICAgKiB3aWxsIGJlIHVzZWQuXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvblJlZ2lzdHJ5fSBjb25uZWN0aW9uUmVnaXN0cnkgbWV0YXRyYWRlciBhY2NvdW50IGNvbm5lY3Rpb24gcmVnaXN0cnlcbiAgICogQHBhcmFtIHtEYXRlfSBbaGlzdG9yeVN0YXJ0VGltZV0gaGlzdG9yeSBzdGFydCBzeW5jIHRpbWVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdlYnNvY2tldENsaWVudCwgYWNjb3VudCwgaGlzdG9yeVN0b3JhZ2UsIGNvbm5lY3Rpb25SZWdpc3RyeSwgaGlzdG9yeVN0YXJ0VGltZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50ID0gd2Vic29ja2V0Q2xpZW50O1xuICAgIHRoaXMuX2FjY291bnQgPSBhY2NvdW50O1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25SZWdpc3RyeSA9IGNvbm5lY3Rpb25SZWdpc3RyeTtcbiAgICB0aGlzLl9oaXN0b3J5U3RhcnRUaW1lID0gaGlzdG9yeVN0YXJ0VGltZTtcbiAgICB0aGlzLl90ZXJtaW5hbFN0YXRlID0gbmV3IFRlcm1pbmFsU3RhdGUoKTtcbiAgICB0aGlzLl9oaXN0b3J5U3RvcmFnZSA9IGhpc3RvcnlTdG9yYWdlIHx8IG5ldyBNZW1vcnlIaXN0b3J5U3RvcmFnZShhY2NvdW50LmlkLCBjb25uZWN0aW9uUmVnaXN0cnkuYXBwbGljYXRpb24pO1xuICAgIHRoaXMuX2hlYWx0aE1vbml0b3IgPSBuZXcgQ29ubmVjdGlvbkhlYWx0aE1vbml0b3IodGhpcyk7XG4gICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKGFjY291bnQuaWQsIHRoaXMpO1xuICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcihhY2NvdW50LmlkLCB0aGlzLl90ZXJtaW5hbFN0YXRlKTtcbiAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIoYWNjb3VudC5pZCwgdGhpcy5faGlzdG9yeVN0b3JhZ2UpO1xuICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcihhY2NvdW50LmlkLCB0aGlzLl9oZWFsdGhNb25pdG9yKTtcbiAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuYWRkUmVjb25uZWN0TGlzdGVuZXIodGhpcywgYWNjb3VudC5pZCk7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IHt9O1xuICAgIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4ID0ge307XG4gICAgdGhpcy5fc3luY2hyb25pemVkID0gZmFsc2U7XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzID0gW107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhY2NvdW50IGluZm9ybWF0aW9uIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmVhZFRyYWRpbmdUZXJtaW5hbFN0YXRlL3JlYWRBY2NvdW50SW5mb3JtYXRpb24vKS5cbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlckFjY291bnRJbmZvcm1hdGlvbj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggYWNjb3VudCBpbmZvcm1hdGlvblxuICAgKi9cbiAgZ2V0QWNjb3VudEluZm9ybWF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZ2V0QWNjb3VudEluZm9ybWF0aW9uKHRoaXMuX2FjY291bnQuaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgcG9zaXRpb25zIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmVhZFRyYWRpbmdUZXJtaW5hbFN0YXRlL3JlYWRQb3NpdGlvbnMvKS5cbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8TWV0YXRyYWRlclBvc2l0aW9uPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBhcnJheSBvZiBvcGVuIHBvc2l0aW9uc1xuICAgKi9cbiAgZ2V0UG9zaXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZ2V0UG9zaXRpb25zKHRoaXMuX2FjY291bnQuaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc3BlY2lmaWMgcG9zaXRpb24gKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZWFkVHJhZGluZ1Rlcm1pbmFsU3RhdGUvcmVhZFBvc2l0aW9uLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwb3NpdGlvbklkIHBvc2l0aW9uIGlkXG4gICAqIEByZXR1cm4ge1Byb21pc2U8TWV0YXRyYWRlclBvc2l0aW9uPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBNZXRhVHJhZGVyIHBvc2l0aW9uIGZvdW5kXG4gICAqL1xuICBnZXRQb3NpdGlvbihwb3NpdGlvbklkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5nZXRQb3NpdGlvbih0aGlzLl9hY2NvdW50LmlkLCBwb3NpdGlvbklkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG9wZW4gb3JkZXJzIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmVhZFRyYWRpbmdUZXJtaW5hbFN0YXRlL3JlYWRPcmRlcnMvKS5cbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxNZXRhdHJhZGVyT3JkZXI+Pn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBvcGVuIE1ldGFUcmFkZXIgb3JkZXJzXG4gICAqL1xuICBnZXRPcmRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5nZXRPcmRlcnModGhpcy5fYWNjb3VudC5pZCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBzcGVjaWZpYyBvcGVuIG9yZGVyIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmVhZFRyYWRpbmdUZXJtaW5hbFN0YXRlL3JlYWRPcmRlci8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3JkZXJJZCBvcmRlciBpZCAodGlja2V0IG51bWJlcilcbiAgICogQHJldHVybiB7UHJvbWlzZTxNZXRhdHJhZGVyT3JkZXI+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIG1ldGF0cmFkZXIgb3JkZXIgZm91bmRcbiAgICovXG4gIGdldE9yZGVyKG9yZGVySWQpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmdldE9yZGVyKHRoaXMuX2FjY291bnQuaWQsIG9yZGVySWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhpc3Rvcnkgb2YgY29tcGxldGVkIG9yZGVycyBmb3IgYSBzcGVjaWZpYyB0aWNrZXQgbnVtYmVyIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVIaXN0b3JpY2FsRGF0YS9yZWFkSGlzdG9yeU9yZGVyc0J5VGlja2V0LykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0aWNrZXQgdGlja2V0IG51bWJlciAob3JkZXIgaWQpXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJIaXN0b3J5T3JkZXJzPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCByZXF1ZXN0IHJlc3VsdHMgY29udGFpbmluZyBoaXN0b3J5IG9yZGVycyBmb3VuZFxuICAgKi9cbiAgZ2V0SGlzdG9yeU9yZGVyc0J5VGlja2V0KHRpY2tldCkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZ2V0SGlzdG9yeU9yZGVyc0J5VGlja2V0KHRoaXMuX2FjY291bnQuaWQsIHRpY2tldCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGlzdG9yeSBvZiBjb21wbGV0ZWQgb3JkZXJzIGZvciBhIHNwZWNpZmljIHBvc2l0aW9uIGlkIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVIaXN0b3JpY2FsRGF0YS9yZWFkSGlzdG9yeU9yZGVyc0J5UG9zaXRpb24vKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb25JZCBwb3NpdGlvbiBpZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVySGlzdG9yeU9yZGVycz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcmVxdWVzdCByZXN1bHRzIGNvbnRhaW5pbmcgaGlzdG9yeSBvcmRlcnMgZm91bmRcbiAgICovXG4gIGdldEhpc3RvcnlPcmRlcnNCeVBvc2l0aW9uKHBvc2l0aW9uSWQpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmdldEhpc3RvcnlPcmRlcnNCeVBvc2l0aW9uKHRoaXMuX2FjY291bnQuaWQsIHBvc2l0aW9uSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhpc3Rvcnkgb2YgY29tcGxldGVkIG9yZGVycyBmb3IgYSBzcGVjaWZpYyB0aW1lIHJhbmdlIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVIaXN0b3JpY2FsRGF0YS9yZWFkSGlzdG9yeU9yZGVyc0J5VGltZVJhbmdlLylcbiAgICogQHBhcmFtIHtEYXRlfSBzdGFydFRpbWUgc3RhcnQgb2YgdGltZSByYW5nZSwgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSB7RGF0ZX0gZW5kVGltZSBlbmQgb2YgdGltZSByYW5nZSwgZXhjbHVzaXZlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgcGFnaW5hdGlvbiBvZmZzZXQsIGRlZmF1bHQgaXMgMFxuICAgKiBAcGFyYW0ge051bWJlcn0gbGltaXQgcGFnaW5hdGlvbiBsaW1pdCwgZGVmYXVsdCBpcyAxMDAwXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJIaXN0b3J5T3JkZXJzPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCByZXF1ZXN0IHJlc3VsdHMgY29udGFpbmluZyBoaXN0b3J5IG9yZGVycyBmb3VuZFxuICAgKi9cbiAgZ2V0SGlzdG9yeU9yZGVyc0J5VGltZVJhbmdlKHN0YXJ0VGltZSwgZW5kVGltZSwgb2Zmc2V0ID0gMCwgbGltaXQgPSAxMDAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5nZXRIaXN0b3J5T3JkZXJzQnlUaW1lUmFuZ2UodGhpcy5fYWNjb3VudC5pZCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBvZmZzZXQsIGxpbWl0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGhpc3RvcnkgZGVhbHMgd2l0aCBhIHNwZWNpZmljIHRpY2tldCBudW1iZXIgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZXRyaWV2ZUhpc3RvcmljYWxEYXRhL3JlYWREZWFsc0J5VGlja2V0LykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0aWNrZXQgdGlja2V0IG51bWJlciAoZGVhbCBpZCBmb3IgTVQ1IG9yIG9yZGVyIGlkIGZvciBNVDQpXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJEZWFscz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcmVxdWVzdCByZXN1bHRzIGNvbnRhaW5pbmcgZGVhbHMgZm91bmRcbiAgICovXG4gIGdldERlYWxzQnlUaWNrZXQodGlja2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5nZXREZWFsc0J5VGlja2V0KHRoaXMuX2FjY291bnQuaWQsIHRpY2tldCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBoaXN0b3J5IGRlYWxzIGZvciBhIHNwZWNpZmljIHBvc2l0aW9uIGlkIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVIaXN0b3JpY2FsRGF0YS9yZWFkRGVhbHNCeVBvc2l0aW9uLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwb3NpdGlvbklkIHBvc2l0aW9uIGlkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJEZWFscz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcmVxdWVzdCByZXN1bHRzIGNvbnRhaW5pbmcgZGVhbHMgZm91bmRcbiAgICovXG4gIGdldERlYWxzQnlQb3NpdGlvbihwb3NpdGlvbklkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5nZXREZWFsc0J5UG9zaXRpb24odGhpcy5fYWNjb3VudC5pZCwgcG9zaXRpb25JZCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBoaXN0b3J5IGRlYWxzIHdpdGggZm9yIGEgc3BlY2lmaWMgdGltZSByYW5nZSAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlSGlzdG9yaWNhbERhdGEvcmVhZERlYWxzQnlUaW1lUmFuZ2UvKS5cbiAgICogQHBhcmFtIHtEYXRlfSBzdGFydFRpbWUgc3RhcnQgb2YgdGltZSByYW5nZSwgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSB7RGF0ZX0gZW5kVGltZSBlbmQgb2YgdGltZSByYW5nZSwgZXhjbHVzaXZlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgcGFnaW5hdGlvbiBvZmZzZXQsIGRlZmF1bHQgaXMgMFxuICAgKiBAcGFyYW0ge051bWJlcn0gbGltaXQgcGFnaW5hdGlvbiBsaW1pdCwgZGVmYXVsdCBpcyAxMDAwXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJEZWFscz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcmVxdWVzdCByZXN1bHRzIGNvbnRhaW5pbmcgZGVhbHMgZm91bmRcbiAgICovXG4gIGdldERlYWxzQnlUaW1lUmFuZ2Uoc3RhcnRUaW1lLCBlbmRUaW1lLCBvZmZzZXQgPSAwLCBsaW1pdCA9IDEwMDApIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmdldERlYWxzQnlUaW1lUmFuZ2UodGhpcy5fYWNjb3VudC5pZCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBvZmZzZXQsIGxpbWl0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIG9yZGVyIGFuZCB0cmFuc2FjdGlvbiBoaXN0b3J5IG9mIGEgc3BlY2lmaWVkIGFwcGxpY2F0aW9uIHNvIHRoYXQgaXQgY2FuIGJlIHN5bmNocm9uaXplZCBmcm9tIHNjcmF0Y2hcbiAgICogKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZW1vdmVIaXN0b3J5LykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbYXBwbGljYXRpb25dIGFwcGxpY2F0aW9uIHRvIHJlbW92ZSBoaXN0b3J5IGZvclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBoaXN0b3J5IGlzIGNsZWFyZWRcbiAgICovXG4gIHJlbW92ZUhpc3RvcnkoYXBwbGljYXRpb24pIHtcbiAgICB0aGlzLl9oaXN0b3J5U3RvcmFnZS5jbGVhcigpO1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVtb3ZlSGlzdG9yeSh0aGlzLl9hY2NvdW50LmlkLCBhcHBsaWNhdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBvcmRlciBhbmQgdHJhbnNhY3Rpb24gaGlzdG9yeSBvZiBhIHNwZWNpZmllZCBhcHBsaWNhdGlvbiBhbmQgcmVtb3ZlcyBhcHBsaWNhdGlvbiAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JlbW92ZUFwcGxpY2F0aW9uLykuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGhpc3RvcnkgaXMgY2xlYXJlZCBhbmQgYXBwbGljYXRpb24gaXMgcmVtb3ZlZFxuICAgKi9cbiAgcmVtb3ZlQXBwbGljYXRpb24oKSB7XG4gICAgdGhpcy5faGlzdG9yeVN0b3JhZ2UuY2xlYXIoKTtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJlbW92ZUFwcGxpY2F0aW9uKHRoaXMuX2FjY291bnQuaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbW1vbiB0cmFkZSBvcHRpb25zXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFRyYWRlT3B0aW9uc1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2NvbW1lbnRdIG9wdGlvbmFsIG9yZGVyIGNvbW1lbnQuIFRoZSBzdW0gb2YgdGhlIGxpbmUgbGVuZ3RocyBvZiB0aGUgY29tbWVudCBhbmQgdGhlXG4gICAqIGNsaWVudElkIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDI2LiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L2NsaWVudElkVXNhZ2UvXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbY2xpZW50SWRdIG9wdGlvbmFsIGNsaWVudC1hc3NpZ25lZCBpZC4gVGhlIGlkIHZhbHVlIGNhbiBiZSBhc3NpZ25lZCB3aGVuIHN1Ym1pdHRpbmcgYSB0cmFkZSBhbmRcbiAgICogd2lsbCBiZSBwcmVzZW50IG9uIHBvc2l0aW9uLCBoaXN0b3J5IG9yZGVycyBhbmQgaGlzdG9yeSBkZWFscyByZWxhdGVkIHRvIHRoZSB0cmFkZS4gWW91IGNhbiB1c2UgdGhpcyBmaWVsZCB0byBiaW5kXG4gICAqIHlvdXIgdHJhZGVzIHRvIG9iamVjdHMgaW4geW91ciBhcHBsaWNhdGlvbiBhbmQgdGhlbiB0cmFjayB0cmFkZSBwcm9ncmVzcy4gVGhlIHN1bSBvZiB0aGUgbGluZSBsZW5ndGhzIG9mIHRoZVxuICAgKiBjb21tZW50IGFuZCB0aGUgY2xpZW50SWQgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMjYuIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvY2xpZW50SWRVc2FnZS9cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFttYWdpY10gb3B0aW9uYWwgbWFnaWMgKGV4cGVydCBpZCkgbnVtYmVyLiBJZiBub3Qgc2V0IGRlZmF1bHQgdmFsdWUgc3BlY2lmaWVkIGluIGFjY291bnQgZW50aXR5XG4gICAqIHdpbGwgYmUgdXNlZC5cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzbGlwcGFnZV0gb3B0aW9uYWwgc2xpcHBhZ2UgaW4gcG9pbnRzLiBTaG91bGQgYmUgZ3JlYXRlciBvciBlcXVhbCB0byB6ZXJvLiBJbiBub3Qgc2V0LFxuICAgKiBkZWZhdWx0IHZhbHVlIHNwZWNpZmllZCBpbiBhY2NvdW50IGVudGl0eSB3aWxsIGJlIHVzZWQuIFNsaXBwYWdlIGlzIGlnbm9yZWQgaWYgZXhlY3V0aW9uIG1vZGUgc2V0IHRvXG4gICAqIFNZTUJPTF9UUkFERV9FWEVDVVRJT05fTUFSS0VUIGluIHN5bWJvbCBzcGVjaWZpY2F0aW9uLiBOb3QgdXNlZCBmb3IgY2xvc2UgYnkgb3JkZXJzLlxuICAgKi9cblxuICAvKipcbiAgICogTWFya2V0IHRyYWRlIG9wdGlvbnNcbiAgICogQHR5cGVkZWYge1RyYWRlT3B0aW9uc30gTWFya2V0VHJhZGVPcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8U3RyaW5nPn0gW2ZpbGxpbmdNb2Rlc10gb3B0aW9uYWwgYWxsb3dlZCBmaWxsaW5nIG1vZGVzIGluIHRoZSBvcmRlciBvZiBwcmlvcml0eS4gRGVmYXVsdCBpcyB0b1xuICAgKiBhbGxvdyBhbGwgZmlsbGluZyBtb2RlcyBhbmQgcHJlZmVyIE9SREVSX0ZJTExJTkdfRk9LIG92ZXIgT1JERVJfRklMTElOR19JT0MuIFNlZVxuICAgKiBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy90cmFkaW5nY29uc3RhbnRzL29yZGVycHJvcGVydGllcyNlbnVtX29yZGVyX3R5cGVfZmlsbGluZyBmb3IgZXh0cmFcbiAgICogZXhwbGFuYXRpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIFBlbmRpbmcgb3JkZXIgdHJhZGUgb3B0aW9uc1xuICAgKiBAdHlwZWRlZiB7VHJhZGVPcHRpb25zfSBQZW5kaW5nVHJhZGVPcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7RXhwaXJhdGlvbk9wdGlvbnN9IFtleHBpcmF0aW9uXSBvcHRpb25hbCBwZW5kaW5nIG9yZGVyIGV4cGlyYXRpb24gc2V0dGluZ3MuIFNlZSBQZW5kaW5nIG9yZGVyIGV4cGlyYXRpb25cbiAgICogc2V0dGluZ3Mgc2VjdGlvblxuICAgKi9cblxuICAvKipcbiAgICogUGVuZGluZyBvcmRlciBleHBpcmF0aW9uIHNldHRpbmdzXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IEV4cGlyYXRpb25PcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0eXBlIHBlbmRpbmcgb3JkZXIgZXhwaXJhdGlvbiB0eXBlLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvdHJhZGluZ2NvbnN0YW50cy9vcmRlcnByb3BlcnRpZXMjZW51bV9vcmRlcl90eXBlX3RpbWUgZm9yIHRoZSBsaXN0IG9mXG4gICAqIHBvc3NpYmxlIG9wdGlvbnMuIE1ldGFUcmFkZXI0IHBsYXRmb3JtIHN1cHBvcnRzIG9ubHkgT1JERVJfVElNRV9TUEVDSUZJRUQgZXhwaXJhdGlvbiB0eXBlLiBPbmUgb2YgT1JERVJfVElNRV9HVEMsXG4gICAqIE9SREVSX1RJTUVfREFZLCBPUkRFUl9USU1FX1NQRUNJRklFRCwgT1JERVJfVElNRV9TUEVDSUZJRURfREFZXG4gICAqIEBwcm9wZXJ0eSB7RGF0ZX0gW3RpbWVdIG9wdGlvbmFsIHBlbmRpbmcgb3JkZXIgZXhwaXJhdGlvbiB0aW1lLiBJZ25vcmVkIGlmIGV4cGlyYXRpb24gdHlwZSBpcyBub3Qgb25lIG9mXG4gICAqIE9SREVSX1RJTUVfREFZIG9yIE9SREVSX1RJTUVfU1BFQ0lGSUVEXG4gICAqL1xuXG4gIC8qKlxuICAgKiBTdG9wIG9wdGlvbnNcbiAgICogQHR5cGVkZWYge09iamVjdH0gU3RvcE9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHZhbHVlIHN0b3AgKFNMIG9yIFRQKSB2YWx1ZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdW5pdHMgc3RvcCB1bml0cy4gQUJTT0xVVEVfUFJJQ0UgbWVhbnMgdGhlIHRoYXQgdGhlIHZhbHVlIG9mIHZhbHVlIGZpZWxkIGlzIGEgZmluYWwgc3RvcCB2YWx1ZS5cbiAgICogUkVMQVRJVkVfKiBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmaWVsZCB2YWx1ZSBjb250YWlucyByZWxhdGl2ZSBzdG9wIGV4cHJlc3NlZCBlaXRoZXIgaW4gcHJpY2UsIHBvaW50cywgYWNjb3VudFxuICAgKiBjdXJyZW5jeSBvciBiYWxhbmNlIHBlcmNlbnRhZ2UuIERlZmF1bHQgaXMgQUJTT0xVVEVfUFJJQ0UuIEFsbG93ZWQgdmFsdWVzIGFyZSBBQlNPTFVURV9QUklDRSwgUkVMQVRJVkVfUFJJQ0UsXG4gICAqIFJFTEFUSVZFX1BPSU5UUywgUkVMQVRJVkVfQ1VSUkVOQ1ksIFJFTEFUSVZFX0JBTEFOQ0VfUEVSQ0VOVEFHRVxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG1hcmtldCBidXkgb3JkZXIgKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS90cmFkZS8pLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB0cmFkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdm9sdW1lIG9yZGVyIHZvbHVtZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3N0b3BMb3NzXSBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFt0YWtlUHJvZml0XSB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcGFyYW0ge01hcmtldFRyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjcmVhdGVNYXJrZXRCdXlPcmRlcihzeW1ib2wsIHZvbHVtZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQudHJhZGUodGhpcy5fYWNjb3VudC5pZCwgT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ09SREVSX1RZUEVfQlVZJywgc3ltYm9sLCB2b2x1bWV9LFxuICAgICAgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCksIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbWFya2V0IHNlbGwgb3JkZXIgKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS90cmFkZS8pLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB0cmFkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdm9sdW1lIG9yZGVyIHZvbHVtZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3N0b3BMb3NzXSBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFt0YWtlUHJvZml0XSB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcGFyYW0ge01hcmtldFRyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjcmVhdGVNYXJrZXRTZWxsT3JkZXIoc3ltYm9sLCB2b2x1bWUsIHN0b3BMb3NzLCB0YWtlUHJvZml0LCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LnRyYWRlKHRoaXMuX2FjY291bnQuaWQsIE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9UWVBFX1NFTEwnLCBzeW1ib2wsIHZvbHVtZX0sXG4gICAgICB0aGlzLl9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSwgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBsaW1pdCBidXkgb3JkZXIgKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS90cmFkZS8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB0cmFkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdm9sdW1lIG9yZGVyIHZvbHVtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb3BlblByaWNlIG9yZGVyIGxpbWl0IHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbc3RvcExvc3NdIHN0b3AgbG9zcyBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3Rha2VQcm9maXRdIHRha2UgcHJvZml0IHByaWNlXG4gICAqIEBwYXJhbSB7UGVuZGluZ1RyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjcmVhdGVMaW1pdEJ1eU9yZGVyKHN5bWJvbCwgdm9sdW1lLCBvcGVuUHJpY2UsIHN0b3BMb3NzLCB0YWtlUHJvZml0LCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LnRyYWRlKHRoaXMuX2FjY291bnQuaWQsIE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9UWVBFX0JVWV9MSU1JVCcsIHN5bWJvbCxcbiAgICAgIHZvbHVtZSwgb3BlblByaWNlfSwgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCksIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbGltaXQgc2VsbCBvcmRlciAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3RyYWRlLykuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHRyYWRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWUgb3JkZXIgdm9sdW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGVuUHJpY2Ugb3JkZXIgbGltaXQgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFtzdG9wTG9zc10gc3RvcCBsb3NzIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbdGFrZVByb2ZpdF0gdGFrZSBwcm9maXQgcHJpY2VcbiAgICogQHBhcmFtIHtQZW5kaW5nVHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNyZWF0ZUxpbWl0U2VsbE9yZGVyKHN5bWJvbCwgdm9sdW1lLCBvcGVuUHJpY2UsIHN0b3BMb3NzLCB0YWtlUHJvZml0LCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LnRyYWRlKHRoaXMuX2FjY291bnQuaWQsIE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9UWVBFX1NFTExfTElNSVQnLCBzeW1ib2wsXG4gICAgICB2b2x1bWUsIG9wZW5QcmljZX0sIHRoaXMuX2dlbmVyYXRlU3RvcE9wdGlvbnMoc3RvcExvc3MsIHRha2VQcm9maXQpLCBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHN0b3AgYnV5IG9yZGVyIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvdHJhZGUvKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gdHJhZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZvbHVtZSBvcmRlciB2b2x1bWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wZW5QcmljZSBvcmRlciBzdG9wIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbc3RvcExvc3NdIHN0b3AgbG9zcyBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3Rha2VQcm9maXRdIHRha2UgcHJvZml0IHByaWNlXG4gICAqIEBwYXJhbSB7UGVuZGluZ1RyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjcmVhdGVTdG9wQnV5T3JkZXIoc3ltYm9sLCB2b2x1bWUsIG9wZW5QcmljZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQudHJhZGUodGhpcy5fYWNjb3VudC5pZCwgT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ09SREVSX1RZUEVfQlVZX1NUT1AnLCBzeW1ib2wsXG4gICAgICB2b2x1bWUsIG9wZW5QcmljZX0sIHRoaXMuX2dlbmVyYXRlU3RvcE9wdGlvbnMoc3RvcExvc3MsIHRha2VQcm9maXQpLCBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHN0b3Agc2VsbCBvcmRlciAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3RyYWRlLykuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHRyYWRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWUgb3JkZXIgdm9sdW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGVuUHJpY2Ugb3JkZXIgc3RvcCBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3N0b3BMb3NzXSBzdG9wIGxvc3MgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFt0YWtlUHJvZml0XSB0YWtlIHByb2ZpdCBwcmljZVxuICAgKiBAcGFyYW0ge1BlbmRpbmdUcmFkZU9wdGlvbnN9IG9wdGlvbnMgb3B0aW9uYWwgdHJhZGUgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgY3JlYXRlU3RvcFNlbGxPcmRlcihzeW1ib2wsIHZvbHVtZSwgb3BlblByaWNlLCBzdG9wTG9zcywgdGFrZVByb2ZpdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC50cmFkZSh0aGlzLl9hY2NvdW50LmlkLCBPYmplY3QuYXNzaWduKHthY3Rpb25UeXBlOiAnT1JERVJfVFlQRV9TRUxMX1NUT1AnLCBzeW1ib2wsXG4gICAgICB2b2x1bWUsIG9wZW5QcmljZX0sIHRoaXMuX2dlbmVyYXRlU3RvcE9wdGlvbnMoc3RvcExvc3MsIHRha2VQcm9maXQpLCBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHN0b3AgbGltaXQgYnV5IG9yZGVyIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvdHJhZGUvKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gdHJhZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZvbHVtZSBvcmRlciB2b2x1bWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wZW5QcmljZSBvcmRlciBzdG9wIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdG9wTGltaXRQcmljZSB0aGUgbGltaXQgb3JkZXIgcHJpY2UgZm9yIHRoZSBzdG9wIGxpbWl0IG9yZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbc3RvcExvc3NdIHN0b3AgbG9zcyBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3Rha2VQcm9maXRdIHRha2UgcHJvZml0IHByaWNlXG4gICAqIEBwYXJhbSB7UGVuZGluZ1RyYWRlT3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCB0cmFkZSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjcmVhdGVTdG9wTGltaXRCdXlPcmRlcihzeW1ib2wsIHZvbHVtZSwgb3BlblByaWNlLCBzdG9wTGltaXRQcmljZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQudHJhZGUodGhpcy5fYWNjb3VudC5pZCwgT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ09SREVSX1RZUEVfQlVZX1NUT1BfTElNSVQnLFxuICAgICAgc3ltYm9sLCB2b2x1bWUsIG9wZW5QcmljZSwgc3RvcExpbWl0UHJpY2V9LCB0aGlzLl9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSwgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzdG9wIGxpbWl0IHNlbGwgb3JkZXIgKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS90cmFkZS8pLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byB0cmFkZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdm9sdW1lIG9yZGVyIHZvbHVtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb3BlblByaWNlIG9yZGVyIHN0b3AgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0b3BMaW1pdFByaWNlIHRoZSBsaW1pdCBvcmRlciBwcmljZSBmb3IgdGhlIHN0b3AgbGltaXQgb3JkZXJcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFtzdG9wTG9zc10gc3RvcCBsb3NzIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbdGFrZVByb2ZpdF0gdGFrZSBwcm9maXQgcHJpY2VcbiAgICogQHBhcmFtIHtQZW5kaW5nVHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNyZWF0ZVN0b3BMaW1pdFNlbGxPcmRlcihzeW1ib2wsIHZvbHVtZSwgb3BlblByaWNlLCBzdG9wTGltaXRQcmljZSwgc3RvcExvc3MsIHRha2VQcm9maXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQudHJhZGUodGhpcy5fYWNjb3VudC5pZCwgT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ09SREVSX1RZUEVfU0VMTF9TVE9QX0xJTUlUJyxcbiAgICAgIHN5bWJvbCwgdm9sdW1lLCBvcGVuUHJpY2UsIHN0b3BMaW1pdFByaWNlfSwgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCksIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZmllcyBhIHBvc2l0aW9uIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvdHJhZGUvKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uSWQgcG9zaXRpb24gaWQgdG8gbW9kaWZ5XG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbc3RvcExvc3NdIHN0b3AgbG9zcyBwcmljZVxuICAgKiBAcGFyYW0ge251bWJlcnxTdG9wT3B0aW9uc30gW3Rha2VQcm9maXRdIHRha2UgcHJvZml0IHByaWNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBtb2RpZnlQb3NpdGlvbihwb3NpdGlvbklkLCBzdG9wTG9zcywgdGFrZVByb2ZpdCkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQudHJhZGUodGhpcy5fYWNjb3VudC5pZCwgT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ1BPU0lUSU9OX01PRElGWScsIHBvc2l0aW9uSWR9LFxuICAgICAgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJ0aWFsbHkgY2xvc2VzIGEgcG9zaXRpb24gKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS90cmFkZS8pLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcG9zaXRpb25JZCBwb3NpdGlvbiBpZCB0byBtb2RpZnlcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZvbHVtZSB2b2x1bWUgdG8gY2xvc2VcbiAgICogQHBhcmFtIHtNYXJrZXRUcmFkZU9wdGlvbnN9IG9wdGlvbnMgb3B0aW9uYWwgdHJhZGUgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgY2xvc2VQb3NpdGlvblBhcnRpYWxseShwb3NpdGlvbklkLCB2b2x1bWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQudHJhZGUodGhpcy5fYWNjb3VudC5pZCwgT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ1BPU0lUSU9OX1BBUlRJQUwnLCBwb3NpdGlvbklkLFxuICAgICAgdm9sdW1lfSwgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZ1bGx5IGNsb3NlcyBhIHBvc2l0aW9uIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvdHJhZGUvKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uSWQgcG9zaXRpb24gaWQgdG8gbW9kaWZ5XG4gICAqIEBwYXJhbSB7TWFya2V0VHJhZGVPcHRpb25zfSBvcHRpb25zIG9wdGlvbmFsIHRyYWRlIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIGNsb3NlUG9zaXRpb24ocG9zaXRpb25JZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC50cmFkZSh0aGlzLl9hY2NvdW50LmlkLCBPYmplY3QuYXNzaWduKHthY3Rpb25UeXBlOiAnUE9TSVRJT05fQ0xPU0VfSUQnLCBwb3NpdGlvbklkfSxcbiAgICAgIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdWxseSBjbG9zZXMgYSBwb3NpdGlvbiAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3RyYWRlLykuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbklkIHBvc2l0aW9uIGlkIHRvIGNsb3NlIGJ5IG9wcG9zaXRlIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHBvc2l0ZVBvc2l0aW9uSWQgb3Bwb3NpdGUgcG9zaXRpb24gaWQgdG8gY2xvc2VcbiAgICogQHBhcmFtIHtNYXJrZXRUcmFkZU9wdGlvbnN9IG9wdGlvbnMgb3B0aW9uYWwgdHJhZGUgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgY2xvc2VCeShwb3NpdGlvbklkLCBvcHBvc2l0ZVBvc2l0aW9uSWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQudHJhZGUodGhpcy5fYWNjb3VudC5pZCwgT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ1BPU0lUSU9OX0NMT1NFX0JZJywgcG9zaXRpb25JZCxcbiAgICAgIGNsb3NlQnlQb3NpdGlvbklkOiBvcHBvc2l0ZVBvc2l0aW9uSWR9LCBvcHRpb25zIHx8IHt9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHBvc2l0aW9ucyBieSBhIHN5bWJvbChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvdHJhZGUvKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gdHJhZGVcbiAgICogQHBhcmFtIHtNYXJrZXRUcmFkZU9wdGlvbnN9IG9wdGlvbnMgb3B0aW9uYWwgdHJhZGUgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgY2xvc2VQb3NpdGlvbnNCeVN5bWJvbChzeW1ib2wsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQudHJhZGUodGhpcy5fYWNjb3VudC5pZCwgT2JqZWN0LmFzc2lnbih7YWN0aW9uVHlwZTogJ1BPU0lUSU9OU19DTE9TRV9TWU1CT0wnLCBzeW1ib2x9LFxuICAgICAgb3B0aW9ucyB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmaWVzIGEgcGVuZGluZyBvcmRlciAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3RyYWRlLykuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmRlcklkIG9yZGVyIGlkICh0aWNrZXQgbnVtYmVyKVxuICAgKiBAcGFyYW0ge251bWJlcn0gb3BlblByaWNlIG9yZGVyIHN0b3AgcHJpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ8U3RvcE9wdGlvbnN9IFtzdG9wTG9zc10gc3RvcCBsb3NzIHByaWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfFN0b3BPcHRpb25zfSBbdGFrZVByb2ZpdF0gdGFrZSBwcm9maXQgcHJpY2VcbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhZGVSZXNwb25zZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJhZGUgcmVzdWx0XG4gICAqIEB0aHJvd3Mge1RyYWRlRXJyb3J9IG9uIHRyYWRlIGVycm9yLCBjaGVjayBlcnJvciBwcm9wZXJ0aWVzIGZvciBlcnJvciBjb2RlIGRldGFpbHNcbiAgICovXG4gIG1vZGlmeU9yZGVyKG9yZGVySWQsIG9wZW5QcmljZSwgc3RvcExvc3MsIHRha2VQcm9maXQpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LnRyYWRlKHRoaXMuX2FjY291bnQuaWQsIE9iamVjdC5hc3NpZ24oe2FjdGlvblR5cGU6ICdPUkRFUl9NT0RJRlknLCBvcmRlcklkLCBvcGVuUHJpY2V9LFxuICAgICAgdGhpcy5fZ2VuZXJhdGVTdG9wT3B0aW9ucyhzdG9wTG9zcywgdGFrZVByb2ZpdCkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIG9yZGVyIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvdHJhZGUvKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yZGVySWQgb3JkZXIgaWQgKHRpY2tldCBudW1iZXIpXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICBjYW5jZWxPcmRlcihvcmRlcklkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC50cmFkZSh0aGlzLl9hY2NvdW50LmlkLCB7YWN0aW9uVHlwZTogJ09SREVSX0NBTkNFTCcsIG9yZGVySWR9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvbm5lY3RzIHRvIHRoZSBNZXRhdHJhZGVyIHRlcm1pbmFsIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmVjb25uZWN0LykuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gcmVjb25uZWN0aW9uIHN0YXJ0ZWRcbiAgICovXG4gIHJlY29ubmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJlY29ubmVjdCh0aGlzLl9hY2NvdW50LmlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0cyB0aGUgdGVybWluYWwgdG8gc3RhcnQgc3luY2hyb25pemF0aW9uIHByb2Nlc3NcbiAgICogKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L3N5bmNocm9uaXppbmcvc3luY2hyb25pemUvKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbnN0YW5jZSBpbmRleFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN5bmNocm9uaXphdGlvbiBzdGFydGVkXG4gICAqL1xuICBhc3luYyBzeW5jaHJvbml6ZShpbnN0YW5jZUluZGV4KSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmdldEluc3RhbmNlTnVtYmVyKGluc3RhbmNlSW5kZXgpO1xuICAgIGNvbnN0IGhvc3QgPSB0aGlzLmdldEhvc3ROYW1lKGluc3RhbmNlSW5kZXgpO1xuICAgIGxldCBzdGFydGluZ0hpc3RvcnlPcmRlclRpbWUgPSBuZXcgRGF0ZShNYXRoLm1heChcbiAgICAgICh0aGlzLl9oaXN0b3J5U3RhcnRUaW1lIHx8IG5ldyBEYXRlKDApKS5nZXRUaW1lKCksXG4gICAgICAoYXdhaXQgdGhpcy5faGlzdG9yeVN0b3JhZ2UubGFzdEhpc3RvcnlPcmRlclRpbWUoaW5zdGFuY2UpKS5nZXRUaW1lKClcbiAgICApKTtcbiAgICBsZXQgc3RhcnRpbmdEZWFsVGltZSA9IG5ldyBEYXRlKE1hdGgubWF4KFxuICAgICAgKHRoaXMuX2hpc3RvcnlTdGFydFRpbWUgfHwgbmV3IERhdGUoMCkpLmdldFRpbWUoKSxcbiAgICAgIChhd2FpdCB0aGlzLl9oaXN0b3J5U3RvcmFnZS5sYXN0RGVhbFRpbWUoaW5zdGFuY2UpKS5nZXRUaW1lKClcbiAgICApKTtcbiAgICBsZXQgc3luY2hyb25pemF0aW9uSWQgPSByYW5kb21zdHJpbmcuZ2VuZXJhdGUoMzIpO1xuICAgIHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpLmxhc3RTeW5jaHJvbml6YXRpb25JZCA9IHN5bmNocm9uaXphdGlvbklkO1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQuc3luY2hyb25pemUodGhpcy5fYWNjb3VudC5pZCwgaW5zdGFuY2UsIGhvc3QsIHN5bmNocm9uaXphdGlvbklkLFxuICAgICAgc3RhcnRpbmdIaXN0b3J5T3JkZXJUaW1lLCBzdGFydGluZ0RlYWxUaW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBtZXRhIGFwaSBjb25uZWN0aW9uXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBtZXRhIGFwaSBjb25uZWN0aW9uIGlzIGluaXRpYWxpemVkXG4gICAqL1xuICBhc3luYyBpbml0aWFsaXplKCkge1xuICAgIGF3YWl0IHRoaXMuX2hpc3RvcnlTdG9yYWdlLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWF0ZXMgc3Vic2NyaXB0aW9uIHRvIE1ldGFUcmFkZXIgdGVybWluYWxcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBzdWJzY3JpcHRpb24gaXMgaW5pdGlhdGVkXG4gICAqL1xuICBhc3luYyBzdWJzY3JpYmUoKSB7XG4gICAgaWYoIXRoaXMuX2Nsb3NlZCkge1xuICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmVuc3VyZVN1YnNjcmliZSh0aGlzLl9hY2NvdW50LmlkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlcyBvbiBtYXJrZXQgZGF0YSBvZiBzcGVjaWZpZWQgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9tYXJrZXREYXRhU3RyZWFtaW5nL3N1YnNjcmliZVRvTWFya2V0RGF0YS8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3ltYm9sIHN5bWJvbCAoZS5nLiBjdXJyZW5jeSBwYWlyIG9yIGFuIGluZGV4KVxuICAgKiBAcGFyYW0ge0FycmF5PE1hcmtldERhdGFTdWJzY3JpcHRpb24+fSBzdWJzY3JpcHRpb25zIGFycmF5IG9mIG1hcmtldCBkYXRhIHN1YnNjcmlwdGlvbiB0byBjcmVhdGUgb3IgdXBkYXRlLiBQbGVhc2VcbiAgICogbm90ZSB0aGF0IHRoaXMgZmVhdHVyZSBpcyBub3QgZnVsbHkgaW1wbGVtZW50ZWQgb24gc2VydmVyLXNpZGUgeWV0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnN0YW5jZUluZGV4IGluc3RhbmNlIGluZGV4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dEluU2Vjb25kc10gdGltZW91dCB0byB3YWl0IGZvciBwcmljZXMgaW4gc2Vjb25kcywgZGVmYXVsdCBpcyAzMFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN1YnNjcmlwdGlvbiByZXF1ZXN0IHdhcyBwcm9jZXNzZWRcbiAgICovXG4gIGFzeW5jIHN1YnNjcmliZVRvTWFya2V0RGF0YShzeW1ib2wsIHN1YnNjcmlwdGlvbnMsIGluc3RhbmNlSW5kZXgsIHRpbWVvdXRJblNlY29uZHMpIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zW3N5bWJvbF0gPSB7c3Vic2NyaXB0aW9uc307XG4gICAgYXdhaXQgdGhpcy5fd2Vic29ja2V0Q2xpZW50LnN1YnNjcmliZVRvTWFya2V0RGF0YSh0aGlzLl9hY2NvdW50LmlkLCBpbnN0YW5jZUluZGV4LCBzeW1ib2wsIHN1YnNjcmlwdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLnRlcm1pbmFsU3RhdGUud2FpdEZvclByaWNlKHN5bWJvbCwgdGltZW91dEluU2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmVzIGZyb20gbWFya2V0IGRhdGEgb2Ygc3BlY2lmaWVkIHN5bWJvbCAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvbWFya2V0RGF0YVN0cmVhbWluZy91bnN1YnNjcmliZUZyb21NYXJrZXREYXRhLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIChlLmcuIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEBwYXJhbSB7QXJyYXk8TWFya2V0RGF0YVVuc3Vic2NyaXB0aW9uPn0gc3Vic2NyaXB0aW9ucyBhcnJheSBvZiBzdWJzY3JpcHRpb25zIHRvIGNhbmNlbFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VJbmRleCBpbnN0YW5jZSBpbmRleFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHVuc3Vic2NyaXB0aW9uIHJlcXVlc3Qgd2FzIHByb2Nlc3NlZFxuICAgKi9cbiAgdW5zdWJzY3JpYmVGcm9tTWFya2V0RGF0YShzeW1ib2wsIHN1YnNjcmlwdGlvbnMsIGluc3RhbmNlSW5kZXgpIHtcbiAgICBpZiAoIXN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzY3JpcHRpb25zW3N5bWJvbF07XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zdWJzY3JpcHRpb25zW3N5bWJvbF0pIHtcbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNbc3ltYm9sXS5zdWJzY3JpcHRpb25zID0gdGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdLnN1YnNjcmlwdGlvbnNcbiAgICAgICAgLmZpbHRlcihzID0+ICFzdWJzY3JpcHRpb25zLmZpbmQoczIgPT4gcy50eXBlID09PSBzMi50eXBlKSk7XG4gICAgICBpZiAoIXRoaXMuX3N1YnNjcmlwdGlvbnNbc3ltYm9sXS5zdWJzY3JpcHRpb25zLmxlbmd0aCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LnVuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEodGhpcy5fYWNjb3VudC5pZCwgaW5zdGFuY2VJbmRleCwgc3ltYm9sLCBzdWJzY3JpcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gc3Vic2NyaXB0aW9uIGRvd25ncmFkZSBoYXMgb2NjdXJyZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gdXBkYXRlIHN1YnNjcmlwdGlvbnMgZm9yXG4gICAqIEBwYXJhbSB7QXJyYXk8TWFya2V0RGF0YVN1YnNjcmlwdGlvbj59IHVwZGF0ZXMgYXJyYXkgb2YgbWFya2V0IGRhdGEgc3Vic2NyaXB0aW9uIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0ge0FycmF5PE1hcmtldERhdGFVbnN1YnNjcmlwdGlvbj59IHVuc3Vic2NyaXB0aW9ucyBhcnJheSBvZiBzdWJzY3JpcHRpb25zIHRvIGNhbmNlbFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIGFzeW5jIG9uU3Vic2NyaXB0aW9uRG93bmdyYWRlZChpbnN0YW5jZUluZGV4LCBzeW1ib2wsIHVwZGF0ZXMsIHVuc3Vic2NyaXB0aW9ucykge1xuICAgIGxldCBzdWJzY3JpcHRpb25zID0gdGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdO1xuICAgIGlmICh1bnN1YnNjcmlwdGlvbnMgJiYgdW5zdWJzY3JpcHRpb25zLmxlbmd0aCkge1xuICAgICAgaWYgKHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgZm9yIChsZXQgc3Vic2NyaXB0aW9uIG9mIHVuc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbnMgPSBzdWJzY3JpcHRpb25zLmZpbHRlcihzID0+IHMudHlwZSA9PT0gc3Vic2NyaXB0aW9uLnR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEoc3ltYm9sLCB1bnN1YnNjcmlwdGlvbnMpO1xuICAgIH1cbiAgICBpZiAodXBkYXRlcyAmJiB1cGRhdGVzLmxlbmd0aCkge1xuICAgICAgaWYgKHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgZm9yIChsZXQgc3Vic2NyaXB0aW9uIG9mIHVwZGF0ZXMpIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb25zLmZpbHRlcihzID0+IHMudHlwZSA9PT0gc3Vic2NyaXB0aW9uLnR5cGUpXG4gICAgICAgICAgICAuZm9yRWFjaChzID0+IHMuaW50ZXJ2YWxJbk1pbGxpaXNlY29uZHMgPSBzdWJzY3JpcHRpb24uaW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuc3Vic2NyaWJlVG9NYXJrZXREYXRhKHN5bWJvbCwgdXBkYXRlcyk7XG4gICAgfVxuICAgIGlmIChzdWJzY3JpcHRpb25zICYmICFzdWJzY3JpcHRpb25zLmxlbmd0aCkge1xuICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbnNbc3ltYm9sXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBsaXN0IG9mIHRoZSBzeW1ib2xzIGNvbm5lY3Rpb24gaXMgc3Vic2NyaWJlZCB0b1xuICAgKiBAcmV0dXJucyB7QXJyYXk8U3RyaW5nPn0gbGlzdCBvZiB0aGUgc3ltYm9scyBjb25uZWN0aW9uIGlzIHN1YnNjcmliZWQgdG9cbiAgICovXG4gIGdldCBzdWJzY3JpYmVkU3ltYm9scygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fc3Vic2NyaXB0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBzdWJzY3JpcHRpb25zIGZvciBhIHN5bWJvbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byByZXRyaWV2ZSBzdWJzY3JpcHRpb25zIGZvclxuICAgKiBAcmV0dXJucyB7QXJyYXk8TWFya2V0RGF0YVN1YnNjcmlwdGlvbj59IGxpc3Qgb2YgbWFya2V0IGRhdGEgc3Vic2NyaXB0aW9ucyBmb3IgdGhlIHN5bWJvbFxuICAgKi9cbiAgc3Vic2NyaXB0aW9ucyhzeW1ib2wpIHtcbiAgICByZXR1cm4gKHRoaXMuX3N1YnNjcmlwdGlvbnNbc3ltYm9sXSB8fCB7fSkuc3Vic2NyaXB0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYXZhaWxhYmxlIHN5bWJvbHMgZm9yIGFuIGFjY291bnQgKHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L2FwaS9yZXRyaWV2ZU1hcmtldERhdGEvcmVhZFN5bWJvbHMvKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gcmV0cmlldmUgc3ltYm9scyBmb3JcbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8c3RyaW5nPj59IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBzeW1ib2xzIGFyZSByZXRyaWV2ZWRcbiAgICovXG4gIGdldFN5bWJvbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5nZXRTeW1ib2xzKHRoaXMuX2FjY291bnQuaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBzcGVjaWZpY2F0aW9uIGZvciBhIHN5bWJvbCAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlTWFya2V0RGF0YS9yZWFkU3ltYm9sU3BlY2lmaWNhdGlvbi8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byByZXRyaWV2ZSBzcGVjaWZpY2F0aW9uIGZvclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVyU3ltYm9sU3BlY2lmaWNhdGlvbj59IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBzcGVjaWZpY2F0aW9uIGlzIHJldHJpZXZlZFxuICAgKi9cbiAgZ2V0U3ltYm9sU3BlY2lmaWNhdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmdldFN5bWJvbFNwZWNpZmljYXRpb24odGhpcy5fYWNjb3VudC5pZCwgc3ltYm9sKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgbGF0ZXN0IHByaWNlIGZvciBhIHN5bWJvbCAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlTWFya2V0RGF0YS9yZWFkU3ltYm9sUHJpY2UvKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gcmV0cmlldmUgcHJpY2UgZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJTeW1ib2xQcmljZT59IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBwcmljZSBpcyByZXRyaWV2ZWRcbiAgICovXG4gIGdldFN5bWJvbFByaWNlKHN5bWJvbCkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZ2V0U3ltYm9sUHJpY2UodGhpcy5fYWNjb3VudC5pZCwgc3ltYm9sKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgbGF0ZXN0IGNhbmRsZSBmb3IgYSBzeW1ib2wgYW5kIHRpbWVmcmFtZSAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlTWFya2V0RGF0YS9yZWFkQ2FuZGxlLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIGNhbmRsZSBmb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRpbWVmcmFtZSBkZWZpbmVzIHRoZSB0aW1lZnJhbWUgYWNjb3JkaW5nIHRvIHdoaWNoIHRoZSBjYW5kbGUgbXVzdCBiZSBnZW5lcmF0ZWQuIEFsbG93ZWQgdmFsdWVzIGZvclxuICAgKiBNVDUgYXJlIDFtLCAybSwgM20sIDRtLCA1bSwgNm0sIDEwbSwgMTJtLCAxNW0sIDIwbSwgMzBtLCAxaCwgMmgsIDNoLCA0aCwgNmgsIDhoLCAxMmgsIDFkLCAxdywgMW1uLiBBbGxvd2VkIHZhbHVlc1xuICAgKiBmb3IgTVQ0IGFyZSAxbSwgNW0sIDE1bSAzMG0sIDFoLCA0aCwgMWQsIDF3LCAxbW5cbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlckNhbmRsZT59IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBjYW5kbGUgaXMgcmV0cmlldmVkXG4gICAqL1xuICBnZXRDYW5kbGUoc3ltYm9sLCB0aW1lZnJhbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmdldENhbmRsZSh0aGlzLl9hY2NvdW50LmlkLCBzeW1ib2wsIHRpbWVmcmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGxhdGVzdCB0aWNrIGZvciBhIHN5bWJvbCAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC93ZWJzb2NrZXQvYXBpL3JldHJpZXZlTWFya2V0RGF0YS9yZWFkVGljay8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byByZXRyaWV2ZSB0aWNrIGZvclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVyVGljaz59IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aWNrIGlzIHJldHJpZXZlZFxuICAgKi9cbiAgZ2V0VGljayhzeW1ib2wpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmdldFRpY2sodGhpcy5fYWNjb3VudC5pZCwgc3ltYm9sKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgbGF0ZXN0IG9yZGVyIGJvb2sgZm9yIGEgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9hcGkvcmV0cmlldmVNYXJrZXREYXRhL3JlYWRCb29rLykuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIG9yZGVyIGJvb2sgZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJUaWNrPn0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIG9yZGVyIGJvb2sgaXMgcmV0cmlldmVkXG4gICAqL1xuICBnZXRCb29rKHN5bWJvbCkge1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZ2V0Qm9vayh0aGlzLl9hY2NvdW50LmlkLCBzeW1ib2wpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGNsaWVudCB1cHRpbWUgc3RhdHMgdG8gdGhlIHNlcnZlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IHVwdGltZSB1cHRpbWUgc3RhdGlzdGljcyB0byBzZW5kIHRvIHRoZSBzZXJ2ZXJcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB1cHRpbWUgc3RhdGlzdGljcyBpcyBzdWJtaXR0ZWRcbiAgICovXG4gIHNhdmVVcHRpbWUodXB0aW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5zYXZlVXB0aW1lKHRoaXMuX2FjY291bnQuaWQsIHVwdGltZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBsb2NhbCBjb3B5IG9mIHRlcm1pbmFsIHN0YXRlXG4gICAqIEByZXR1cm5zIHtUZXJtaW5hbFN0YXRlfSBsb2NhbCBjb3B5IG9mIHRlcm1pbmFsIHN0YXRlXG4gICAqL1xuICBnZXQgdGVybWluYWxTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGVybWluYWxTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGxvY2FsIGhpc3Rvcnkgc3RvcmFnZVxuICAgKiBAcmV0dXJucyB7SGlzdG9yeVN0b3JhZ2V9IGxvY2FsIGhpc3Rvcnkgc3RvcmFnZVxuICAgKi9cbiAgZ2V0IGhpc3RvcnlTdG9yYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9oaXN0b3J5U3RvcmFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHN5bmNocm9uaXphdGlvbiBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge1N5bmNocm9uaXphdGlvbkxpc3RlbmVyfSBsaXN0ZW5lciBzeW5jaHJvbml6YXRpb24gbGlzdGVuZXIgdG8gYWRkXG4gICAqL1xuICBhZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIodGhpcy5fYWNjb3VudC5pZCwgbGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgc3luY2hyb25pemF0aW9uIGxpc3RlbmVyIGZvciBzcGVjaWZpYyBhY2NvdW50XG4gICAqIEBwYXJhbSB7U3luY2hyb25pemF0aW9uTGlzdGVuZXJ9IGxpc3RlbmVyIHN5bmNocm9uaXphdGlvbiBsaXN0ZW5lciB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZVN5bmNocm9uaXphdGlvbkxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzID0gdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzLmZpbHRlcihsID0+IGwgIT09IGxpc3RlbmVyKTtcbiAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVtb3ZlU3luY2hyb25pemF0aW9uTGlzdGVuZXIodGhpcy5fYWNjb3VudC5pZCwgbGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBjb25uZWN0aW9uIHRvIE1ldGFUcmFkZXIgdGVybWluYWwgZXN0YWJsaXNoZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJlcGxpY2FzIG51bWJlciBvZiBhY2NvdW50IHJlcGxpY2FzIGxhdW5jaGVkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgYXN5bmMgb25Db25uZWN0ZWQoaW5zdGFuY2VJbmRleCwgcmVwbGljYXMpIHtcbiAgICBsZXQga2V5ID0gcmFuZG9tc3RyaW5nLmdlbmVyYXRlKDMyKTtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBzdGF0ZS5zaG91bGRTeW5jaHJvbml6ZSA9IGtleTtcbiAgICBzdGF0ZS5zeW5jaHJvbml6YXRpb25SZXRyeUludGVydmFsSW5TZWNvbmRzID0gMTtcbiAgICBzdGF0ZS5zeW5jaHJvbml6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9lbnN1cmVTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwga2V5KTtcbiAgICBsZXQgaW5kaWNlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVwbGljYXM7IGkrKykge1xuICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBlIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4KSkge1xuICAgICAgaWYgKCFpbmRpY2VzLmluY2x1ZGVzKHRoaXMuZ2V0SW5zdGFuY2VOdW1iZXIoZVsxXS5pbnN0YW5jZUluZGV4KSkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4W2VbMF1dO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gY29ubmVjdGlvbiB0byBNZXRhVHJhZGVyIHRlcm1pbmFsIHRlcm1pbmF0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICovXG4gIGFzeW5jIG9uRGlzY29ubmVjdGVkKGluc3RhbmNlSW5kZXgpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBzdGF0ZS5sYXN0RGlzY29ubmVjdGVkU3luY2hyb25pemF0aW9uSWQgPSBzdGF0ZS5sYXN0U3luY2hyb25pemF0aW9uSWQ7XG4gICAgc3RhdGUubGFzdFN5bmNocm9uaXphdGlvbklkID0gdW5kZWZpbmVkO1xuICAgIHN0YXRlLnNob3VsZFN5bmNocm9uaXplID0gdW5kZWZpbmVkO1xuICAgIHN0YXRlLnN5bmNocm9uaXplZCA9IGZhbHNlO1xuICAgIHN0YXRlLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGEgc3luY2hyb25pemF0aW9uIG9mIGhpc3RvcnkgZGVhbHMgb24gYSBNZXRhVHJhZGVyIGFjY291bnQgaGF2ZSBmaW5pc2hlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3luY2hyb25pemF0aW9uSWQgc3luY2hyb25pemF0aW9uIHJlcXVlc3QgaWRcbiAgICovXG4gIGFzeW5jIG9uRGVhbFN5bmNocm9uaXphdGlvbkZpbmlzaGVkKGluc3RhbmNlSW5kZXgsIHN5bmNocm9uaXphdGlvbklkKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUuZGVhbHNTeW5jaHJvbml6ZWRbc3luY2hyb25pemF0aW9uSWRdID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gYSBzeW5jaHJvbml6YXRpb24gb2YgaGlzdG9yeSBvcmRlcnMgb24gYSBNZXRhVHJhZGVyIGFjY291bnQgaGF2ZSBmaW5pc2hlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3luY2hyb25pemF0aW9uSWQgc3luY2hyb25pemF0aW9uIHJlcXVlc3QgaWRcbiAgICovXG4gIGFzeW5jIG9uT3JkZXJTeW5jaHJvbml6YXRpb25GaW5pc2hlZChpbnN0YW5jZUluZGV4LCBzeW5jaHJvbml6YXRpb25JZCkge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHN0YXRlLm9yZGVyc1N5bmNocm9uaXplZFtzeW5jaHJvbml6YXRpb25JZF0gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBNZXRhVHJhZGVyIGFjY291bnQgaW5mb3JtYXRpb24gaXMgdXBkYXRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge01ldGF0cmFkZXJBY2NvdW50SW5mb3JtYXRpb259IGFjY291bnRJbmZvcm1hdGlvbiB1cGRhdGVkIE1ldGFUcmFkZXIgYWNjb3VudCBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIGFzeW5jIG9uQWNjb3VudEluZm9ybWF0aW9uVXBkYXRlZChpbnN0YW5jZUluZGV4LCBhY2NvdW50SW5mb3JtYXRpb24pIHtcbiAgICBmb3IobGV0IHN5bWJvbCBvZiB0aGlzLnN1YnNjcmliZWRTeW1ib2xzKSB7XG4gICAgICBpZighdGhpcy5fdGVybWluYWxTdGF0ZS5wcmljZShzeW1ib2wpKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRJbnN0YW5jZU51bWJlcihpbnN0YW5jZUluZGV4KTtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHRoaXMuc3Vic2NyaWJlVG9NYXJrZXREYXRhKHN5bWJvbCwgdGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdLnN1YnNjcmlwdGlvbnMsIGluc3RhbmNlKSlcbiAgICAgICAgICAuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoJ1snICsgKG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCkgKyAnXSBNZXRhQXBpIHdlYnNvY2tldCBjbGllbnQgZm9yIGFjY291bnQgJyBcbiAgICAgICAgICAgICsgdGhpcy5fYWNjb3VudC5pZCArICc6JyArIGluc3RhbmNlSW5kZXggKyAnIGZhaWxlZCB0byByZXN1YnNjcmliZSB0byBzeW1ib2wgJyArIHN5bWJvbCwgZXJyKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBjb25uZWN0aW9uIHRvIE1ldGFBcGkgd2Vic29ja2V0IEFQSSByZXN0b3JlZCBhZnRlciBhIGRpc2Nvbm5lY3RcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIGNvbm5lY3Rpb24gdG8gTWV0YUFwaSB3ZWJzb2NrZXQgQVBJIHJlc3RvcmVkIGFmdGVyIGEgZGlzY29ubmVjdFxuICAgKi9cbiAgYXN5bmMgb25SZWNvbm5lY3RlZCgpIHtcbiAgICB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBhIHN0cmVhbSBmb3IgYW4gaW5zdGFuY2UgaW5kZXggaXMgY2xvc2VkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgYXN5bmMgb25TdHJlYW1DbG9zZWQoaW5zdGFuY2VJbmRleCkge1xuICAgIGRlbGV0ZSB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFtpbnN0YW5jZUluZGV4XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZsYWcgaW5kaWNhdGluZyBzdGF0dXMgb2Ygc3RhdGUgc3luY2hyb25pemF0aW9uIHdpdGggTWV0YVRyYWRlciB0ZXJtaW5hbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3luY2hyb25pemF0aW9uSWQgb3B0aW9uYWwgc3luY2hyb25pemF0aW9uIHJlcXVlc3QgaWQsIGxhc3Qgc3luY2hyb25pemF0aW9uIHJlcXVlc3QgaWQgd2lsbCBiZSB1c2VkXG4gICAqIGJ5IGRlZmF1bHRcbiAgICogQHJldHVybiB7UHJvbWlzZTxCb29sZWFuPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBhIGZsYWcgaW5kaWNhdGluZyBzdGF0dXMgb2Ygc3RhdGUgc3luY2hyb25pemF0aW9uIHdpdGggTWV0YVRyYWRlclxuICAgKiB0ZXJtaW5hbFxuICAgKi9cbiAgYXN5bmMgaXNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgc3luY2hyb25pemF0aW9uSWQpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCkucmVkdWNlKChhY2MsIHMpID0+IHtcbiAgICAgIGlmIChpbnN0YW5jZUluZGV4ICE9PSB1bmRlZmluZWQgJiYgcy5pbnN0YW5jZUluZGV4ICE9PSBpbnN0YW5jZUluZGV4KSB7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG4gICAgICBzeW5jaHJvbml6YXRpb25JZCA9IHN5bmNocm9uaXphdGlvbklkIHx8IHMubGFzdFN5bmNocm9uaXphdGlvbklkO1xuICAgICAgbGV0IHN5bmNocm9uaXplZCA9ICEhcy5vcmRlcnNTeW5jaHJvbml6ZWRbc3luY2hyb25pemF0aW9uSWRdICYmICEhcy5kZWFsc1N5bmNocm9uaXplZFtzeW5jaHJvbml6YXRpb25JZF07XG4gICAgICByZXR1cm4gYWNjIHx8IHN5bmNocm9uaXplZDtcbiAgICB9LCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gU3luY2hyb25pemF0aW9uT3B0aW9uc1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2FwcGxpY2F0aW9uUGF0dGVybl0gYXBwbGljYXRpb24gcmVndWxhciBleHByZXNzaW9uIHBhdHRlcm4sIGRlZmF1bHQgaXMgLipcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtzeW5jaHJvbml6YXRpb25JZF0gc3luY2hyb25pemF0aW9uIGlkLCBsYXN0IHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkIHdpbGwgYmUgdXNlZCBieVxuICAgKiBkZWZhdWx0XG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbaW5zdGFuY2VJbmRleF0gaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSB0byBlbnN1cmUgc3luY2hyb25pemF0aW9uIG9uLCBkZWZhdWx0IGlzIHRvIHdhaXRcbiAgICogZm9yIHRoZSBmaXJzdCBpbnN0YW5jZSB0byBzeW5jaHJvbml6ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVvdXRJblNlY29uZHNdIHdhaXQgdGltZW91dCBpbiBzZWNvbmRzLCBkZWZhdWx0IGlzIDVtXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaW50ZXJ2YWxJbk1pbGxpc2Vjb25kc10gaW50ZXJ2YWwgYmV0d2VlbiBhY2NvdW50IHJlbG9hZHMgd2hpbGUgd2FpdGluZyBmb3IgYSBjaGFuZ2UsIGRlZmF1bHQgaXMgMXNcbiAgICovXG5cbiAgLyoqXG4gICAqIFdhaXRzIHVudGlsIHN5bmNocm9uaXphdGlvbiB0byBNZXRhVHJhZGVyIHRlcm1pbmFsIGlzIGNvbXBsZXRlZFxuICAgKiBAcGFyYW0ge1N5bmNocm9uaXphdGlvbk9wdGlvbnN9IHN5bmNocm9uaXphdGlvbiBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBzeW5jaHJvbml6YXRpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCBpcyBjb21wbGV0ZWRcbiAgICogQHRocm93cyB7VGltZW91dEVycm9yfSBpZiBhcHBsaWNhdGlvbiBmYWlsZWQgdG8gc3luY2hyb25pemUgd2l0aCB0aGUgdGVtaW5hbCB3aXRoaW5nIHRpbWVvdXQgYWxsb3dlZFxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgYXN5bmMgd2FpdFN5bmNocm9uaXplZChvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgbGV0IGluc3RhbmNlSW5kZXggPSBvcHRzLmluc3RhbmNlSW5kZXg7XG4gICAgbGV0IHN5bmNocm9uaXphdGlvbklkID0gb3B0cy5zeW5jaHJvbml6YXRpb25JZDtcbiAgICBsZXQgdGltZW91dEluU2Vjb25kcyA9IG9wdHMudGltZW91dEluU2Vjb25kcyB8fCAzMDA7XG4gICAgbGV0IGludGVydmFsSW5NaWxsaXNlY29uZHMgPSBvcHRzLmludGVydmFsSW5NaWxsaXNlY29uZHMgfHwgMTAwMDtcbiAgICBsZXQgYXBwbGljYXRpb25QYXR0ZXJuID0gb3B0cy5hcHBsaWNhdGlvblBhdHRlcm4gfHxcbiAgICAgICh0aGlzLl9hY2NvdW50LmFwcGxpY2F0aW9uID09PSAnQ29weUZhY3RvcnknID8gJ0NvcHlGYWN0b3J5Lip8UlBDJyA6ICdSUEMnKTtcbiAgICBsZXQgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgc3luY2hyb25pemVkO1xuICAgIHdoaWxlICghKHN5bmNocm9uaXplZCA9IGF3YWl0IHRoaXMuaXNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgc3luY2hyb25pemF0aW9uSWQpKSAmJlxuICAgICAgKHN0YXJ0VGltZSArIHRpbWVvdXRJblNlY29uZHMgKiAxMDAwKSA+IERhdGUubm93KCkpIHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgaW50ZXJ2YWxJbk1pbGxpc2Vjb25kcykpO1xuICAgIH1cbiAgICBsZXQgc3RhdGU7XG4gICAgaWYgKGluc3RhbmNlSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yIChsZXQgcyBvZiBPYmplY3QudmFsdWVzKHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4KSkge1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5pc1N5bmNocm9uaXplZChzLmluc3RhbmNlSW5kZXgsIHN5bmNocm9uaXphdGlvbklkKSkge1xuICAgICAgICAgIHN0YXRlID0gcztcbiAgICAgICAgICBpbnN0YW5jZUluZGV4ID0gcy5pbnN0YW5jZUluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlID0gT2JqZWN0LnZhbHVlcyh0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCkuZmluZChzID0+IHMuaW5zdGFuY2VJbmRleCA9PT0gaW5zdGFuY2VJbmRleCk7XG4gICAgfVxuICAgIGlmICghc3luY2hyb25pemVkKSB7XG4gICAgICB0aHJvdyBuZXcgVGltZW91dEVycm9yKCdUaW1lZCBvdXQgd2FpdGluZyBmb3IgTWV0YUFwaSB0byBzeW5jaHJvbml6ZSB0byBNZXRhVHJhZGVyIGFjY291bnQgJyArXG4gICAgICAgIHRoaXMuX2FjY291bnQuaWQgKyAnLCBzeW5jaHJvbml6YXRpb24gaWQgJyArIChzeW5jaHJvbml6YXRpb25JZCB8fCAoc3RhdGUgJiYgc3RhdGUubGFzdFN5bmNocm9uaXphdGlvbklkKSB8fFxuICAgICAgICAgIChzdGF0ZSAmJiBzdGF0ZS5sYXN0RGlzY29ubmVjdGVkU3luY2hyb25pemF0aW9uSWQpKSk7XG4gICAgfVxuICAgIGxldCB0aW1lTGVmdEluU2Vjb25kcyA9IE1hdGgubWF4KDAsIHRpbWVvdXRJblNlY29uZHMgLSAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSkgLyAxMDAwKTtcbiAgICBhd2FpdCB0aGlzLl93ZWJzb2NrZXRDbGllbnQud2FpdFN5bmNocm9uaXplZCh0aGlzLl9hY2NvdW50LmlkLCB0aGlzLmdldEluc3RhbmNlTnVtYmVyKGluc3RhbmNlSW5kZXgpLFxuICAgICAgYXBwbGljYXRpb25QYXR0ZXJuLCB0aW1lTGVmdEluU2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLiBUaGUgaW5zdGFuY2Ugb2YgdGhlIGNsYXNzIHNob3VsZCBubyBsb25nZXIgYmUgdXNlZCBhZnRlciB0aGlzIG1ldGhvZCBpcyBpbnZva2VkLlxuICAgKi9cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgaWYoIXRoaXMuX2Nsb3NlZCkge1xuICAgICAgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXggPSB7fTtcbiAgICAgIGF3YWl0IHRoaXMuX3dlYnNvY2tldENsaWVudC51bnN1YnNjcmliZSh0aGlzLl9hY2NvdW50LmlkKTtcbiAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZW1vdmVTeW5jaHJvbml6YXRpb25MaXN0ZW5lcih0aGlzLl9hY2NvdW50LmlkLCB0aGlzKTtcbiAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZW1vdmVTeW5jaHJvbml6YXRpb25MaXN0ZW5lcih0aGlzLl9hY2NvdW50LmlkLCB0aGlzLl90ZXJtaW5hbFN0YXRlKTtcbiAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZW1vdmVTeW5jaHJvbml6YXRpb25MaXN0ZW5lcih0aGlzLl9hY2NvdW50LmlkLCB0aGlzLl9oaXN0b3J5U3RvcmFnZSk7XG4gICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVtb3ZlU3luY2hyb25pemF0aW9uTGlzdGVuZXIodGhpcy5fYWNjb3VudC5pZCwgdGhpcy5faGVhbHRoTW9uaXRvcik7XG4gICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnMpIHtcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJlbW92ZVN5bmNocm9uaXphdGlvbkxpc3RlbmVyKHRoaXMuX2FjY291bnQuaWQsIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZW1vdmVSZWNvbm5lY3RMaXN0ZW5lcih0aGlzKTtcbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb25SZWdpc3RyeS5yZW1vdmUodGhpcy5fYWNjb3VudC5pZCk7XG4gICAgICB0aGlzLl9oZWFsdGhNb25pdG9yLnN0b3AoKTtcbiAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc3luY2hyb25pemF0aW9uIHN0YXR1c1xuICAgKiBAcmV0dXJuIHtib29sZWFufSBzeW5jaHJvbml6YXRpb24gc3RhdHVzXG4gICAqL1xuICBnZXQgc3luY2hyb25pemVkKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4KS5yZWR1Y2UoKGFjYywgcykgPT4gYWNjIHx8IHMuc3luY2hyb25pemVkLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBNZXRhQXBpIGFjY291bnRcbiAgICogQHJldHVybiB7TWV0YXRyYWRlckFjY291bnR9IE1ldGFBcGkgYWNjb3VudFxuICAgKi9cbiAgZ2V0IGFjY291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjY291bnQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjb25uZWN0aW9uIGhlYWx0aCBtb25pdG9yIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0Nvbm5lY3Rpb25IZWFsdGhNb25pdG9yfSBjb25uZWN0aW9uIGhlYWx0aCBtb25pdG9yIGluc3RhbmNlXG4gICAqL1xuICBnZXQgaGVhbHRoTW9uaXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhbHRoTW9uaXRvcjtcbiAgfVxuXG4gIF9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSB7XG4gICAgbGV0IHRyYWRlID0ge307XG4gICAgaWYgKHR5cGVvZiBzdG9wTG9zcyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRyYWRlLnN0b3BMb3NzID0gc3RvcExvc3M7XG4gICAgfSBlbHNlIGlmIChzdG9wTG9zcykge1xuICAgICAgdHJhZGUuc3RvcExvc3MgPSBzdG9wTG9zcy52YWx1ZTtcbiAgICAgIHRyYWRlLnN0b3BMb3NzVW5pdHMgPSBzdG9wTG9zcy51bml0cztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0YWtlUHJvZml0ID09PSAnbnVtYmVyJykge1xuICAgICAgdHJhZGUudGFrZVByb2ZpdCA9IHRha2VQcm9maXQ7XG4gICAgfSBlbHNlIGlmICh0YWtlUHJvZml0KSB7XG4gICAgICB0cmFkZS50YWtlUHJvZml0ID0gdGFrZVByb2ZpdC52YWx1ZTtcbiAgICAgIHRyYWRlLnRha2VQcm9maXRVbml0cyA9IHRha2VQcm9maXQudW5pdHM7XG4gICAgfVxuICAgIHJldHVybiB0cmFkZTtcbiAgfVxuXG4gIGFzeW5jIF9lbnN1cmVTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwga2V5KSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgaWYgKHN0YXRlICYmICF0aGlzLl9jbG9zZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN5bmNocm9uaXphdGlvblJlc3VsdCA9IGF3YWl0IHRoaXMuc3luY2hyb25pemUoaW5zdGFuY2VJbmRleCk7XG4gICAgICAgIGlmKHN5bmNocm9uaXphdGlvblJlc3VsdCkge1xuICAgICAgICAgIHN0YXRlLnN5bmNocm9uaXplZCA9IHRydWU7XG4gICAgICAgICAgc3RhdGUuc3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kcyA9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbJyArIChuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpICsgJ10gTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50IGZvciBhY2NvdW50ICcgKyB0aGlzLl9hY2NvdW50LmlkICtcbiAgICAgICAgICAnOicgKyBpbnN0YW5jZUluZGV4ICsgJyBmYWlsZWQgdG8gc3luY2hyb25pemUnLCBlcnIpO1xuICAgICAgICBpZiAoc3RhdGUuc2hvdWxkU3luY2hyb25pemUgPT09IGtleSkge1xuICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5fZW5zdXJlU3luY2hyb25pemVkLmJpbmQodGhpcywgaW5zdGFuY2VJbmRleCwga2V5KSxcbiAgICAgICAgICAgIHN0YXRlLnN5bmNocm9uaXphdGlvblJldHJ5SW50ZXJ2YWxJblNlY29uZHMgKiAxMDAwKTtcbiAgICAgICAgICBzdGF0ZS5zeW5jaHJvbml6YXRpb25SZXRyeUludGVydmFsSW5TZWNvbmRzID0gTWF0aC5taW4oc3RhdGUuc3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kcyAqIDIsIDMwMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCkge1xuICAgIGlmICghdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbJycgKyBpbnN0YW5jZUluZGV4XSkge1xuICAgICAgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbJycgKyBpbnN0YW5jZUluZGV4XSA9IHtcbiAgICAgICAgaW5zdGFuY2VJbmRleCxcbiAgICAgICAgb3JkZXJzU3luY2hyb25pemVkOiB7fSxcbiAgICAgICAgZGVhbHNTeW5jaHJvbml6ZWQ6IHt9LFxuICAgICAgICBzaG91bGRTeW5jaHJvbml6ZTogdW5kZWZpbmVkLFxuICAgICAgICBzeW5jaHJvbml6YXRpb25SZXRyeUludGVydmFsSW5TZWNvbmRzOiAxLFxuICAgICAgICBzeW5jaHJvbml6ZWQ6IGZhbHNlLFxuICAgICAgICBsYXN0RGlzY29ubmVjdGVkU3luY2hyb25pemF0aW9uSWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgbGFzdFN5bmNocm9uaXphdGlvbklkOiB1bmRlZmluZWQsXG4gICAgICAgIGRpc2Nvbm5lY3RlZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFsnJyArIGluc3RhbmNlSW5kZXhdO1xuICB9XG5cbn1cbiJdfQ==